## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|---------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 6 ITR   | 1b - Window mode. Can execute service sequence only when the timeout counter is less than the value in WN Interrupt Then Reset Request For a description of how this chip implements SWT reset requests and interrupt requests resulting from SWT timeouts, see the chip-specific SWT information. NOTE 0b - Generate a reset request on a timeout 1b - Generate an interrupt on an initial timeout; generate a reset request on a second consecutive timeout |
| 5 HLK   | Hard Lock Indicates that the hard lock is enabled. Youcannot directly write 0 to this field. This field becomes0only after a reset. 0b - CR, TO, WN, and SK are read/write registers if SLK is also 0 1b - CR, TO, WN, and SK are read-only registers                                                                                                                                                                                                         |
| 4 SLK   | Soft Lock Indicates that the soft lock is enabled. You cannot directly write 0 to this field. Clear this field by writing the unlock sequence to the service register. 0b - CR, TO, WN, and SK are read/write registers if HLK is also 0 1b - CR, TO, WN, and SK are read-only registers                                                                                                                                                                      |
| 3 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 2 STP   | Stop Mode Control Controls the watchdog timer when the chip enters Stop or Standby mode. 0b - Timer continues 1b - Timer stops                                                                                                                                                                                                                                                                                                                                |
| 1 FRZ   | Debug Mode Control Controls the watchdog timer when the core enters Debug mode. 0b - Timer continues 1b - Timer stops                                                                                                                                                                                                                                                                                                                                         |
| 0 WEN   | Watchdog Enable Enables or disables SWT. The reset value is 0. Therefore, after reset, you must enable SWT to start the countdown timer.                                                                                                                                                                                                                                                                                                                      |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                   |
|---------|----------------------------|
|         | 0b - Disabled 1b - Enabled |

## 41.3.3 Interrupt (IR)

## Offset

| Register   | Offset   |
|------------|----------|
| IR         | 4h       |

## Function

The timeout interrupt flag.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | TIF  |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      | W1C  |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                   |
|---------|--------------------------------------------------------------------------------------------|
| 31-1    | Reserved                                                                                   |
| 0       | Timeout Interrupt Flag Write 1 to this field to clear the flag 0b - No interrupt request   |
| TIF     | and interrupt. Writing a 0 has no effect. 1b - Interrupt request due to an initial timeout |

## 41.3.4 Timeout (TO)

## Offset

| Register   | Offset   |
|------------|----------|
| TO         | 8h       |

## Function

Contains the 32-bit timeout period. The register is read-only if either hard lock or soft lock is enabled (CR[HLK] or CR[SLK] is 1).

## Diagram

<!-- image -->

| Bits    | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|---------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R W     |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset   | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 0    | 0    | 1    | 1    |
| Bits    | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R       |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| W Reset | 1    | 1    | 1    | 1    | 1    | 1    | 0    | 1    | 1    | 1    | 1    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                                                                                     |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | Watchdog Timeout                                                                                                                                                                             |
| WTO     | Watchdog timeout period in clock cycles. When software writes a service sequence or enables SWT,SWT loads the internal 32-bit countdown timer with this value or 100h, whichever is greater. |

## 41.3.5 Window (WN)

## Offset

| Register   | Offset   |
|------------|----------|
| WN         | Ch       |

## Function

Contains the 32-bit window start value. SWT clears this register on reset. The register is read-only if either hard lock or soft lock is enabled (CR[HLK] or CR[SLK] is 1).

Software Watchdog Timer (SWT)

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R W    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R W    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                        |
|---------|---------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | Window Start Value                                                                                                              |
| WST     | When you enable window mode (CR[WND]), you can write the service sequence only when the internal timer is less than this value. |

## 41.3.6 Service (SR)

## Offset

| Register   | Offset   |
|------------|----------|
| SR         | 10h      |

## Function

Initiates the service operation and resets the watchdog timer.

## Diagram

<!-- image -->

Software Watchdog Timer (SWT)

## Fields

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-16 -  | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 15-0 WSC | Watchdog Service Code Use this field to service the watchdog and to unlock the Soft Lock (CR[SLK]). To service the watchdog: If SWTis in keyed service mode (CR[SMD]), write two pseudorandom key values to WSC (see Service key generation for details). Otherwise, write the following values to WSC, in the order shown: 1. A602h 2. B480h To unlock the Soft Lock (CR[SLK]), write the following values to WSC, in the order shown: 1. C520h 2. D928h When read, WSC always returns zero. |

## 41.3.7 Counter Output (CO)

## Offset

| Register   | Offset   |
|------------|----------|
| CO         | 14h      |

## Function

Shows the value of the internal timer when SWT is disabled.

## Diagram

<!-- image -->

Software Watchdog Timer (SWT)

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                            |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | Watchdog Count                                                                                                                                                                                                                                                                                                                                                                                      |
| CNT     | When SWT is disabled (CR[WEN] is 0), CNT shows the value of the internal timer. When SWT is enabled (CR[WEN] is 1), it writes 0 to CNT. Values in this field can lag behind the internal timer value up to six system clock cycles plus eight counter clock cycles. Therefore, the CNTvalue that is read immediately after disabling SWT may be higher than the actual value of the internal timer. |

## 41.3.8 Service Key (SK)

## Offset

| Register   | Offset   |
|------------|----------|
| SK         | 18h      |

## Function

Holds the previous (or initial) service key value. This register is read-only if either hard lock or soft lock is enabled (CR[HLK] or CR[SLK] is 1).

## Diagram

<!-- image -->

## Fields

| Field   | Function                                                                                                                                                                     |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-16   | Reserved                                                                                                                                                                     |
| 15-0    | Service Key                                                                                                                                                                  |
| SK      | Holds the previous (or initial) service key value used in Initiate a keyed service sequence. If CR[SMD]is 01b, the next key value to write to SR is (17 * SK + 3) mod 2 16 . |

## 41.3.9 Event Request (RRR)

## Offset

| Register   | Offset   |
|------------|----------|
| RRR        | 1Ch      |

## Function

Contains the timeout reset request flag. See the chip-specific information for the specific event associated with this flag.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | RRF  |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      | W1C  |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                                  |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------|
| 31-1 -  | Reserved                                                                                                                                  |
| 0 RRF   | Reset Request Flag Write 1 to clear the flag and request. Writing 0 has no effect. 0b - No reset request 1b - Any reset request initiated |

## 41.4 Functional description

## 41.4.1 Behavior in different chip and core modes

SWT supports the core modes of operation as follows:

| Core mode   | SWT behavior                                                               |
|-------------|----------------------------------------------------------------------------|
| Normal      | When SWT is enabled (CR[WEN] = 1), the SWT timer counts down continuously. |

Table continues on the next page...

Table continued from the previous page...

| Core mode       | SWT behavior                                                                |
|-----------------|-----------------------------------------------------------------------------|
| Debug           | If CR[FRZ] = 1, SWT stops the timer; otherwise, the timer continues to run. |
| Stop or Standby | If CR[STP] = 1, SWT stops the timer; otherwise, the timer continues to run. |

## 41.4.2 Register access latency

Accesses to SWT registers occur with no peripheral bus wait states. The switch fabric may add one or more system wait states. However, due to synchronization logic in the SWT design, recognition of the service sequence or configuration changes may require up to three system clock cycles plus seven counter clock cycles.

## 41.4.3 Service key generation

SWT generates service keys with the pseudorandom key generator defined by the following equation.

## Figure 250. Pseudorandom key generator

This algorithm generates a sequence of 2 16  different key values before repeating. In keyed service sequence mode, each time you write a valid key to SR[WSC], SWT updates SK[SK] with the next key.

For example, if the previous service key (SK[SK]) is 100h, then the next service sequence keys are 1103h followed by 2136h.

## 41.4.4 Clocking

The SWT has two clock domains, one for the IPS interface and the other for the counter and reset request logic. The two clocks can be asynchronous to each other and have independent resets.

## 41.4.5 Reset

The following table describes the SWT resets:

## Table 268. SWT resets

| Reset       | Description                                           |
|-------------|-------------------------------------------------------|
| RESET_B     | It is used to reset the programming model registers.  |
| RESET_SWT_B | It is used to reset the functional domain of the SWT. |

## 41.4.6 Interrupts

The SWT generates one interrupt:

- Timeout interrupt: it is asserted when the watchdog timer count exceeds the timeout period in the TO register.

## 41.4.7 Reset only the SWT

When a timeout triggers a reset request and the application does not require a system reset, you can make the SWT instance reset itself rather than the whole system.

To make a timeout reset request trigger only an SWT reset (rather than the whole system), write 1 to the Reset Request Flag (RRR[RRF]).

This action causes SWT to:

- Clear the reset request.
- If an interrupt request also occurred, clear the interrupt request (IR[TIF]).
- Reset and restart the SWT.

For systems with multiple SWT instances, this feature allows you to reset an individual SWT instance, avoiding the widespread impact of a system reset.

## 41.4.8 Test SWT operation

When you disable SWT, it loads the current countdown timer into CO[CNT]. When you enable SWT, it clears this register. You can use CO[CNT] to perform a software self-test of SWT.

To test SWT operation:

1. Enable the SWT (CR[WEN] = 1).
2. Do not service SWT for a fixed period of time that is less than the timeout value.
3. Disable the SWT (CR[WEN] = 0).
4. Read the value in CO[CNT] to determine whether the internal countdown timer is working properly.

## NOTE

The value shown in CO[CNT] can lag behind the actual internal timer up to six system clock cycles plus eight counter clock cycles.

## 41.5 External signals

This module has no external signals.

## 41.6 Initialization

## 41.6.1 Initialize the SWT

To initialize the SWT, you must do the following:

- Select the clock source (if there are more than one possible sources).
- Set the timeout period.
- Control timeout behavior. There are two options:
- Select reset request on timeout, or
- Select interrupt on initial timeout.

You must initialize all registers before enabling SWT (CR[WEN]). You can initialize the registers in any sequence.

## 41.6.1.1 Select the clock source

See the chip-specific SWT information to find the clock source that drives the countdown timer.

## 41.6.1.2 Set the timeout period

When you enable SWT, it loads the greater of the specified watchdog timeout period or the minimum timeout period into an internal 32-bit countdown timer every time you perform a valid service operation.

To set the watchdog timeout period:

- Write the desired timeout period to TO[WTO].

The minimum timeout period is 256 clock cycles.

Software Watchdog Timer (SWT)

## 41.6.1.3 Control timeout behavior

SWT can respond to a timeout in one of two ways:

- Generate an immediate reset request on any timeout.
- Generate an interrupt and load the countdown timer on an initial timeout, then generate a reset request on a subsequent timeout.

## 41.6.1.3.1 Select reset request on timeout

To configure SWT to generate an immediate reset request on any timeout:

- Write 0 to CR[ITR].

## 41.6.1.3.2 Select interrupt on initial timeout

To configure SWT to generate an interrupt on an initial timeout:

- Write 1 to CR[ITR].

In this configuration, on the initial timeout:

- SWT loads the countdown timer with the timeout period (TO[WTO]).
- SWT indicates the interrupt with the timeout interrupt flag (IR[TIF]).
- If a second consecutive timeout occurs before writing the service sequence for the first timeout, SWT generates a reset request.

You clear the interrupt flag by writing 1 to IR[TIF].

## 41.6.1.4 Configure locking and unlocking

You can lock the SWT configuration with either a hard lock or a soft lock. When either lock is in effect, CR, TO, WN, and SK are read-only.

## 41.6.1.4.1 Enable the hard lock

To enable the hard lock:

- Write 1 to CR[HLK].

Hard lock is disabled only by a reset.

## 41.6.1.4.2 Enable the soft lock

To enable the soft lock:

- Write 1 to CR[SLK].

## 41.6.1.4.3 Unlock the soft lock

To unlock the soft lock:

1. Write C520h to SR[WSC].
2. Write D928h to SR[WSC].

This unlock sequence:

- Ignores service sequence writes.
- Recognizes the unlock sequence regardless of previous writes.
- Recognizes the unlock sequence regardless of the time between writes.
- Does not require CR[WEN] to be 1.

Software Watchdog Timer (SWT)

You can write this unlock sequence at any time.

## NOTE

It is possible for a keyed service sequence to unlock soft lock. See Avoid soft unlock for the procedure to handle this situation.

## 41.6.1.4.4 Avoid soft unlock

When SWT operates in keyed sequence service, the sequence of service keys generated by the pseudorandom generator includes the unlock keys for soft lock. If one or more service routines use both unlock keys in the proper order, 0xC520 followed at any future time by 0xD928, SWT unlocks soft lock (CR[SLK] = 0). The unlock sequence logic ignores any service keys other than the unlock keys, so the unlock keys don't have to be inserted consecutively. If the second unlock key is also the second key of a service operation, unlock occurs before the service operation completes.

To avoid unlock:

If the service routine writes a key value of C520h to SR[WSC] as a key of the service operation, then do the following:

1. Complete the service operation.
2. Complete the unlock sequence by writing the second unlock key, D928h, to SR[WSC].
3. Reinitiate the soft lock (CR[SLK] = 1).

## 41.6.1.5 Select behavior on an invalid access

SWT can respond to an invalid access one of two ways:

- Generate a bus error.
- Generate a bus error and, if SWT is enabled, a reset request.

To select how SWT responds to an invalid access:

- Write the appropriate value to CR[RIA].

## 41.6.2 Initiate service operations

When enabled, SWT requires periodic execution of a servicing operation.

SWT can operate in one of the following service sequence modes:

- Fixed service sequence
- Keyed service sequence

## 41.6.2.1 Initiate a fixed service sequence

To initiate the fixed service sequence:

1. Select the fixed servicing mode (write 00b to CR[SMD]).
2. Write A602h to SR[WSC].
3. Write B480h to SR[WSC].

There is no timing requirement between the two writes. The service sequence logic ignores unlock-sequence writes.

## 41.6.2.2 Initiate a keyed service sequence

To initiate the keyed service sequence:

1. Select the keyed servicing mode (write 01b to CR[SMD]).
2. Read the initial service key from SK[SK].

Software Watchdog Timer (SWT)

3. Calculate the next service key using the provided equation.
4. Write that service key to SR[WSC].
5. Repeat steps 2 through 4 one time.

See Service key generation for information about service keys.

## 41.6.2.3 Select window service mode

In window service mode, you must write the service sequence only when the watchdog timer is less than the window start value (WN[WST]). If you write the service sequence outside of this window, the access is invalid and generates a bus error or reset request depending on the Reset on Invalid Access setting (CR[RIA]).

For example, if the timeout period is 5000 and the window start value is 1000, you must write the service sequence during the last 20% of the timeout period.

Synchronization logic in SWT causes a slight delay in the opening of the window. This delay can be up to three system clock cycles plus four counter clock cycles.

To select window service mode:

- Write 1 to (CR[WND]).

Software Watchdog Timer (SWT)

## Chapter 42 Periodic Interrupt Timer (PIT)

## 42.1 Chip-specific PIT information

## 42.1.1 PIT module instance details

In this chip, in addition to timer channels for raising interrupts and triggering DMA channels, the PIT module is the source of:

- The external time tick for the FlexCAN free-running timer
- The external OS tick for the FlexRay stopwatch counter

## 42.1.2 PIT triggers

The following table shows the connections between the outputs of the PIT modules and other peripherals.

The PIT modules are connected to separate peripheral interface modules.

## Table 269. PIT triggers

| Timer   |   Channel | Peripheral           | Function                                                                                      |
|---------|-----------|----------------------|-----------------------------------------------------------------------------------------------|
| PIT_0   |         0 | DMAMUX_0             | Periodic trigger input 0                                                                      |
| PIT_0   |         1 | DMAMUX_0             | Periodic trigger input 1                                                                      |
| PIT_0   |         2 | DMAMUX_1             | Periodic trigger input 0                                                                      |
| PIT_0   |         3 | DMAMUX_1             | Periodic trigger input 1                                                                      |
| PIT_0   |         4 | FlexRay              | External OS tick for stopwatch counter (configured by SRC_0 FLEXRAY_OS_TICK_INPUT_SELECT_REG) |
| PIT_0   |         5 | FlexCAN_0, FlexCAN_1 | External time tick for free-running timer                                                     |
| PIT_0   |         6 | CTU                  | Trigger of CTU PWM                                                                            |
| PIT_1   |         0 | DMAMUX_2             | Periodic trigger input 0                                                                      |
| PIT_1   |         1 | DMAMUX_2             | Periodic trigger input 1                                                                      |
| PIT_1   |         2 | DMAMUX_3             | Periodic trigger input 0                                                                      |
| PIT_1   |         3 | DMAMUX_3             | Periodic trigger input 1                                                                      |
| PIT_1   |         4 | FlexCAN_2, FlexCAN_3 | External time tick for free-running timer                                                     |
| PIT_1   |         5 | -                    | -                                                                                             |

## 42.2 Overview

PIT contains an array of timers that can be used to raise interrupts and trigger DMA channels.

## 42.2.1 Block diagram

<!-- image -->

## 42.2.2 Features

The key features of the module are:

- 7 32-bit countdown timers
- Independent timeout periods for each timer
- Ability to chain two timers into a 64-bit lifetimer
- Ability of timers to generate interrupts
- Ability of timers to generate DMA trigger pulses
- Maskable interrupts

## 42.3 PIT register descriptions

This section provides a detailed description of all registers accessible in the PIT module.

- See the chip-specific PIT information for the number of PIT channels used in this MCU.

## NOTE

When a chip has more than one instance of the PIT, the different instances might have different feature and register sets. Please see the configuration information.

## 42.3.1 PIT memory map

PIT\_0 base address: 4018\_8000h

PIT\_1 base address: 4028\_8000h

Periodic Interrupt Timer (PIT)

Periodic Interrupt Timer (PIT)

| Offset   | Register                      |   Width (In bits) | Access   | Reset value   |
|----------|-------------------------------|-------------------|----------|---------------|
| 0h       | PIT Module Control (MCR)      |                32 | RW       | 0000_0000h    |
| E0h      | PIT Upper Lifetimer (LTMR64H) |                32 | R        | 0000_0000h    |
| E4h      | PIT Lower Lifetimer (LTMR64L) |                32 | R        | 0000_0000h    |
| 100h     | Timer Load Value (LDVAL0)     |                32 | RW       | 0000_0000h    |
| 104h     | Current Timer Value (CVAL0)   |                32 | R        | 0000_0000h    |
| 108h     | Timer Control (TCTRL0)        |                32 | RW       | 0000_0000h    |
| 10Ch     | Timer Flag (TFLG0)            |                32 | RW       | 0000_0000h    |
| 110h     | Timer Load Value (LDVAL1)     |                32 | RW       | 0000_0000h    |
| 114h     | Current Timer Value (CVAL1)   |                32 | R        | 0000_0000h    |
| 118h     | Timer Control (TCTRL1)        |                32 | RW       | 0000_0000h    |
| 11Ch     | Timer Flag (TFLG1)            |                32 | RW       | 0000_0000h    |
| 120h     | Timer Load Value (LDVAL2)     |                32 | RW       | 0000_0000h    |
| 124h     | Current Timer Value (CVAL2)   |                32 | R        | 0000_0000h    |
| 128h     | Timer Control (TCTRL2)        |                32 | RW       | 0000_0000h    |
| 12Ch     | Timer Flag (TFLG2)            |                32 | RW       | 0000_0000h    |
| 130h     | Timer Load Value (LDVAL3)     |                32 | RW       | 0000_0000h    |
| 134h     | Current Timer Value (CVAL3)   |                32 | R        | 0000_0000h    |
| 138h     | Timer Control (TCTRL3)        |                32 | RW       | 0000_0000h    |
| 13Ch     | Timer Flag (TFLG3)            |                32 | RW       | 0000_0000h    |
| 140h     | Timer Load Value (LDVAL4)     |                32 | RW       | 0000_0000h    |
| 144h     | Current Timer Value (CVAL4)   |                32 | R        | 0000_0000h    |
| 148h     | Timer Control (TCTRL4)        |                32 | RW       | 0000_0000h    |
| 14Ch     | Timer Flag (TFLG4)            |                32 | RW       | 0000_0000h    |
| 150h     | Timer Load Value (LDVAL5)     |                32 | RW       | 0000_0000h    |
| 154h     | Current Timer Value (CVAL5)   |                32 | R        | 0000_0000h    |
| 158h     | Timer Control (TCTRL5)        |                32 | RW       | 0000_0000h    |
| 15Ch     | Timer Flag (TFLG5)            |                32 | RW       | 0000_0000h    |
| 160h     | Timer Load Value (LDVAL6)     |                32 | RW       | 0000_0000h    |
| 164h     | Current Timer Value (CVAL6)   |                32 | R        | 0000_0000h    |
| 168h     | Timer Control (TCTRL6)        |                32 | RW       | 0000_0000h    |
| 16Ch     | Timer Flag (TFLG6)            |                32 | RW       | 0000_0000h    |

## 42.3.2 PIT Module Control (MCR)

## Offset

| Register   | Offset   |
|------------|----------|
| MCR        | 0h       |

## Function

Enables the PIT timer clocks and specifies the behavior of the timers when PIT enters Debug mode.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29    | 28   | 27 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18        | 17   | 16   |    |
|--------|------|------|-------|------|---------|------|------|------|------|------|------|------|-----------|------|------|----|
| R      | 0    | 0    | 0     | 0    | 0       | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0  |
| W      |      |      |       |      |         |      |      |      |      |      |      |      |           |      |      |    |
| Reset  | 0    | 0    | 0     | 0 0  | 0       | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    |    |
| Bits   | 15   | 14   | 13 12 | 11   | 10      | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2         | 1    | 0    |    |
| R      | 0    | 0    | 0     | 0    | 0       | 0    | 0    | 0    | 0    | 0    | 0    | 0    | Reserv ed | MDIS | FRZ  |    |
| W      |      |      |       |      |         |      |      |      |      |      |      |      |           | MDIS | FRZ  |    |
| Reset  | 0    | 0    | 0 0   | 0    | 0       | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    |    |

## Fields

| Field   | Function                                                                                                                                                                                                               |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-3 -  | Reserved                                                                                                                                                                                                               |
| 2 -     | Reserved                                                                                                                                                                                                               |
| 1 MDIS  | Module Disable for PIT Disables the standard timers. You must disable the clock (write 1 to MDIS) before configuring PIT. After configuration, you must enable the clock (write 0 to MDIS). 0b - Enables 1b - Disables |
| 0 FRZ   | Freeze Stops the timers when the device enters Debug mode. 0b - Timers run in Debug mode 1b - Timers stop in Debug mode                                                                                                |

## 42.3.3 PIT Upper Lifetimer (LTMR64H)

## Offset

| Register   | Offset   |
|------------|----------|
| LTMR64H    | E0h      |

## Function

Combined with LTMR64L, provides a 64-bit lifetimer constructed from the values in two chained PIT timers.

For more information, see Lifetimer.

## Diagram

<!-- image -->

## Fields

| Field   | Function                                                                                                                                                                                    |
|---------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | Lifetimer Value                                                                                                                                                                             |
| LTH     | Indicates the timer value of timer 1. This value is the upper 32 bits of the 64-bit lifetimer value. When you read this register at t1, the value of timer 0 at t1 is latched into LTMR64L. |

## 42.3.4 PIT Lower Lifetimer (LTMR64L)

## Offset

| Register   | Offset   |
|------------|----------|
| LTMR64L    | E4h      |

## Function

Combined with LTMR64H, provides a 64-bit lifetimer.

For more information, see Lifetimer.

Periodic Interrupt Timer (PIT)

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  | LTL  |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                                                                               |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | Lifetimer Value                                                                                                                                                                        |
| LTL     | Indicates the timer value of timer 0 at the moment LTMR64H was last read. This value is the lower 32 bits of the 64-bit lifetimer value. This field updates only when LTMR64H is read. |

## 42.3.5 Timer Load Value (LDVAL0 - LDVAL6)

## Offset

| Register   | Offset   |
|------------|----------|
| LDVAL0     | 100h     |
| LDVAL1     | 110h     |
| LDVAL2     | 120h     |
| LDVAL3     | 130h     |
| LDVAL4     | 140h     |
| LDVAL5     | 150h     |
| LDVAL6     | 160h     |

## Function

Specifies the length of the timeout period in clock cycles.

The value change is visible immediately. The synchronization mechanism allows 0 wait states in this case.

## NOTE

Each module instance supports a different number of registers.

Periodic Interrupt Timer (PIT)

See Register reset values.

Periodic Interrupt Timer (PIT)

| Instance   | Register supported   | Register not supported   |
|------------|----------------------|--------------------------|
| PIT_0      | LDVAL0-LDVAL6        | -                        |
| PIT_1      | LDVAL0-LDVAL5        | LDVAL6                   |

## Diagram

Reset

<!-- image -->

## Register reset values

| Register      | Reset value             |
|---------------|-------------------------|
| LDVAL0-LDVAL5 | PIT_0,PIT_1: 0000_0000h |
| LDVAL6        | 0000_0000h              |

## Fields

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0 TSV | Timer Start Value Specifies the starting timer value. The timer counts down until it reaches 0, then sets the interrupt flag and reloads this value. When you write a new value to this register, the timer does not restart with the new value until the current timing period expires. To terminate the current period and start a new period with the new value, you must disable the timer (write 0 to TCTRL n [TEN]) and then enable it again (write to TCTRL n [TEN]). Because the CPU requires several cycles to service an interrupt, there is a practical limit to the lowest start value for a timer. Setting the value too low may result in a lost interrupt. NOTE |

## 42.3.6 Current Timer Value (CVAL0 - CVAL6)

## Offset

| Register   | Offset   |
|------------|----------|
| CVAL0      | 104h     |
| CVAL1      | 114h     |
| CVAL2      | 124h     |
| CVAL3      | 134h     |
| CVAL4      | 144h     |
| CVAL5      | 154h     |
| CVAL6      | 164h     |

## Function

Indicates the current timer value.

## NOTE

Each module instance supports a different number of registers.

| Instance   | Register supported   | Register not supported   |
|------------|----------------------|--------------------------|
| PIT_0      | CVAL0-CVAL6          | -                        |
| PIT_1      | CVAL0-CVAL5          | CVAL6                    |

See Register reset values.

<!-- image -->

## Register reset values

| Register    | Reset value             |
|-------------|-------------------------|
| CVAL0-CVAL5 | PIT_0,PIT_1: 0000_0000h |
| CVAL6       | 0000_0000h              |

Periodic Interrupt Timer (PIT)

## Fields

| Field   | Function                           |
|---------|------------------------------------|
| 31-0    | Timer Value                        |
| TVL     | Indicates the current timer value. |

## 42.3.7 Timer Control (TCTRL0 - TCTRL6)

## Offset

| Register   | Offset   |
|------------|----------|
| TCTRL0     | 108h     |
| TCTRL1     | 118h     |
| TCTRL2     | 128h     |
| TCTRL3     | 138h     |
| TCTRL4     | 148h     |
| TCTRL5     | 158h     |
| TCTRL6     | 168h     |

## Function

Controls timer behavior.

## NOTE

Each module instance supports a different number of registers.

| Instance   | Register supported   | Register not supported   |
|------------|----------------------|--------------------------|
| PIT_0      | TCTRL0-TCTRL6        | -                        |
| PIT_1      | TCTRL0-TCTRL5        | TCTRL6                   |

## Diagram

Reset

Periodic Interrupt Timer (PIT)

<!-- image -->

## Register reset values

| Register      | Reset value             |
|---------------|-------------------------|
| TCTRL0-TCTRL5 | PIT_0,PIT_1: 0000_0000h |
| TCTRL6        | 0000_0000h              |

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                         |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-3 -  | Reserved                                                                                                                                                                                                                                                                                                                                                                         |
| 2 CHN   | Chain Mode Chains this timer (timer n , where n is > 0) to the next lower numbered timer (timer n - 1) to create a 64-bit lifetimer. When chained, timer n decrements when timer n - 1 expires. See LTMR64H and LTMR64L. You cannot chain timer 0. 0b - Unchains 1b - Chains                                                                                                     |
| 1 TIE   | Timer Interrupt Enable Enables the timer interrupt. If the interrupt is enabled, when an interrupt is pending or the Timer Interrupt Flag is set (TFLG n [TIF] = 1), PIT generates an interrupt. To avoid an interrupt when you first enable the interrupt, clear the Timer Interrupt Flag (write 1 to TFLG n [TIF]) before you enable the interrupt. 0b - Disables 1b - Enables |
| 0 TEN   | Timer Enable Enables the timer. 0b - Disables 1b - Enables. The timer begins counting down.                                                                                                                                                                                                                                                                                      |

See Register reset values.

## 42.3.8 Timer Flag (TFLG0 - TFLG6)

## Offset

| Register   | Offset   |
|------------|----------|
| TFLG0      | 10Ch     |
| TFLG1      | 11Ch     |
| TFLG2      | 12Ch     |
| TFLG3      | 13Ch     |
| TFLG4      | 14Ch     |
| TFLG5      | 15Ch     |
| TFLG6      | 16Ch     |

## Function

Indicates the PIT timer has expired.

## NOTE

Each module instance supports a different number of registers.

| Instance   | Register supported   | Register not supported   |
|------------|----------------------|--------------------------|
| PIT_0      | TFLG0-TFLG6          | -                        |
| PIT_1      | TFLG0-TFLG5          | TFLG6                    |

Reset

<!-- image -->

## Register reset values

| Register    | Reset value             |
|-------------|-------------------------|
| TFLG0-TFLG5 | PIT_0,PIT_1: 0000_0000h |
| TFLG6       | 0000_0000h              |

See Register reset values.

Periodic Interrupt Timer (PIT)

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                     |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-1 -  | Reserved                                                                                                                                                                                                                                                                                                                                     |
| 0 TIF   | Timer Interrupt Flag Indicates the timer period has expired (CVAL n [TVL] = 0). If interrupts are enabled (TCTRL n [TIE] = 1), TIF triggers an interrupt request. This field behaves differently for register reads and writes. NOTE When reading 0b - Timer has not expired 1b - Timer expired When writing 0b - No effect 1b - Clears flag |

## 42.4 Functional description

## 42.4.1 Modes of operation

| Mode   | Description                                                                    |
|--------|--------------------------------------------------------------------------------|
| Run    | All functional parts of the PIT operate normally.                              |
| Debug  | Timers run or stop depending on the Freeze setting (MCR[FRZ]). See Debug mode. |

## 42.4.2 Timer operation

When you enable a timer (write 1 to TCTRLn[TEN]), the timer counts down (one count per clock cycle) from its initial start value (LDVALn[TSV]). When the timer period expires (CVALn[TVL] reaches 0), PIT sets the Timer Interrupt Flag (writes 1 to TFLGn[TIE] or RTI\_TFLG[TIE]). It then reloads the timer start value and starts the timer counting down again.

If the timer interrupt is enabled (TCTRLn[TIE] = 1), it generates an interrupt when it sets the Timer Interrupt Flag. The timer cannot generate a new interrupt until you clear the flag from the previous interrupt.

You can read the current counter value of any timer (CVALn[TVL]).

See these related topics:

- Stop and start a timer
- Change timer period
- Change timer period dynamically

## NOTE

- If Freeze is enabled (MCR[FRZ] = 1) when the timer nears 0, the Debug mode command may not reach PIT before the timer expires and generates a trigger.
- If a timer is at zero when Debug mode is asserted, the interrupt trigger remains asserted until the device exits Debug mode. Clear the Timer Interrupt Flag (write 1 to TFLGn[TIF]) upon Debug exit.
- If Freeze is enabled (MCR[FRZ] = 1), sufficient time must be ensured for the IP to react.

## 42.4.2.1 Stop and start a timer

To restart a running timer:

1. Disable the timer (write 0 to TCTRLn[TEN]).
2. Enable the timer (write 1 to TCTRLn[TEN]).

Enabling the timer reloads the start value and starts the timer counting down again. See Stop and start a timer timing.

## 42.4.2.2 Stop and start a timer timing

<!-- image -->

## 42.4.2.3 Change timer period

To change the counter period of a running timer:

1. Disable the timer (write 0 to TCTRLn[TEN] or RTI\_TCTRL[TEN]).
2. Specify a new start value (LDVALn[TSV] or RTI\_LDVAL[TSV]).
3. Enable the timer (write 1 to TCTRLn[TEN] or RTI\_TCTRL[TEN]).

Enabling the timer loads the new start value and starts the timer counting down again. See Change timer period timing.

## 42.4.2.4 Change timer period timing

<!-- image -->

## 42.4.2.5 Change timer period dynamically

To change the counter period of a running timer:

- Specify a new start value (LDVALn[TSV] or RTI\_LDVAL[TSV])

The next time the timer expires, it loads the new start value. See Change timer period dynamically timing.

Periodic Interrupt Timer (PIT)

## 42.4.2.6 Change timer period dynamically timing

<!-- image -->

## 42.4.3 Chained timers

PIT supports chaining two timers together to support timer periods greater than FFFFFFFFh. When a timer n has chain mode enabled, it decrements each time timer n - 1 expires. The chained timer sets its Timer Interrupt Flag when it expires (CVALn - 0).

For example, assume you need to configure a timer period of 6,000,000,000 cycles. You could specify a start value of 10 for timer n and 599,999,999 for timer n - 1. With these values, the chained timer expires after timer n - 1 has expired ten times.

You cannot chain timer 0 to another timer.

For an example configuration of a chained timer, see Example configuration using chained timers.

## 42.4.4 Lifetimer

PIT supports a 64-bit lifetimer. You configure the lifetimer by chaining timer 1 to timer 0 and populating the start values for both timers with the maximum value of FFFFFFFFh. You read the lifetimer in the LTMR64H and LTMR64L registers. LTMR64H returns the upper 32 bits of the lifetimer value and LMTR64L returns the lower 32 bits. When a timer 1 has chain mode enabled, it decrements each time timer 0 expires. The lifetimer expires when CVAL1 expires.

When you chain timer 1 to timer 0, timer 1 decrements every time timer 0 expires. To obtain the correct lifetimer value, read LTMR64H first and then read LTMR64L. When you read LTMR64H, it returns the value in CVAL1 (the chained timer value), and immediately latches the value from CVAL0 into LTMR64L. This latching eliminates the carryover effects of the running counter.

For an example configuration of the lifetimer, see Example configuration using the lifetimer.

## 42.4.5 Debug mode

If Freeze is enabled (MCR[FRZ] = 1), the timers stop if the device enters Debug mode. This freeze allows the software developer to halt the processor, investigate the current state of the system, including the PIT timer values, and then continue operation.

## 42.4.6 Clocking

The PIT general-purpose timers are driven by the peripheral bus clock.

## 42.4.7 Interrupts

All of the timers support interrupt generation.

You enable interrupt generation for each individual timer (TCTRLn[TIE]). Each interrupt is available on a separate interrupt output.

When a timer expires (CVALn[TVL] = 0), it sets the Timer Interrupt Flag (TFLGn[TIF]) regardless of whether the interrupt is enabled. To enable generation of an interrupt when the the Timer Interrupt Flag is set, write 1 to TCTRLn[TIE]. To clear the Timer Interrupt Flag, write 1 to it.

## 42.5 External signals

PIT has no external inputs.

Periodic Interrupt Timer (PIT)

## 42.6 Initialization

To initialize PIT:

1. For each timer n you plan to use:
- a. Specify the timer period (LDVALn[TSV]).

To calculate the load value for a timer:

Start value = (timer period / clock period) - 1

- b. If you want the timer to generate an interrupt each time it expires, enable the timer interrupt (write 1 to TCTRLn[TIE]).
- c. If you want to use this timer as the divisor of a pair of chained timers, chain this timer to the next lower-numbered timer (write 1 to TCTRLn[CHN]). You cannot chain timer 0. If you want to use the lifetimer, chain timer 1 to timer 0.
- d. Enable the timer (write 1 to TCTRLn[TEN]).
2. Activate, or enable, PIT (write 0 to MCR[MDIS]).

All enabled timers load their start values and begin counting down.

For example configurations, see Application information.

## 42.7 Application information

## 42.7.1 Example configuration for general timers

In this example configuration:

- The PIT clock frequency is 50 MHz, which equates to a clock cycle of 20 ns.
- Timer 1 needs to generate an interrupt every 5.12 ms.
- Timer 3 needs to generate a trigger event every 30 ms.

To configure PIT for this example:

1. Disable PIT (write 1 to MCR[MDIS]).
2. Use the formula in Initialization to calculate the load value for timer 1:

(5.12 ms/20 ns) - 1 = 255,999 cycles, or 0003E7FFh.

3. Disable timer 1 (write 0 to TCTRL1[TEN]).
4. Specify the timer 1 value (write 0003E7FFh to LDVAL1[TSV]).
5. Enable the timer 1 interrupt (write 1 to TCTRL1[TIE])
6. Enable timer 1 (write 1 to TCTRL1[TEN]).
7. Calculate the load value for timer 3:

(30 ms/20 ns) - 1 = 1,499,999 cycles, or 0016E35Fh.

8. Disable timer 3 (write 0 to TCTRL3[TEN]).
9. Specify the timer 3 value (write 0016E35Fh to LDVAL3[TSV]).
10. Enable timer 3 (write 1 to TCTRL3[TEN]).
11. Activate, or enable, PIT (write 0 to MCR[MDIS]).

Periodic Interrupt Timer (PIT)

## NOTE

You can configure timers without first disabling PIT or the timer itself. However, if PIT is running, be aware that when a timer begins using a new start value depends on whether the timer is running or disabled when you specify the new start value. For more information, see Timer operation.

The following example code provides the described configuration:

```
// Disable PIT (see note above) PIT_MCR = 0x01; // Timer 1 PIT_LDVAL1 = 0x0003E7FF;    // Configure timer 1 for 256000 cycles PIT_TCTRL1 = TIE;           // Enable Timer 1 interrupts PIT_TCTRL1 |= TEN;          // Start Timer 1 // Timer 3 PIT_LDVAL3 = 0x0016E35F;    // Configure timer 3 for 1500000 cycles PIT_TCTRL3 = TEN;           // Enable Timer 3 // Enable PIT PIT_MCR = 0x00;
```

## 42.7.2 Example configuration using chained timers

In this example configuration:

- The PIT clock is frequency 100 MHz, which equates to a clock cycle of 10 ns.
- Timers 1 and 2 are available.
- An interrupt is needed every minute. Using the formula in Initialization, a 1 minute timer period requires:

```
(60 s/100 ns) - 1 = 5,999,999,999 cycles, or 165A0BBFFh
```

This value requires more than 32 bits.

To configure PIT for this example:

1. Disable PIT (write 1 to MCR[MDIS]).
2. Disable timer 1 (write 0 to TCTRL1[TEN]).
3. Disable timer 2 (write 0 to TCTRL2[TEN]).
4. Chain timer 2 to timer 1 (write 1 to TCTRL2[CHN]).
5. For the timer 2 start value, select a value that divides evenly into the desired period. For this example, we are using 10. For the timer 1 value, divide the full timer period by the selected divisor: 6,000,000,000/10 = 600,000,000.
6. Specify the timer 2 value as the selected divisor (write 0000000Ah to LDVAL2[TSV]).
7. Specify the timer 1 value as the quotient minus 1, or 599,999,999 (write 0003E7FFh to LDVAL1[TSV]).
8. Enable the timer 2 interrupt (write 1 to TCTRL2[TIE])
9. Enable timer 2 (write 1 to TCTRL2[TEN]).
10. Enable timer 1 (write 1 to TCTRL1[TEN]).
11. Activate, or enable, PIT (write 0 to MCR[MDIS]).

Periodic Interrupt Timer (PIT)

The following example code matches the described configuration:

```
// Disable PIT PIT_MCR = 0x01; // Timer 2 PIT_LDVAL2 = 0x0000000A; // Configure Timer 2 to the divisor (10) PIT_TCTRL2 = TIE;        // Enable Timer 2 interrupt PIT_TCTRL2 |= CHN;       // Chain Timer 2 to Timer 1 PIT_TCTRL2 |= TEN;       // Enable Timer 2 // Timer 1 PIT_LDVAL1 = 0x23C345FF; // Configure Timer 1 to 600,000,000 cycles PIT_TCTRL1 = TEN;        // Enable Timer 1 // Enable PIT PIT_MCR = 0x00;
```

## 42.7.3 Example configuration using the lifetimer

To configure the lifetimer:

1. Disable PIT (write 1 to MCR[MDIS]).
2. Disable timer 0 (write 0 to TCTRL0[TEN]).
3. Disable timer 1 (write 0 to TCTRL1[TEN]).
4. Chain timer 1 to timer 0 (write 1 to TCTRL1[CHN]).
5. Specify the maximum start value for timer 1 (write FFFFFFFFh to LDVAL1[TSV]).
6. Specify the maximum start value for timer 0 (write FFFFFFFFh to LDVAL0[TSV]).
7. Enable timer 1 (write 1 to TCTRL1[TEN]).
8. Enable timer 0 (write 1 to TCTRL0[TEN]).
9. Activate, or enable, PIT (write 0 to MCR[MDIS]).

To access the lifetimer, first read LTMR64H and then LTMR64L. For more information, see Lifetimer.

The following example code matches the described setup:

```
// turn on PIT PIT_MCR = 0x00; // Timer 1 PIT_LDVAL1 = 0xFFFFFFFF; // setup timer 1 for maximum counting period PIT_TCTRL1 = 0x0; // disable timer 1 interrupts PIT_TCTRL1 |= CHN; // chain timer 1 to timer 0 PIT_TCTRL1 |= TEN; // start timer 1 // Timer 0
```

Periodic Interrupt Timer (PIT)

```
PIT_LDVAL0 = 0xFFFFFFFF; // setup timer 0 for maximum counting period PIT_TCTRL0 = TEN; // start timer 0 // Read lifetimer current_uptime = PIT_LTMR64H<<32; current_uptime = current_uptime + PIT_LTMR64L;
```

Periodic Interrupt Timer (PIT)

## Chapter 43 FlexTimer (FTM)

## 43.1 Chip-specific FTM information

## 43.1.1 FTM instances

The chip contains two FTM instances: FTM\_0 and FTM\_1.

The following table summarizes the features for each instance.

Table 270. FTM instance features

| Feature                           | FTM_0   | FTM_1   |
|-----------------------------------|---------|---------|
| Number of channels                | 6       | 6       |
| Input filter on channel 0         | Yes     | Yes     |
| Input filter on channel 1         | Yes     | Yes     |
| Input filter on channel 2         | Yes     | Yes     |
| Input filter on channel 3         | Yes     | Yes     |
| Number of fault inputs            | 0       | 0       |
| Quadrature decoder                | Yes     | Yes     |
| DMA support                       | Yes     | Yes     |
| Output Buffer Enable active value | 1       | 1       |
| Half-cycle reload                 | Yes     | Yes     |
| Dithering                         | Yes     | Yes     |

## 43.1.2 FTM global time base

This chip provides the optional FTM global time base feature. For more details, see the Global time base (GTB) section of this chapter. FTM0 provides the only source for the FTM global time base. The FTM1 module can share the same time base as shown in the following figure.

<!-- image -->

## 43.1.3 Initialization triggers and external triggers

The following table shows FlexTimer trigger connections.

Table 271. FTM trigger connections

| Timer   | Trigger or channel   | Connection    |
|---------|----------------------|---------------|
| FTM_0   | Trigger_0 input      | GMAC_0        |
| FTM_0   | Trigger_1 input      | Reserved      |
| FTM_0   | Trigger_2 input      | Reserved      |
| FTM_1   | Trigger_0 input      | GMAC_0        |
| FTM_1   | Trigger_1 input      | Reserved      |
| FTM_1   | Trigger_2 input      | Reserved      |
| FTM_0   | Channel_0 output     | CTU trigger 0 |
| FTM_0   | Channel_1 output     | CTU trigger 1 |
| FTM_0   | Channel_2 output     | CTU trigger 2 |
| FTM_0   | Channel_5 output     | GMAC_0        |
| FTM_1   | Channel_0 output     | CTU trigger 3 |
| FTM_1   | Channel_1 output     | CTU trigger 4 |
| FTM_1   | Channel_2 output     | CTU trigger 5 |
| FTM_1   | Channel_5 output     | GMAC_0        |

## 43.2 Introduction

The FlexTimer module (FTM) is a two-to-eight channel timer that supports input capture, output compare, and the generation of PWM signals to control electric motor and power management applications. The FTM time reference is a 16-bit counter that can be used as an unsigned or signed counter.

## 43.2.1 Features

The FTM features include:

- FTM source clock is selectable
- Source clock can be the FTM input clock, the fixed frequency clock, or an external clock
- Fixed frequency clock is an additional clock input to allow the selection of an on chip clock source other than the FTM input clock
- Selecting external clock connects FTM clock to a chip level input pin therefore allowing to synchronize the FTM counter with an off chip clock source
- Prescaler divide-by 1, 2, 4, 8, 16, 32, 64, or 128
- 16-bit counter
- It can be a free-running counter or a counter with initial and final value
- The counting can be up or up-down
- Each channel can be configured for input capture, output compare, or edge-aligned PWM mode
- In Input Capture mode:

- The capture can occur on rising edges, falling edges or both edges
- An input filter can be selected for some channels. One unique prescaler is available for all filters
- In Output Compare mode the output signal can be set, cleared, or toggled on match
- All channels can be configured for center-aligned PWM mode
- Each pair of channels can be combined to generate a PWM signal with independent control of both edges of PWM signal
- The FTM channels can operate as pairs with equal outputs, pairs with complementary outputs, or independent channels with independent outputs
- The deadtime insertion is available for each complementary pair
- Generation of match triggers
- Software control of PWM outputs
- The polarity of each channel is configurable
- The generation of an interrupt per channel
- The generation of an interrupt when the counter overflows
- The generation of an interrupt when a register reload point occurs
- Synchronized loading of write buffered FTM registers
- Half cycle and Full cycle register reload capacity
- Write protection for critical registers
- Backwards compatible with TPM
- Testing of input capture mode
- Direct access to input pin states
- Dual edge capture for pulse and period width measurement
- Quadrature decoder with input filters, relative position counting, and interrupt on position count or capture of position count on external event
- The FTM channels can be selected to generate a trigger pulse on channel output instead of a PWM
- Dithering capability to simulate fine edge control for both PWM period or PWM duty cycle

## 43.2.2 Modes of operation

When the chip is in an active Debug mode, the FTM temporarily suspends all counting until the chip returns to normal user operating mode. During Stop mode, all FTM input clocks are stopped, so the FTM is effectively disabled until clocks resume. During Wait mode, the FTM continues to operate normally. If the FTM does not need to produce a real time reference or provide the interrupt sources needed to wake the chip from Wait mode, the power can then be saved by disabling FTM functions before entering Wait mode.

## 43.2.3 Block Diagram

The FTM uses one input/output (I/O) pin per channel, CHn (FTM channel (n)) where n is the channel number (0-7).

## NOTE

The number of channels supported can vary for each instance of the FTM module on a chip. See the chip-specific FTM information to see how many channels are supported for each module instance. For example, if a module instance supports only six channels, references to channel numbers 6 and 7 do not apply for that instance.

The following figure shows the FTM structure. The central component of the FTM is the 16-bit counter with programmable initial and final values and its counting can be up or up-down.

FlexTimer (FTM)

<!-- image -->

## 43.3 FTM signal descriptions

Table 272 shows the user-accessible signals for the FTM.

Table 272. FTM signal descriptions

| Signal   | Description                                                                             | I/O   | Function                                                                                                                                                                                                                                                                                 |
|----------|-----------------------------------------------------------------------------------------|-------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| EXTCLK   | External clock. FTM external clock can be selected to drive the FTM counter.            | I     | The external clock input signal is used as the FTM counter clock if selected by CLKS[1:0] bits in the SCregister. This clock signal must not exceed 1/4 of FTM input clock frequency. The FTM counter prescaler selection and settings are also used when an external clock is selected. |
| CHn      | FTM channel (n), where n can be 7-0                                                     | I/O   | Each FTM channel can be configured to operate either as input or output. The direction associated with each channel, input or output, is selected according to the mode assigned for that channel.                                                                                       |
| PHA      | Quadrature decoder phase A input. Input pin associated with quadrature decoder phase A. | I     | The quadrature decoder phase A input is used as the Quadrature Decoder mode is selected. The phase A input signal is one of the signals that control the FTM counter increment or decrement in the Quadrature Decoder Mode.                                                              |
| PHB      | Quadrature decoder phase B input. Input pin associated with quadrature decoder phase B. | I     | The quadrature decoder phase B input is used as the Quadrature Decoder mode is selected. The phase B input signal is one of the signals that control the FTM counter increment or decrement in the Quadrature Decoder Mode.                                                              |

## 43.4 Memory map and register definition

## 43.4.1 Memory map

This section presents a high-level summary of the FTM registers and how they are mapped.

The registers and bits of an unavailable function in the FTM remain in the memory map and in the reset value, but they have no active function.

## NOTE

The number of channels supported can vary for each instance of the FTM module on a chip. See the chip-specific FTM information to see how many channels are supported for each module instance.

## 43.4.2 Register descriptions

Accesses to reserved addresses result in transfer errors. Registers for absent channels are considered reserved. Double buffered register writes must be done using 32-bit operations.

## 43.4.3 FTM register descriptions

## 43.4.3.1 FTM memory map

FTM\_0 base address: 401F\_4000h

FTM\_1 base address: 402E\_4000h

FlexTimer (FTM)

| Offset   | Register                                       |   Width (In bits) | Access   | Reset value   |
|----------|------------------------------------------------|-------------------|----------|---------------|
| 0h       | Status And Control (SC)                        |                32 | RW       | 0000_0000h    |
| 4h       | Counter (CNT)                                  |                32 | RW       | 0000_0000h    |
| 8h       | Modulo (MOD)                                   |                32 | RW       | 0000_0000h    |
| Ch       | Channel (n) Status And Control (C0SC)          |                32 | RW       | 0000_0000h    |
| 10h      | Channel (n) Value (C0V)                        |                32 | RW       | 0000_0000h    |
| 14h      | Channel (n) Status And Control (C1SC)          |                32 | RW       | 0000_0000h    |
| 18h      | Channel (n) Value (C1V)                        |                32 | RW       | 0000_0000h    |
| 1Ch      | Channel (n) Status And Control (C2SC)          |                32 | RW       | 0000_0000h    |
| 20h      | Channel (n) Value (C2V)                        |                32 | RW       | 0000_0000h    |
| 24h      | Channel (n) Status And Control (C3SC)          |                32 | RW       | 0000_0000h    |
| 28h      | Channel (n) Value (C3V)                        |                32 | RW       | 0000_0000h    |
| 2Ch      | Channel (n) Status And Control (C4SC)          |                32 | RW       | 0000_0000h    |
| 30h      | Channel (n) Value (C4V)                        |                32 | RW       | 0000_0000h    |
| 34h      | Channel (n) Status And Control (C5SC)          |                32 | RW       | 0000_0000h    |
| 38h      | Channel (n) Value (C5V)                        |                32 | RW       | 0000_0000h    |
| 4Ch      | Counter Initial Value (CNTIN)                  |                32 | RW       | 0000_0000h    |
| 50h      | Capture And Compare Status (STATUS)            |                32 | RW       | 0000_0000h    |
| 54h      | Features Mode Selection (MODE)                 |                32 | RW       | 0000_0004h    |
| 58h      | Synchronization (SYNC)                         |                32 | RW       | 0000_0000h    |
| 5Ch      | Initial State For Channels Output (OUTINIT)    |                32 | RW       | 0000_0000h    |
| 60h      | Output Mask (OUTMASK)                          |                32 | RW       | 0000_0000h    |
| 64h      | Function For Linked Channels (COMBINE)         |                32 | RW       | 0000_0000h    |
| 68h      | Deadtime Configuration (DEADTIME)              |                32 | RW       | 0000_0000h    |
| 6Ch      | FTM External Trigger (EXTTRIG)                 |                32 | RW       | 0000_0000h    |
| 70h      | Channels Polarity (POL)                        |                32 | RW       | 0000_0000h    |
| 74h      | Fault Mode Status (FMS)                        |                32 | RW       | 0000_0000h    |
| 78h      | Input Capture Filter Control (FILTER)          |                32 | RW       | 0000_0000h    |
| 80h      | Quadrature Decoder Control And Status (QDCTRL) |                32 | RW       | 0000_0000h    |
| 84h      | Configuration (CONF)                           |                32 | RW       | 0000_0000h    |
| 8Ch      | Synchronization Configuration (SYNCONF)        |                32 | RW       | 0000_0000h    |
| 90h      | FTM Inverting Control (INVCTRL)                |                32 | RW       | 0000_0000h    |
| 94h      | FTM Software Output Control (SWOCTRL)          |                32 | RW       | 0000_0000h    |

Table continues on the next page...

## Table continued from the previous page...

| Offset      | Register                                                    |   Width (In bits) | Access   | Reset value   |
|-------------|-------------------------------------------------------------|-------------------|----------|---------------|
| 98h         | FTM PWM Load (PWMLOAD)                                      |                32 | RW       | 0000_0000h    |
| 9Ch         | Half Cycle Register (HCR)                                   |                32 | RW       | 0000_0000h    |
| 200h        | Mirror of Modulo Value (MOD_MIRROR)                         |                32 | RW       | 0000_0000h    |
| 204h - 218h | Mirror of Channel (n) Match Value (C0V_MIRROR - C5V_MIRROR) |                32 | RW       | 0000_0000h    |

## 43.4.3.2 Status And Control (SC)

## Offset

| Register   | Offset   |
|------------|----------|
| SC         | 0h       |

## Function

SC contains the overflow status flag and control bits used to configure the interrupt enable, FTM configuration, clock source, filter prescaler, and prescaler factor.

This register also contains the output enable control bits and the reload opportunity flag control.

These controls relate to all channels within this module.

## Diagram

<!-- image -->

## Fields

| Field   | Function   |
|---------|------------|
| 31-28   | Reserved   |

Table continues on the next page...

Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 27-24 FLTPS  | Filter Prescaler The bits FLTPS selects the clock prescaler used in the FTM filters:  channel input filters  quadrature decoder phase A and B inputs filters Writing to the bits FLTPS has immediate effect. 0000b - Divide by 1 0001b - Divide by 2 0010b - Divide by 3 0011b - Divide by 4 0100b - Divide by 5 0101b - Divide by 6 0110b - Divide by 7 0111b - Divide by 8 1000b - Divide by 9 1001b - Divide by 10 1010b - Divide by 11 1011b - Divide by 12 1100b - Divide by 13 1101b - Divide by 14 |
| 23-22 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 21-16 PWMENn | Channel n PWM enable bit This bit enables the PWM channel output. This bit should be set to 0 (output disabled) when an input mode is used. 0b - Channel output port is disabled. 1b - Channel output port is enabled.                                                                                                                                                                                                                                                                                      |
| 15-10 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 9 TOF        | Timer Overflow Flag Set by hardware when the FTM counter passes the value in the MOD register. The TOF bit is cleared by reading the SC register while TOF is set and then writing a 0 to TOF bit. Writing a 1 to TOF has no effect.                                                                                                                                                                                                                                                                        |

Table continues on the next page...

## Table continued from the previous page...

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|          | If another FTM overflow occurs between the read and write operations, the write operation has no effect; therefore, TOF remains set indicating an overflow has occurred. In this case, a TOF interrupt request is not lost due to the clearing sequence for a previous TOF. 0b - FTM counter has not overflowed. 1b - FTM counter has overflowed.                                                                                                 |
| 8 TOIE   | Timer Overflow Interrupt Enable Enables FTM overflow interrupts. 0b - Disable TOF interrupts. Use software polling. 1b - Enable TOF interrupts. An interrupt is generated when TOF equals one.                                                                                                                                                                                                                                                    |
| 7 RF     | Reload Flag The RF bit is set at each selected reload point. See Reload Points. The RF bit is cleared by reading the SC register while RF is set and then writing a 0 to RF bit. Writing 1 to RF has no effect. If another selected reload point happens between the read and write operations, the write operation has no effect; therefore, RF remains set. 0b - A selected reload point did not happen. 1b - A selected reload point happened. |
| 6 RIE    | Reload Point Interrupt Enable Enables the reload point interrupt. 0b - Reload point interrupt is disabled. 1b - Reload point interrupt is enabled.                                                                                                                                                                                                                                                                                                |
| 5 CPWMS  | Center-Aligned PWM Select Selects CPWM mode. This mode configures the FTM to operate in Up-Down Counting mode. This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - FTM counter operates in Up Counting mode. 1b - FTM counter operates in Up-Down Counting mode.                                                                                                                                                     |
| 4-3 CLKS | Clock Source Selection Selects one of the three FTM counter clock sources. This field is write protected. It can be written only when MODE[WPDIS] = 1. 00b - No clock selected. This in effect disables the FTM counter. 01b - FTM input clock 10b - Fixed frequency clock 11b - External clock                                                                                                                                                   |
| 2-0      | Prescale Factor Selection                                                                                                                                                                                                                                                                                                                                                                                                                         |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| PS      | Selects one of 8 division factors for the clock source selected by CLKS. The new prescaler factor affects the clock source on the next FTM input clock cycle after the new value is updated into the register bits. This field is write protected. It can be written only when MODE[WPDIS] = 1. 000b - Divide by 1 001b - Divide by 2 010b - Divide by 4 011b - Divide by 8 100b - Divide by 16 101b - Divide by 32 110b - Divide by 64 111b - Divide by 128 |

## 43.4.3.3 Counter (CNT)

## Offset

| Register   | Offset   |
|------------|----------|
| CNT        | 4h       |

## Function

The CNT register contains the FTM counter value.

Reset clears the CNT register. Writing any value to COUNT updates the counter with its initial value, CNTIN.

## Diagram

<!-- image -->

## Fields

| Field   | Function      |
|---------|---------------|
| 31-16   | Reserved      |
| 15-0    | Counter Value |
| COUNT   |               |

## 43.4.3.4 Modulo (MOD)

## Offset

| Register   | Offset   |
|------------|----------|
| MOD        | 8h       |

## Function

The Modulo register contains the modulo value for the FTM counter. After the FTM counter reaches the modulo value, the overflow flag (TOF) becomes set at the next clock cycle, and the next value of FTM counter depends on the selected counting method; see Counter.

Writes to the MOD register are done on its write buffer. The MOD register is updated with its write buffer value according to Registers updated from write buffers. If FTMEN = 0, a write to SC register resets manually this write coherency mechanism.

Initialize the FTM counter, by writing to CNT, before writing to the MOD register to avoid confusion about when the first counter overflow will occur.

## Diagram

<!-- image -->

| Bits    | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|---------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R       | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W       |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset   | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits    | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R       |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| W Reset | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function   |
|---------|------------|
| 31-16   | Reserved   |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function     |
|---------|--------------|
| -       |              |
| 15-0    | MOD          |
| MOD     | Modulo Value |

## 43.4.3.5 Channel (n) Status And Control (C0SC - C5SC)

## Offset

| Register   | Offset   |
|------------|----------|
| C0SC       | Ch       |
| C1SC       | 14h      |
| C2SC       | 1Ch      |
| C3SC       | 24h      |
| C4SC       | 2Ch      |
| C5SC       | 34h      |

## Function

CnSC contains channel (n) status bits and control bits that select the channel (n) mode and its functionality.

## Diagram

<!-- image -->

## Fields

| Field   | Function   |
|---------|------------|
| 31-11   | Reserved   |
| -       |            |

Table continues on the next page...

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 10 CHOV    | Channel (n) Output Value The CHOV bit has the final value of the channel (n) output. The CHOV bit should be ignored when the channel (n) is not in an output mode. NOTE 0b - The channel (n) output is zero. 1b - The channel (n) output is one.                                                                                                                                                                                                                                                                                                                                            |
| 9 CHIS     | Channel (n) Input State The CHIS bit has the value of the channel (n) input after the double-sampling or the filtering (if the channel (n) filter is enabled) both them are inside the FTM. The CHIS bit should be ignored when the channel (n) is not in an input mode. NOTE When the pair channels is on dual edge mode, the channel (n+1) CHIS bit is the channel (n+1) input value and not the channel (n) input value (this signal is the input signal used by the dual edge mode). NOTE 0b - The channel (n) input is zero.                                                           |
| 8 TRIGMODE | Trigger mode control This bit controls the trigger generation on FTM channel outputs. This mode is allowed only if when FTM channel is configured to EPWMorCPWMmodes.If a match in the channel occurs, a trigger pulse with one FTM clock cycle width will be generated in the channel output. See Channel trigger output. This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - Channel outputs will generate the normal PWM outputs without generating a pulse. 1b - If a match in the channel occurs, a trigger generation on channel output will happen. The |
| 7 CHF      | Channel (n) Flag Set by hardware when an event occurs on the channel (n). CHF is cleared by reading the CnSC register while CHF is set and then writing a 0 to the CHF bit. Writing a 1 to CHF has no effect. If another event occurs between the read and write operations, the write operation has no effect; therefore, CHFremains set indicating an event has occurred. In this case a CHFinterrupt request is not lost due to the clearing sequence for a previous CHF. 0b - No channel (n) event has occurred. 1b - A channel (n) event has occurred.                                 |
| 6          | Channel (n) Interrupt Enable Enables channel (n) interrupt.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                 |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| CHIE    | 0b - Disable channel (n) interrupt. Use software polling. 1b - Enable channel (n) interrupt.                                                                                                                                                                                                                                                                                                             |
| 5 MSB   | Channel (n) Mode Select Used on the selection of the channel (n) mode. See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                    |
| 4 MSA   | Channel (n) Mode Select Used on the selection of the channel (n) mode. See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                    |
| 3 ELSB  | Channel (n) Edge or Level Select Used on the selection of the channel (n) mode. See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                           |
| 2 ELSA  | Channel (n) Edge or Level Select Used on the selection of the channel (n) mode. See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                           |
| 1 ICRST | FTM counter reset by the selected input capture event. FTM counter reset is driven by the selected event of the channel (n) in the Input Capture mode. This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - FTM counter is not reset when the selected channel (n) input event is detected. 1b - FTM counter is reset when the selected channel (n) input event is detected. |
| 0 DMA   | DMA Enable Enables DMA transfers for the channel. 0b - Disable DMA transfers. 1b - Enable DMA transfers.                                                                                                                                                                                                                                                                                                 |

## 43.4.3.6 Channel (n) Value (C0V - C5V)

## Offset

| Register   | Offset   |
|------------|----------|
| C0V        | 10h      |
| C1V        | 18h      |
| C2V        | 20h      |

Table continues on the next page...

Table continued from the previous page...

| Register   | Offset   |
|------------|----------|
| C3V        | 28h      |
| C4V        | 30h      |
| C5V        | 38h      |

## Function

These registers contain the captured FTM counter value for the input modes or the match value for the output modes.

In Input Capture , Capture Test, and Dual Edge Capture modes, any write to a CnV register is ignored.

In output modes, writes to the CnV register are done on its write buffer. The CnV register is updated with its write buffer value according to Registers updated from write buffers. If FTMEN = 0, a write to CnSC register resets manually this write coherency mechanism.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| W      | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  | VAL  |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                              |
|---------|---------------------------------------------------------------------------------------|
| 31-16   | Reserved                                                                              |
| -       |                                                                                       |
| 15-0    | Channel Value                                                                         |
| VAL     | Captured FTM counter value of the input modes or the match value for the output modes |

## 43.4.3.7 Counter Initial Value (CNTIN)

## Offset

| Register   | Offset   |
|------------|----------|
| CNTIN      | 4Ch      |

## Function

The Counter Initial Value register contains the initial value for the FTM counter.

Writing to the CNTIN register latches the value into a buffer. The CNTIN register is updated with the value of its write buffer according to Registers updated from write buffers.

When the FTM clock is initially selected, by writing a non-zero value to the CLKS bits, the FTM counter starts with the value 0x0000. To avoid this behavior, before the first write to select the FTM clock, write the new value to the CNTIN register and then initialize the FTM counter by writing any value to the CNT register.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| W      | INIT | INIT | INIT | INIT | INIT | INIT | INIT | INIT | INIT | INIT | INIT | INIT | INIT | INIT | INIT | INIT |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function   |
|---------|------------|
| 31-16   | Reserved   |
| 15-0    | INIT       |

## 43.4.3.8 Capture And Compare Status (STATUS)

## Offset

| Register   | Offset   |
|------------|----------|
| STATUS     | 50h      |

## Function

The STATUS register contains a copy of the status flag CHF bit in CnSC for each FTM channel for software convenience.

Each CHF bit in STATUS is a mirror of CHF bit in CnSC. All CHF bits can be checked using only one read of STATUS. All CHF bits can be cleared by reading STATUS followed by writing 0x00 to STATUS.

Hardware sets the individual channel flags when an event occurs on the channel. CHF is cleared by reading STATUS while CHF is set and then writing a 0 to the CHF bit. Writing a 1 to CHF has no effect.

FlexTimer (FTM)

FlexTimer (FTM)

If another event occurs between the read and write operations, the write operation has no effect; therefore, CHF remains set indicating an event has occurred. In this case, a CHF interrupt request is not lost due to the clearing sequence for a previous CHF.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | CH5F | CH4F | CH3F | CH2F | CH1F | CH0F |
| W      |      |      |      |      |      |      |      |      |      |      | CH5F | CH4F | CH3F | CH2F | CH1F | CH0F |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field    | Function                                                                                                            |
|----------|---------------------------------------------------------------------------------------------------------------------|
| 31-6 -   | Reserved                                                                                                            |
| 5-0 CHnF | Channel n Flag See the register description. 0b - No channel event has occurred. 1b - A channel event has occurred. |

## 43.4.3.9 Features Mode Selection (MODE)

## Offset

| Register   | Offset   |
|------------|----------|
| MODE       | 54h      |

## Function

This register contains the global enable bit for FTM-specific features and the control bits used to configure:

- Capture Test mode
- PWM synchronization
- Write protection
- Channel output initialization

These controls relate to all channels within this module.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | CAPT | PWMS | WPDI | 0    | FTME |
| W      |      |      |      |      |      |      |      |      |      |      |      | EST  | YNC  | S    | INIT | N    |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |

## Fields

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-8 -    | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 7-5 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 4 CAPTEST | Capture Test Mode Enable Enables the capture test mode. This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - Capture test mode is disabled. 1b - Capture test mode is enabled.                                                                                                                                                                                                                                                                        |
| 3 PWMSYNC | PWM Synchronization Mode SelectswhichtriggerscanbeusedbyMOD,CnV,OUTMASK,andFTMcountersynchronization.SeePWM synchronization. The PWMSYNC bit configures the synchronization when SYNCMODE is 0. 0b - No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization. 1b - Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization. |
| 2 WPDIS   | Write Protection Disable When write protection is enabled (WPDIS = 0), write protected bits cannot be written. When write protection is disabled (WPDIS = 1), write protected bits can be written. The WPDIS bit is the negation of the WPEN bit. WPDIS is cleared when 1 is written to WPEN. WPDIS is set when WPEN bit is read as a 1 and then 1 is written to WPDIS. Writing 0 to WPDIS has no effect. 0b - Write protection is enabled. 1b - Write protection is disabled.    |
| 1         | Initialize The Channels Output                                                                                                                                                                                                                                                                                                                                                                                                                                                    |

Table continues on the next page...

FlexTimer (FTM)

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                    |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| INIT    | When a 1 is written to INIT bit the channels output is initialized according to the state of their corresponding bit in the OUTINIT register. Writing a 0 to INIT bit has no effect. The INIT bit is always read as 0.                                      |
| 0 FTMEN | FTM Enable This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - TPM compatibility. Free running counter and synchronization compatible with TPM. 1b - Free running counter and synchronization are different from TPM behavior. |

## 43.4.3.10 Synchronization (SYNC)

## Offset

| Register   | Offset   |
|------------|----------|
| SYNC       | 58h      |

## Function

This register configures the PWM synchronization.

A synchronization event can perform the synchronized update of MOD, CnV, and OUTMASK registers with the value of their write buffer and the FTM counter initialization.

## NOTE

The software trigger, SWSYNC bit, and hardware triggers TRIG0, TRIG1, and TRIG2 bits have a potential conflict if used together when SYNCMODE = 0. Use only hardware or software triggers but not both at the same time, otherwise unpredictable behavior is likely to happen.

The selection of the loading point, CNTMAX and CNTMIN bits, is intended to provide the update of MOD, CNTIN, and CnV registers across all enabled channels simultaneously. The use of the loading point selection together with SYNCMODE = 0 and hardware trigger selection, TRIG0, TRIG1, or TRIG2 bits, is likely to result in unpredictable behavior.

The synchronization event selection also depends on the PWMSYNC (MODE register) and SYNCMODE (SYNCONF register) bits. See PWM synchronization.

## Diagram

<!-- image -->

## Fields

| Field    | Function                                                                                                                                                                                                                                        |
|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-8 -   | Reserved                                                                                                                                                                                                                                        |
| 7 SWSYNC | PWM Synchronization Software Trigger Selects the software trigger as the PWM synchronization trigger. The software trigger happens when a 1 is written to SWSYNC bit. 0b - Software trigger is not selected. 1b - Software trigger is selected. |
| 6 TRIG2  | PWM Synchronization Hardware Trigger 2 Enables hardware trigger 2 to the PWM synchronization. Hardware trigger 2 happens when a rising edge is detected at the trigger 2 input signal. 0b - Trigger is disabled. 1b - Trigger is enabled.       |
| 5 TRIG1  | PWM Synchronization Hardware Trigger 1 Enables hardware trigger 1 to the PWM synchronization. Hardware trigger 1 happens when a rising edge is detected at the trigger 1 input signal. 0b - Trigger is disabled. 1b - Trigger is enabled.       |
| 4 TRIG0  | PWM Synchronization Hardware Trigger 0 Enables hardware trigger 0 to the PWM synchronization. Hardware trigger 0 occurs when a rising edge is detected at the trigger 0 input signal. 0b - Trigger is disabled. 1b - Trigger is enabled.        |
| 3        | Output Mask Synchronization                                                                                                                                                                                                                     |

Table continues on the next page...

FlexTimer (FTM)

## Table continued from the previous page...

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                 |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SYNCHOM  | Selects when the OUTMASK register is updated with the value of its buffer. 0b - OUTMASK register is updated with the value of its buffer in all rising edges of the FTM input clock. 1b - OUTMASK register is updated with the value of its buffer only by the PWM synchronization.                                                                                                                      |
| 2 REINIT | FTM Counter Reinitialization by Synchronization Determines if the FTM counter is reinitialized when the selected trigger for the synchronization is detected (FTM counter synchronization). The REINIT bit configures the synchronization when SYNCMODE is zero. 0b - FTM counter continues to count normally. 1b - FTM counter is updated with its initial value when the selected trigger is detected. |
| 1 CNTMAX | Maximum Loading Point Enable Selects the maximum loading point to PWM synchronization (Synchronization Points). If CNTMAX is 1, the selected loading point is when the FTM counter reaches its maximum value (MOD register). 0b - The maximum loading point is disabled. 1b - The maximum loading point is enabled.                                                                                      |
| 0 CNTMIN | Minimum Loading Point Enable Selects the minimum loading point to PWM synchronization (Synchronization Points). If CNTMIN is 1, the selected loading point is when the FTM counter reaches its minimum value (CNTIN register). 0b - The minimum loading point is disabled. 1b - The minimum loading point is enabled.                                                                                    |

## 43.4.3.11 Initial State For Channels Output (OUTINIT)

## Offset

| Register   | Offset   |
|------------|----------|
| OUTINIT    | 5Ch      |

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21    | 20    | 19    | 18    | 17    | 16    |
|--------|------|------|------|------|------|------|------|------|------|------|-------|-------|-------|-------|-------|-------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0     | 0     | 0     | 0     | 0     |
| W      |      |      |      |      |      |      |      |      |      |      |       |       |       |       |       |       |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0     | 0     | 0     | 0     | 0     |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5     | 4     | 3     | 2     | 1     | 0     |
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | CH5OI | CH4OI | CH3OI | CH2OI | CH1OI | CH0OI |
| W      |      |      |      |      |      |      |      |      |      |      |       |       |       |       |       |       |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0     | 0     | 0     | 0     | 0     |

## Fields

| Field   | Function                                                                                                                                |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------|
| 31-6 -  | Reserved                                                                                                                                |
| 5-0     | Channel n Output Initialization Value Selects the value that is forced into the channel output when 0b - The initialization value is 0. |
| CHnOI   | the initialization occurs. 1b - The initialization value is 1.                                                                          |

## 43.4.3.12 Output Mask (OUTMASK)

## Offset

| Register   | Offset   |
|------------|----------|
| OUTMASK    | 60h      |

## Function

This register provides a mask for each FTM channel. The mask of a channel determines if its output responds, that is, it is masked or not, when a match occurs. This feature is used for BLDC control where the PWM signal is presented to an electric motor at specific times to provide electronic commutation.

Any write to the OUTMASK register, stores the value in its write buffer. The register is updated with the value of its write buffer according to PWM synchronization.

Output Mask bits must not be set for trigger mode.

FlexTimer (FTM)

## Diagram

<!-- image -->

## Fields

| Field     | Function                                                                                                                                                                                                           |
|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-6 -    | Reserved                                                                                                                                                                                                           |
| 5-0 CHnOM | Channel n Output Mask Defines if the channel output is masked or unmasked. 0b - Channel output is not masked. It continues to operate normally. 1b - Channel output is masked. It is forced to its inactive state. |

## 43.4.3.13 Function For Linked Channels (COMBINE)

## Offset

| Register   | Offset   |
|------------|----------|
| COMBINE    | 64h      |

## Function

This register contains the configuration bits for each pair of channels.

FlexTimer (FTM)

## Diagram

<!-- image -->

| Bits   | 31          | 30   | 29       | 28     | 27      | 26        | 25     | 24        | 23          | 22   | 21       | 20     | 19      | 18        | 17     | 16        |
|--------|-------------|------|----------|--------|---------|-----------|--------|-----------|-------------|------|----------|--------|---------|-----------|--------|-----------|
| R      | 0           | 0    | 0        | 0      | 0       | 0         | 0      | 0         | MCOM        | 0    | SYNC     | DTEN   | DECA    | DECA      | COMP   | COMB      |
| W      |             |      |          |        |         |           |        |           | BIN...      |      | EN2      | 2      | P2      | PEN2      | 2      | INE2      |
| Reset  | 0           | 0    | 0        | 0      | 0       | 0         | 0      | 0         | 0           | 0    | 0        | 0      | 0       | 0         | 0      | 0         |
| Bits   | 15          | 14   | 13       | 12     | 11      | 10        | 9      | 8         | 7           | 6    | 5        | 4      | 3       | 2         | 1      | 0         |
| R W    | MCOM BIN... | 0    | SYNC EN1 | DTEN 1 | DECA P1 | DECA PEN1 | COMP 1 | COMB INE1 | MCOM BIN... | 0    | SYNC EN0 | DTEN 0 | DECA P0 | DECA PEN0 | COMP 0 | COMB INE0 |
| Reset  | 0           | 0    | 0        | 0      | 0       | 0         | 0      | 0         | 0           | 0    | 0        | 0      | 0       | 0         | 0      | 0         |

## Fields

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                          |
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-24 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                          |
| 23 MCOMBINE2 | Modified Combine Mode For n = 4 Used on the selection of the modified combine mode for channels (n) and (n+1). See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                     |
| 22 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                          |
| 21 SYNCEN2   | Synchronization Enable For n = 4 Enables PWM synchronization of registers C(n)V and C(n+1)V. 0b - The PWM synchronization in this pair of channels is disabled. 1b - The PWM synchronization in this pair of channels is enabled.                                                                                                                                                 |
| 20 DTEN2     | Deadtime Enable For n = 4 Enables the deadtime insertion in the channels (n) and (n+1). This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - The deadtime insertion in this pair of channels is disabled. 1b - The deadtime insertion in this pair of channels is enabled.                                                                            |
| 19 DECAP2    | Dual Edge Capture Mode Captures For n = 4 Enables the capture of the FTMcounter value according to the channel (n) input event and the configuration of the dual edge capture bits. This field applies only when DECAPEN = 1. DECAPbit is cleared automatically by hardware if dual edge capture - one-shot mode is selected and when the capture of channel (n+1) event is made. |

Table continues on the next page...

FlexTimer (FTM)

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|              | 0b - The dual edge captures are inactive. 1b - The dual edge captures are active.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 18 DECAPEN2  | Dual Edge Capture Mode Enable For n = 4 Enables the Dual Edge Capture mode in the channels (n) and (n+1). See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                                                |
| 17 COMP2     | Complement Of Channel (n) For n = 4 In Complementary mode the channel (n+1) output is the inverse of the channel (n) output. This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - If the channels (n) and (n+1) are in Combine Mode or Modified Combine PWM Mode, the channel (n+1) output is the same as the channel (n) output. If the channel (n+1) is in Output Compare Mode, EPWM or CPWM, the channel (n+1) output is independent from channel (n) output. 1b - The channel (n+1) output is the complement of the channel (n) output. |
| 16 COMBINE2  | Combine Channels For n = 4 Used on the selection of the combine mode for channels (n) and (n+1). See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                                                         |
| 15 MCOMBINE1 | Modified Combine Mode For n = 2 Used on the selection of the modified combine mode for channels (n) and (n+1). See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                                           |
| 14 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 13 SYNCEN1   | Synchronization Enable For n = 2 Enables PWM synchronization of registers C(n)V and C(n+1)V. 0b - The PWM synchronization in this pair of channels is disabled. 1b - The PWM synchronization in this pair of channels is enabled.                                                                                                                                                                                                                                                                                                                                       |
| 12 DTEN1     | Deadtime Enable For n = 2 Enables the deadtime insertion in the channels (n) and (n+1). This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - The deadtime insertion in this pair of channels is disabled. 1b - The deadtime insertion in this pair of channels is enabled.                                                                                                                                                                                                                                                                  |
| 11 DECAP1    | Dual Edge Capture Mode Captures For n = 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |

Table continues on the next page...

## Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | Enables the capture of the FTMcounter value according to the channel (n) input event and the configuration of the dual edge capture bits. This field applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if Dual Edge Capture - One-Shot mode is selected and when the capture of channel (n+1) event is made. 0b - The dual edge captures are inactive. 1b - The dual edge captures are active.                                                                                                                                              |
| 10 DECAPEN1 | Dual Edge Capture Mode Enable For n = 2 Enables the Dual Edge Capture mode in the channels (n) and (n+1). See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                                                |
| 9 COMP1     | Complement Of Channel (n) For n = 2 In Complementary mode the channel (n+1) output is the inverse of the channel (n) output. This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - If the channels (n) and (n+1) are in Combine Mode or Modified Combine PWM Mode, the channel (n+1) output is the same as the channel (n) output. If the channel (n+1) is in Output Compare Mode, EPWM or CPWM, the channel (n+1) output is independent from channel (n) output. 1b - The channel (n+1) output is the complement of the channel (n) output. |
| 8 COMBINE1  | Combine Channels For n = 2 Used on the selection of the combine mode for channels (n) and (n+1). See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                                                         |
| 7 MCOMBINE0 | Modified Combine Mode For n = 0 Used on the selection of the modified combine mode for channels (n) and (n+1). See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                                           |
| 6 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 5 SYNCEN0   | Synchronization Enable For n = 0 Enables PWM synchronization of registers C(n)V and C(n+1)V. 0b - The PWM synchronization in this pair of channels is disabled. 1b - The PWM synchronization in this pair of channels is enabled.                                                                                                                                                                                                                                                                                                                                       |
| 4 DTEN0     | Deadtime Enable For n = 0 Enables the deadtime insertion in the channels (n) and (n+1). This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                                                                                     |

Table continues on the next page...

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | 0b - The deadtime insertion in this pair of channels is disabled. 1b - The deadtime insertion in this pair of channels is enabled.                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 3 DECAP0   | Dual Edge Capture Mode Captures For n = 0 Enables the capture of the FTMcounter value according to the channel (n) input event and the configuration of the dual edge capture bits. This field applies only when DECAPEN = 1. DECAPbit is cleared automatically by hardware if dual edge capture - one-shot mode is selected and when the capture of channel (n+1) event is made. 0b - The dual edge captures are inactive. 1b - The dual edge captures are active.                                                                                                     |
| 2 DECAPEN0 | Dual Edge Capture Mode Enable For n = 0 Enables the Dual Edge Capture mode in the channels (n) and (n+1). See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                                                |
| 1 COMP0    | Complement Of Channel (n) For n = 0 In Complementary mode the channel (n+1) output is the inverse of the channel (n) output. This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - If the channels (n) and (n+1) are in Combine Mode or Modified Combine PWM Mode, the channel (n+1) output is the same as the channel (n) output. If the channel (n+1) is in Output Compare Mode, EPWM or CPWM, the channel (n+1) output is independent from channel (n) output. 1b - The channel (n+1) output is the complement of the channel (n) output. |
| 0 COMBINE0 | Combine Channels For n = 0 Used on the selection of the combine mode for channels (n) and (n+1). See Channel Modes. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                                                         |

## 43.4.3.14 Deadtime Configuration (DEADTIME)

## Offset

| Register   | Offset   |
|------------|----------|
| DEADTIME   | 68h      |

## Function

This register selects the deadtime prescaler and value for all pair of channels.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22    | 21    | 20    | 19      | 18      | 17      | 16      |
|--------|------|------|------|------|------|------|------|------|------|-------|-------|-------|---------|---------|---------|---------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0     | 0     |         |         |         |         |
| W      |      |      |      |      |      |      |      |      |      |       |       |       | DTVALEX | DTVALEX | DTVALEX | DTVALEX |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0     | 0     | 0       | 0       | 0       | 0       |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6     | 5     | 4     | 3       | 2       | 1       | 0       |
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | DTPS |       |       |       |         |         |         |         |
| W      |      |      |      |      |      |      |      |      | DTPS | DTVAL | DTVAL | DTVAL | DTVAL   | DTVAL   | DTVAL   | DTVAL   |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0     | 0     | 0       | 0       | 0       | 0       |

## Fields

| Field         | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-20 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 19-16 DTVALEX | Extended Deadtime Value This field is a bit extension of the DTVAL field. It defines the 4 most significant bits of the deadtime value. The maximum deadtime value is extended to 1023 using the concatenation {DTVALEX, DTVAL}. Deadtime insert value = (DTPS  {DTVALEX, DTVAL}). This field is write protected. It can be written only when MODE[WPDIS] = 1. If full compatibility is needed with previous software versions, write 0 to DTVALEX bits. NOTE |
| 15-8 -        | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 7-6 DTPS      | Deadtime Prescaler Value Selects the division factor of the FTM input clock. This prescaled clock is used by the deadtime counter. This field is write protected. It can be written only when MODE[WPDIS] = 1. 0xb - Divide the FTM input clock by 1. 10b - Divide the FTM input clock by 4. 11b - Divide the FTM input clock by 16.                                                                                                                           |
| 5-0 DTVAL     | Deadtime Value Selects the deadtime value. This field is write protected. It can be written only when MODE[WPDIS] = 1.                                                                                                                                                                                                                                                                                                                                         |

FlexTimer (FTM)

## 43.4.3.15 FTM External Trigger (EXTTRIG)

## Offset

| Register   | Offset   |
|------------|----------|
| EXTTRIG    | 6Ch      |

## Function

This register:

- Indicates when the external trigger was generated
- Enables the generation of a trigger when the FTM counter is equal to its initial value
- Selects which channels are used in the generation of the external trigger

## Diagram

<!-- image -->

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                  |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-10 - | Reserved                                                                                                                                                                                                                                                                                                                                                                                  |
| 9 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                                  |
| 8 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                                  |
| 7 TRIGF | Channel Trigger Flag Set by hardware when a channel trigger is generated. Clear TRIGF by reading EXTTRIG while TRIGF is set and then writing a 0 to TRIGF. Writing a 1 to TRIGF has no effect. If another channel trigger is generated before the clearing sequence is completed, the sequence is reset so TRIGF remains set after the clear sequence is completed for the earlier TRIGF. |

Table continues on the next page...

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                      |
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|              | 0b - No channel trigger was generated. 1b - A channel trigger was generated.                                                                                                                                                                  |
| 6 INITTRIGEN | Initialization Trigger Enable Enables the generation of the trigger when the FTM counter is equal to the CNTIN register. 0b - The generation of initialization trigger is disabled. 1b - The generation of initialization trigger is enabled. |
| 5 CH1TRIG    | Channel 1 External Trigger Enable Enables the generation of the external trigger when FTM counter = C1V. 0b - The generation of this external trigger is disabled. 1b - The generation of this external trigger is enabled.                   |
| 4 CH0TRIG    | Channel 0 External Trigger Enable Enables the generation of the external trigger when FTM counter = C0V. 0b - The generation of this external trigger is disabled. 1b - The generation of this external trigger is enabled.                   |
| 3 CH5TRIG    | Channel 5 External Trigger Enable Enables the generation of the external trigger when FTM counter = C5V. 0b - The generation of this external trigger is disabled. 1b - The generation of this external trigger is enabled.                   |
| 2 CH4TRIG    | Channel 4 External Trigger Enable Enables the generation of the external trigger when FTM counter = C4V. 0b - The generation of this external trigger is disabled. 1b - The generation of this external trigger is enabled.                   |
| 1 CH3TRIG    | Channel 3 External Trigger Enable Enables the generation of the external trigger when FTM counter = C3V. 0b - The generation of this external trigger is disabled. 1b - The generation of this external trigger is enabled.                   |
| 0 CH2TRIG    | Channel 2 External Trigger Enable Enables the generation of the external trigger when FTM counter = C2V. 0b - The generation of this external trigger is disabled. 1b - The generation of this external trigger is enabled.                   |

## 43.4.3.16 Channels Polarity (POL)

## Offset

| Register   | Offset   |
|------------|----------|
| POL        | 70h      |

## Function

This register defines the output polarity of the FTM channels.

<!-- image -->

## Fields

| Field    | Function                                                                                                                                                                                                                   |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-6     | Reserved                                                                                                                                                                                                                   |
| 5-0 POLn | Channel n Polarity Defines the polarity of the channel output. This field is write protected. It can be written only when MODE[WPDIS] = 0b - The channel polarity is active high. 1b - The channel polarity is active low. |

## 43.4.3.17 Fault Mode Status (FMS)

## Offset

| Register   | Offset   |
|------------|----------|
| FMS        | 74h      |

## Function

This register contains:

- the write protection enable bit

## Diagram

<!-- image -->

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                    |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-7 -  | Reserved                                                                                                                                                                                                                                                                                                                                                                    |
| 6 WPEN  | Write Protection Enable The WPEN bit is the negation of the WPDIS bit. WPEN is set when 1 is written to it. WPEN is cleared when WPEN bit is read as a 1 and then 1 is written to WPDIS. Writing 0 to WPEN has no effect. 0b - Write protection is disabled. Write protected bits can be written. 1b - Write protection is enabled. Write protected bits cannot be written. |
| 5 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                    |
| 4 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                    |
| 3       | Reserved                                                                                                                                                                                                                                                                                                                                                                    |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function   |
|---------|------------|
| -       |            |
| 2       | Reserved   |
| -       |            |
| 1       | Reserved   |
| 0       | Reserved   |

## 43.4.3.18 Input Capture Filter Control (FILTER)

## Offset

| Register   | Offset   |
|------------|----------|
| FILTER     | 78h      |

## Function

This register selects the filter value for the inputs of channels.

Channels 4, 5, 6 and 7 do not have an input filter.

| Diagram Bits   | 31      | 30      | 29      | 28      | 27      | 26      | 25      | 24      | 23      | 22      | 21      | 20      | 19      | 18      | 17      | 16      |
|----------------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|
| R              | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |
| W              |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |
| Reset          | 0       | 0       | 0       | 0 0     |         | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |
| Bits           | 15      | 14      | 13      | 12      | 11      | 10      | 9       | 8       | 7       | 6       | 5       | 4       | 3       | 2       | 1       | 0       |
| R W            | CH3FVAL | CH3FVAL | CH3FVAL | CH3FVAL | CH2FVAL | CH2FVAL | CH2FVAL | CH2FVAL | CH1FVAL | CH1FVAL | CH1FVAL | CH1FVAL | CH0FVAL | CH0FVAL | CH0FVAL | CH0FVAL |
| Reset          | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |

<!-- image -->

## Fields

| Field         | Function                                                                                                              |
|---------------|-----------------------------------------------------------------------------------------------------------------------|
| 31-16 -       | Reserved                                                                                                              |
| 15-12 CH3FVAL | Channel 3 Input Filter Selects the filter value for the channel input. The filter is disabled when the value is zero. |
| 11-8 CH2FVAL  | Channel 2 Input Filter Selects the filter value for the channel input. The filter is disabled when the value is zero. |
| 7-4 CH1FVAL   | Channel 1 Input Filter Selects the filter value for the channel input. The filter is disabled when the value is zero. |
| 3-0 CH0FVAL   | Channel 0 Input Filter Selects the filter value for the channel input. The filter is disabled when the value is zero. |

## 43.4.3.19 Quadrature Decoder Control And Status (QDCTRL)

## Offset

| Register   | Offset   |
|------------|----------|
| QDCTRL     | 80h      |

## Function

This register has the control and status bits for the Quadrature Decoder mode.

## Diagram

<!-- image -->

## Fields

| Field       | Function                                                                                                                                                                                                                                                                                                                                  |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-8 -      | Reserved                                                                                                                                                                                                                                                                                                                                  |
| 7 PHAFLTREN | Phase A Input Filter Enable Enables the filter for the quadrature decoder phase A input. The filter value for the phase A input is defined by the CH0FVAL field of FILTER. The phase A filter is also disabled when CH0FVAL is zero. 0b - Phase A input filter is disabled. 1b - Phase A input filter is enabled.                         |
| 6 PHBFLTREN | Phase B Input Filter Enable Enables the filter for the quadrature decoder phase B input. The filter value for the phase B input is defined by the CH1FVAL field of FILTER. The phase B filter is also disabled when CH1FVAL is zero. 0b - Phase B input filter is disabled. 1b - Phase B input filter is enabled.                         |
| 5 PHAPOL    | Phase A Input Polarity Selects the polarity for the quadrature decoder phase A input. 0b - Normal polarity. Phase A input signal is not inverted before identifying the rising and falling edges of this signal. 1b - Inverted polarity. Phase A input signal is inverted before identifying the rising and falling edges of this signal. |
| 4 PHBPOL    | Phase B Input Polarity Selects the polarity for the quadrature decoder phase B input. 0b - Normal polarity. Phase B input signal is not inverted before identifying the rising and falling edges of this signal. 1b - Inverted polarity. Phase B input signal is inverted before identifying the rising and falling edges of this signal. |
| 3 QUADMODE  | Quadrature Decoder Mode Selects the encoding mode used in the Quadrature Decoder mode. 0b - Phase A and phase B encoding mode. 1b - Count and direction encoding mode.                                                                                                                                                                    |
| 2 QUADIR    | FTM Counter Direction In Quadrature Decoder Mode Indicates the counting direction. 0b - Counting direction is decreasing (FTM counter decrement). 1b - Counting direction is increasing (FTM counter increment).                                                                                                                          |
| 1           | Timer Overflow Direction In Quadrature Decoder Mode                                                                                                                                                                                                                                                                                       |

Table continues on the next page...

## Table continued from the previous page...

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| TOFDIR   | Indicates if the TOF bit was set on the top or the bottom of counting. 0b - TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (CNTIN register) to its maximum value (MOD register). 1b - TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (CNTIN register). |
| 0 QUADEN | Quadrature Decoder Mode Enable Enables the Quadrature Decoder mode. In this mode, the phase A and B input signals control the FTM counter direction. The Quadrature Decoder mode has precedence over the other modes. This field is write protected. It can be written only when MODE[WPDIS] = 1. 0b - Quadrature Decoder mode is disabled. 1b - Quadrature Decoder mode is enabled.                                                                |

## 43.4.3.20 Configuration (CONF)

## Offset

| Register   | Offset   |
|------------|----------|
| CONF       | 84h      |

## Function

This register selects the frequency of the reload opportunities, the FTM behavior in Debug mode, the use of an external global time base, and the global time base signal generation.

This register also controls if initialization trigger should be generated when a reload point is reached.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27    | 26   | 25   | 24   | 23      | 22      | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|-------|------|------|------|---------|---------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0     | 0    | 0    | 0    | 0       | 0       | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |       |      |      |      |         |         |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0     | 0    | 0    | 0    | 0       | 0       | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11    | 10   | 9    | 8    | 7       | 6       | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | ITRIG | GTBE | GTBE | 0    |         |         | 0    |      |      | LDFQ |      |      |
| W      |      |      |      |      | R     | OUT  | EN   |      | BDMMODE | BDMMODE |      |      |      | LDFQ |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0     | 0    | 0    | 0    | 0       | 0       | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|-------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-12 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 11 ITRIGR   | Initialization trigger on Reload Point This bit controls whether an initialization trigger is generated when a reload point configuredbyPWMLOAD register is reached considering the FTM_CONF[LDFQ] settings. 0b - Initialization trigger is generated on counter wrap events. 1b - Initialization trigger is generated when a reload point is reached.                                                                                                                                                  |
| 10 GTBEOUT  | Global Time Base Output Enables the global time base signal generation to other FTMs. 0b - A global time base signal generation is disabled. 1b - A global time base signal generation is enabled.                                                                                                                                                                                                                                                                                                      |
| 9 GTBEEN    | Global Time Base Enable Configures the FTM to use an external global time base signal that is generated by another FTM. 0b - Use of an external global time base is disabled. 1b - Use of an external global time base is enabled.                                                                                                                                                                                                                                                                      |
| 8 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 7-6 BDMMODE | Debug Mode Selects the FTM behavior in Debug mode. See Debug mode.                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 5 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 4-0 LDFQ    | Frequency of the Reload Opportunities The LDFQ[4:0] bits define the number of enabled reload opportunities should happen until an enabled reload opportunity becomes a reload point. See Reload Points LDFQ = 0: All reload opportunities are reload points. LDFQ = 1: There is a reload point each 2 reload opportunities. LDFQ = 2: There is a reload point each 3 reload opportunities. LDFQ = 3: There is a reload point each 4 reload opportunities. This pattern continues up to a maximum of 32. |

## 43.4.3.21 Synchronization Configuration (SYNCONF)

## Offset

| Register   | Offset   |
|------------|----------|
| SYNCONF    | 8Ch      |

## Function

This register selects the PWM synchronization configuration, SWOCTRL, INVCTRL and CNTIN registers synchronization, if FTM clears the TRIGj bit, where j = 0, 1, 2, when the hardware trigger j is detected.

## Diagram

<!-- image -->

## Fields

| Field      | Function                                                                                                                                                                                                                           |
|------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-21 -    | Reserved                                                                                                                                                                                                                           |
| 20 HWSOC   | Software output control synchronization is activated by a hardware trigger 0b - A hardware trigger does not activate the SWOCTRL register synchronization. 1b - A hardware trigger activates the SWOCTRL register synchronization. |
| 19 HWINVC  | Inverting control synchronization is activated by a hardware trigger 0b - A hardware trigger does not activate the INVCTRL register synchronization. 1b - A hardware trigger activates the INVCTRL register synchronization.       |
| 18 HWOM    | Output mask synchronization is activated by a hardware trigger 0b - A hardware trigger does not activate the OUTMASK register synchronization. 1b - A hardware trigger activates the OUTMASK register synchronization.             |
| 17 HWWRBUF | MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger 0b - A hardware trigger does not activate MOD, HCR, CNTIN, and CV registers synchronization.                                                  |

Table continues on the next page...

## Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                     |
|-------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 16 HWRSTCNT | FTM counter synchronization is activated by a hardware trigger 0b - A hardware trigger does not activate the FTM counter synchronization. 1b - A hardware trigger activates the FTM counter synchronization.                                                                 |
| 15-13 -     | Reserved                                                                                                                                                                                                                                                                     |
| 12 SWSOC    | Software output control synchronization is activated by the software trigger 0b - The software trigger does not activate the SWOCTRL register synchronization. 1b - The software trigger activates the SWOCTRL register synchronization.                                     |
| 11 SWINVC   | Inverting control synchronization is activated by the software trigger 0b - The software trigger does not activate the INVCTRL register synchronization. 1b - The software trigger activates the INVCTRL register synchronization.                                           |
| 10 SWOM     | Output mask synchronization is activated by the software trigger 0b - The software trigger does not activate the OUTMASK register synchronization. 1b - The software trigger activates the OUTMASK register synchronization.                                                 |
| 9 SWWRBUF   | MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger 0b - The software trigger does not activate MOD, HCR, CNTIN, and CV registers synchronization. 1b - The software trigger activates MOD, HCR, CNTIN, and CV registers synchronization. |
| 8 SWRSTCNT  | FTM counter synchronization is activated by the software trigger 0b - The software trigger does not activate the FTM counter synchronization. 1b - The software trigger activates the FTM counter synchronization.                                                           |
| 7 SYNCMODE  | Synchronization Mode Selects the PWM Synchronization mode. 0b - Legacy PWM synchronization is selected. 1b - Enhanced PWM synchronization is selected.                                                                                                                       |
| 6 -         | Reserved                                                                                                                                                                                                                                                                     |
| 5 SWOC      | SWOCTRL Register Synchronization 0b - SWOCTRL register is updated with its buffer value at all rising edges of FTM input clock. 1b - SWOCTRL register is updated with its buffer value by the PWM synchronization.                                                           |
| 4           | INVCTRL Register Synchronization                                                                                                                                                                                                                                             |

Table continues on the next page...

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                        |
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| INVC         | 0b - INVCTRL register is updated with its buffer value at all rising edges of FTM input clock. 1b - INVCTRL register is updated with its buffer value by the PWM synchronization.                               |
| 3 -          | Reserved                                                                                                                                                                                                        |
| 2 CNTINC     | CNTIN Register Synchronization 0b - CNTIN register is updated with its buffer value at all rising edges of FTM input clock. 1b - CNTIN register is updated with its buffer value by the PWM synchronization.    |
| 1 -          | Reserved                                                                                                                                                                                                        |
| 0 HWTRIGMODE | Hardware Trigger Mode 0b - FTM clears the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2. 1b - FTM does not clear the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2. |

## 43.4.3.22 FTM Inverting Control (INVCTRL)

## Offset

| Register   | Offset   |
|------------|----------|
| INVCTRL    | 90h      |

## Function

This register controls when the channel (n) output becomes the channel (n+1) output, and channel (n+1) output becomes the channel (n) output. Each INVmEN bit enables the inverting operation for the corresponding pair channels m.

This register has a write buffer. The INVmEN bit is updated by the INVCTRL register synchronization.

## Diagram

<!-- image -->

## Fields

| Field    | Function                                                                                |
|----------|-----------------------------------------------------------------------------------------|
| 31-4 -   | Reserved                                                                                |
| 3 -      | Reserved                                                                                |
| 2 INV2EN | Pair Channels 2 Inverting Enable 0b - Inverting is disabled. 1b - Inverting is enabled. |
| 1 INV1EN | Pair Channels 1 Inverting Enable 0b - Inverting is disabled. 1b - Inverting is enabled. |
| 0 INV0EN | Pair Channels 0 Inverting Enable 0b - Inverting is disabled. 1b - Inverting is enabled. |

## 43.4.3.23 FTM Software Output Control (SWOCTRL)

## Offset

| Register   | Offset   |
|------------|----------|
| SWOCTRL    | 94h      |

## Function

This register enables software control of channel (n) output and defines the value forced to the channel (n) output:

- The CH(n)OC bits enable the control of the corresponding channel (n) output by software.
- The CH(n)OCV bits select the value that is forced at the corresponding channel (n) output.

This register has a write buffer. The fields are updated by the SWOCTRL register synchronization.

## Diagram

<!-- image -->

## Fields

| Field       | Function                                                                                                                                                                     |
|-------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-16 -     | Reserved                                                                                                                                                                     |
| 15-14 -     | Reserved                                                                                                                                                                     |
| 13-8 CHnOCV | Channel n Software Output Control Value 0b - The software output control forces 0 to the channel output. 1b - The software output control forces 1 to the channel output.    |
| 7-6 -       | Reserved                                                                                                                                                                     |
| 5-0 CHnOC   | Channel n Software Output Control Enable 0b - The channel output is not affected by software output control. 1b - The channel output is affected by software output control. |

## 43.4.3.24 FTM PWM Load (PWMLOAD)

## Offset

| Register   | Offset   |
|------------|----------|
| PWMLOAD    | 98h      |

## Function

Enables the reload of the MOD, HCR, CNTIN, C(n)V, and C(n+1)V registers with the values of their write buffers when the FTM counter changes from the MOD register value to its next value or when a channel (j) match occurs. A match occurs for channel (j) when FTM counter = C(j)V. A reload can also occurs when FTM counter = HCR register at a half cycle match. This register also controls the local and global load mechanisms.

FlexTimer (FTM)

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27     | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|--------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |        |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11     | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | 0      | GLEN | LDOK | HCSE | 0    |      | CH5S | CH4S | CH3S | CH2S | CH1S | CH0S |
| W      |      |      |      |      | GLDO K |      |      | L    |      |      | EL   | EL   | EL   | EL   | EL   | EL   |
| Reset  | 0    | 0    | 0    | 0    | 0      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-12 -  | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 11 GLDOK | Global Load OK This bit controls the global load mechanism. It generates a pulse at FTMmodule global load output with one FTM clock cycle width, which is used to set LDOK bits of FTM and other modules (including other FTMs). This bit is self-cleared and read value is always zero. The global load mechanism depends on SoC specific information. Refer to FTM SoC specific information to more details. 0b - No action. 1b - LDOK bit is set. |
| 10 GLEN  | Global Load Enable This bit enables the global load mechanism implemented by GLDOK. If GLEN bit is set, then an external event on the FTM global load input sets the LDOK bit. The clear of the LDOK bit is done by CPU writes '0' to the bit. 0b - Global Load Ok disabled. 1b - Global Load OK enabled. A pulse event on the module global load input sets the LDOK bit.                                                                           |
| 9 LDOK   | Load Enable Enables the loading of the MOD, CNTIN, HCR and CV registers with the values of their buffers. The LDOK bit can also be set by the Global Load mechanism if GLEN bit is enabled. 0b - Loading updated values is disabled. 1b - Loading updated values is enabled.                                                                                                                                                                         |
| 8 HCSEL  | Half Cycle Select                                                                                                                                                                                                                                                                                                                                                                                                                                    |

Table continues on the next page...

FlexTimer (FTM)

Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                      |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | This bit enables the half cycle match as a reload opportunity. A half cycle is defined by when the FTM counter matches the HCR register. 0b - Half cycle reload is disabled and it is not considered as a reload opportunity. 1b - Half cycle reload is enabled and it is considered as a reload opportunity. |
| 7-6 -      | Reserved                                                                                                                                                                                                                                                                                                      |
| 5-0 CHnSEL | Channel n Select 0b - Channel match is not included as a reload opportunity. 1b - Channel match is included as a reload opportunity.                                                                                                                                                                          |

## 43.4.3.25 Half Cycle Register (HCR)

## Offset

| Register   | Offset   |
|------------|----------|
| HCR        | 9Ch      |

## Function

The Half Cycle Register contains the match value for FTM half cycle reload feature. After FTM counter reaches this value, a reload opportunity is generated if FTM\_PWMLOAD[HCSEL] is enabled.

Writing to the HCR register latches the value into a buffer. The HCR register is updated with the value of its write buffer according to Registers updated from write buffers.

## Diagram

<!-- image -->

## Fields

| Field   | Function         |
|---------|------------------|
| 31-16   | Reserved         |
| 15-0    | Half Cycle Value |
| HCVAL   |                  |

## 43.4.3.26 Mirror of Modulo Value (MOD\_MIRROR)

## Offset

| Register   | Offset   |
|------------|----------|
| MOD_MIRROR | 200h     |

## Function

This register contains the integer and fractional modulo value for the FTM counter.

## Diagram

<!-- image -->

| Bits   | 31      | 30      | 29      | 28      | 27      | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|---------|---------|---------|---------|---------|------|------|------|------|------|------|------|------|------|------|------|
| R      |         |         |         |         |         |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0       | 0       | 0       | 0       | 0       | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15      | 14      | 13      | 12      | 11      | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      |         |         |         |         |         | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      | FRACMOD | FRACMOD | FRACMOD | FRACMOD | FRACMOD |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0       | 0       | 0       | 0       | 0       | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                                       |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-16   | Mirror of the Modulo Integer Value                                                                                                             |
| MOD     | See the field MOD of the register MOD.                                                                                                         |
| 15-11   | Modulo Fractional Value                                                                                                                        |
| FRACMOD | The modulo fractional value is used in the PWM period dithering. This value is added to an internal accumulator at the end of each PWM period. |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                     |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | Writes to the field FRACMOD are done on its write buffer. The FRACMOD is updated with its write buffer value according to Registers updated from write buffers. If FTMEN=0,awritetoSCregisterresets manually this write coherency mechanism. |
| 10-0 -  | Reserved                                                                                                                                                                                                                                     |

## 43.4.3.27 Mirror of Channel (n) Match Value (C0V\_MIRROR - C5V\_MIRROR)

## Offset

| Register   | Offset   |
|------------|----------|
| C0V_MIRROR | 204h     |
| C1V_MIRROR | 208h     |
| C2V_MIRROR | 20Ch     |
| C3V_MIRROR | 210h     |
| C4V_MIRROR | 214h     |
| C5V_MIRROR | 218h     |

## Function

This register contains the integer and fractional value of the channel (n) match.

## Diagram

<!-- image -->

| Bits   | 31      | 30      | 29      | 28      | 27      | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|---------|---------|---------|---------|---------|------|------|------|------|------|------|------|------|------|------|------|
| R W    |         |         |         |         |         |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0       | 0       | 0       | 0       | 0       | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15      | 14      | 13      | 12      | 11      | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      |         |         |         |         |         | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      | FRACVAL | FRACVAL | FRACVAL | FRACVAL | FRACVAL |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0       | 0       | 0       | 0       | 0       | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                      |
|---------|-----------------------------------------------|
| 31-16   | Mirror of the Channel (n) Match Integer Value |

Table continues on the next page...

Table continued from the previous page...

| Field         | Function                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|---------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| VAL           | See the field VAL of the register CnV.                                                                                                                                                                                                                                                                                                                                                                                                               |
| 15-11 FRACVAL | Channel (n) Match Fractional Value Thechannel (n) match fractional value is used in the PWMedgedithering. This value is addedto the channel (n) internal accumulator at the end of each PWM period. Writes to the field FRACVALaredoneonits write buffer. The FRACVALisupdated with its write buffer value according to Registers updated from write buffers. If FTMEN = 0, a write to CnSC register resets manually this write coherency mechanism. |
| 10-0 -        | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                             |

## 43.5 Functional Description

## 43.5.1 Clock source

The FTM has only one clock domain: the FTM input clock.

## 43.5.1.1 Counter clock source

The CLKS[1:0] bits select one of three possible clock sources for the FTM counter or disable the FTM counter. After any chip reset, CLKS[1:0] = 0:0 so no clock source is selected.

The CLKS[1:0] bits may be read or written at any time. Disabling the FTM counter by writing 0:0 to the CLKS[1:0] bits does not affect the FTM counter value or other registers.

The fixed frequency clock is an alternative clock source for the FTM counter that allows the selection of a clock other than the FTM input clock or an external clock. This clock input is defined by chip integration. Refer to the chip specific documentation for further information. Due to FTM hardware implementation limitations, the frequency of the fixed frequency clock must not exceed 1/2 of the FTM input clock frequency.

The external clock passes through a synchronizer clocked by the FTM input clock to assure that counter transitions are properly aligned to FTM input clock transitions. Therefore, to meet Nyquist criteria considering also jitter, the frequency of the external clock source must not exceed 1/4 of the FTM input clock frequency.

## 43.5.2 Prescaler

The selected counter clock source passes through a prescaler that is a 7-bit counter. The value of the prescaler is selected by the PS[2:0] bits. The following figure shows an example of the prescaler counter and FTM counter.

FlexTimer (FTM)

<!-- image -->

| FTM counting is up. PS[2:0] = 001 CNTIN = 0x0000 MOD = 0x0003   |    |    |    |     |    |    |     |    |    |     |    |    |    |    |    |    |
|-----------------------------------------------------------------|----|----|----|-----|----|----|-----|----|----|-----|----|----|----|----|----|----|
| selected input clock                                            |    |    |    |     |    |    |     |    |    |     |    |    |    |    |    |    |
| prescaler counter                                               | 1  | 0  | 1  | 0 1 | 0  | 1  | 0 1 | 0  | 1  | 0 1 | 0  | 1  | 0  | 1  | 0  |    |
| FTM counter                                                     | 0  | 1  |    | 2   |    | 3  | 0   | 1  |    | 2   |    | 3  |    | 0  |    | 1  |
| Figure 257. Example of the prescaler counter                    |    |    |    |     |    |    |     |    |    |     |    |    |    |    |    |    |

## 43.5.3 Counter

The FTM has a 16-bit counter that is used by the channels either for input or output modes. The FTM counter clock is the selected clock divided by the prescaler.

The FTM counter has these modes of operation:

- Up counting
- Up-down counting
- Quadrature Decoder Mode

## 43.5.3.1 Up counting

Up counting is selected when:

- QUADEN = 0, and
- CPWMS = 0

CNTIN defines the starting value of the count and MOD defines the final value of the count, see the following figure. The value of CNTIN is loaded into the FTM counter, and the counter increments until the value of MOD is reached, at which point the counter is reloaded with the value of CNTIN.

The FTM period when using up counting is (MOD - CNTIN + 0x0001)  period of the FTM counter clock.

The TOF bit is set when the FTM counter changes from MOD to CNTIN.

A counter event happens at the same time of TOF bit set when the FTM counter changes from MOD to CNTIN. See Counter events for more details.

<!-- image -->

Table 273. FTM counting based on CNTIN value

| When                             | Then                                                                                                                 |
|----------------------------------|----------------------------------------------------------------------------------------------------------------------|
| CNTIN = 0x0000                   | The FTM counting is equivalent to TPM up counting, that is, up and unsigned counting. See the following figure.      |
| CNTIN[15] = 1                    | The initial value of the FTM counter is a negative number in two's complement, so the FTM counting is up and signed. |
| CNTIN[15] = 0 and CNTIN  0x0000 | The initial value of the FTM counter is a positive number, so the FTM counting is up and unsigned.                   |

<!-- image -->

## NOTE

- FTM operation is only valid when the value of the CNTIN register is less than the value of the MOD register, either in the unsigned counting or signed counting. It is the responsibility of the software to ensure that the values in the CNTIN and MOD registers meet this requirement. Any values of CNTIN and MOD that do not satisfy this criteria can result in unpredictable behavior.
- MOD = CNTIN is a redundant condition. In this case, the FTM counter is always equal to MOD and the TOF bit is set in each rising edge of the FTM counter clock.
- When MOD = 0x0000, CNTIN = 0x0000, for example after reset, and FTMEN = 1, the FTM counter remains stopped at 0x0000 until a non-zero value is written into the MOD or CNTIN registers.
- Setting CNTIN to be greater than the value of MOD is not recommended as this unusual setting may make the FTM operation difficult to comprehend. However, there is no restriction on this configuration, and an example is shown in the following figure.

<!-- image -->

## 43.5.3.2 Up-down counting

Up-down counting is selected when:

- QUADEN = 0, and
- CPWMS = 1

CNTIN defines the starting value of the count and MOD defines the final value of the count. The value of CNTIN is loaded into the FTM counter, and the counter increments until the value of MOD is reached, at which point the counter is decremented until it returns to the value of CNTIN and the up-down counting restarts.

The FTM period when using up-down counting is 2  (MOD - CNTIN)  period of the FTM counter clock.

The TOF bit is set when the FTM counter changes from MOD to (MOD - 1).

If (CNTIN = 0x0000), the FTM counting is equivalent to TPM up-down counting, that is, up-down and unsigned counting. See the following figure.

<!-- image -->

## NOTE

When CNTIN is different from zero in the up-down counting, a valid CPWM signal is generated:

- if CnV &gt; CNTIN, or
- if CnV = 0 or if CnV[15] = 1. In this case, 0% CPWM is generated.

The figure below shows the possible counter events when in up-down counting mode. See Counter events for more details.

<!-- image -->

## 43.5.3.3 Free running counter

If (FTMEN = 0) and (MOD = 0x0000 or MOD = 0xFFFF), the FTM counter is a free running counter. In this case, the FTM counter runs free from 0x0000 through 0xFFFF and the TOF bit is set when the FTM counter changes from 0xFFFF to 0x0000. See the following figure.

A counter event occurs at the same time of TOF bit set when the FTM counter changes from 0xFFFF to 0x0000. See Counter events for more details.

<!-- image -->

The FTM counter is also a free running counter when:

- FTMEN = 1
- QUADEN = 0
- CPWMS = 0
- CNTIN = 0x0000, and
- MOD = 0xFFFF

## 43.5.3.4 Counter reset

Any one of the following cases resets the FTM counter to the value in the CNTIN register and the channels output to its initial value, except for channels in Output Compare mode.

- Any write to CNT.
- FTM counter synchronization.

- A channel in Input Capture mode with ICRST = 1 (FTM Counter Reset in Input Capture Mode).

Note that resetting the counter also generates a counter event. See Counter events for more details.

## 43.5.3.5 Counter events

Counter events can be used as reload opportunities to FTM register synchronization mechanism. See Reload Points for more details. There are some possible counter events depending on the counter mode. Please see the table below for more details.

Table 274. FTM counter events

| When                                                                                             | Then                                                                                                                                                                                                                                                                                                                                                                                                                        |
|--------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FTM counter is in up counting mode or freerunning                                                |  A counter event happens at the same time of TOF bit set when the FTM counter changes from MOD to CNTIN (counter wrap). Figure at Up counting shows the counter event generation.  When in freerunning, there is a counter event when FTM counter changes from 0xFFFF to 0x0000. Figure at Free running counter shows the counter event generation.                                                                       |
| FTM counter is in up-down counting mode                                                          |  In up-down counting mode, there are two possible counter events when FTM counter turns from down to up counting and when counter turns from up to down counting. User can select which point will be used to generate the counter event. Figure at Up-down counting shows the possible counter events.                                                                                                                    |
| FTM counter is reset (see Counter reset) or a value different from zero is written at CLKS field |  In up-counting mode, all counter reset events or a write in the CLKS with a value different from zero generates a counter event.  In up-down counting mode, counter reset events only generates a counter event if the minimum load point when FTM counter turns from down to up counting is configured. A write in the CLKS with a value different from zero always generates a counter event in up-down counting mode. |

## 43.5.4 Channel Modes

The following table shows the channel modes selection.

Table 275. Channel Modes Selection

| DECAPEN   | MCOMBINE   | COMBINE   | CPWMS   | MSB:MSA   |   ELSB:ELSA | Mode                                                                                            | Configuration                                                                                   |
|-----------|------------|-----------|---------|-----------|-------------|-------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| X         | X          | X         | X       | XX        |          00 | Pin not used for FTM- revert the channel pin to general purpose I/O or other peripheral control | Pin not used for FTM- revert the channel pin to general purpose I/O or other peripheral control |
| 0         | 0          | 0         | 0       | 00        |          01 | Input Capture                                                                                   | Capture on Rising Edge Only                                                                     |

Table continues on the next page...

Table 275. Channel Modes Selection (continued)

| DECAPEN   | MCOMBINE   | COMBINE   | CPWMS   | MSB:MSA   | ELSB:ELSA   | Mode                    | Configuration                                                                 |
|-----------|------------|-----------|---------|-----------|-------------|-------------------------|-------------------------------------------------------------------------------|
|           |            |           |         |           | 10          |                         | Capture on Falling Edge Only                                                  |
|           |            |           |         |           | 11          |                         | Capture on Rising or Falling Edge                                             |
|           |            |           |         | 01        | 01          | Output Compare          | Toggle Output on match                                                        |
|           |            |           |         | 01        | 10          | Output Compare          | Clear Output on match                                                         |
|           |            |           |         | 01        | 11          | Output Compare          | Set Output on match                                                           |
|           |            |           |         | 1X        | 10          | Edge-Aligned PWM        | High-true pulses (clear Output on match)                                      |
|           |            |           |         | 1X        | X1          | Edge-Aligned PWM        | Low-true pulses (set Output on match)                                         |
|           |            |           | 1       | XX        | 10          | Center- Aligned PWM     | High-true pulses (clear Output on match-up)                                   |
|           |            |           | 1       | XX        | X1          | Center- Aligned PWM     | Low-true pulses (set Output on match-up)                                      |
|           |            | 1         | 0       | XX        | 10          | Combine PWM             | High-true pulses (set on channel (n) match, and clear on channel (n+1) match) |
|           |            | 1         | 0       | XX        | X1          | Combine PWM             | Low-true pulses (clear on channel (n) match, and set on channel (n+1) match)  |
|           | 1          | 0         | X       | XX        | XX          | Reserved for future use | Reserved for future use                                                       |

Table continues on the next page...

Table 275. Channel Modes Selection (continued)

| DECAPEN   |   MCOMBINE |   COMBINE |   CPWMS | MSB:MSA   | ELSB:ELSA      | Mode                 | Configuration                                                                 |
|-----------|------------|-----------|---------|-----------|----------------|----------------------|-------------------------------------------------------------------------------|
|           |          1 |         1 |       0 | XX        | 10             | Modified Combine PWM | High-true pulses (set on channel (n) match, and clear on channel (n+1) match) |
|           |          1 |         1 |       0 | XX        | X1             | Modified Combine PWM | Low-true pulses (clear on channel (n) match, and set on channel (n+1) match)  |
| 1         |          0 |         0 |       0 | X0        | See Table 276. | Dual Edge Capture    | One-Shot Capturemode                                                          |
| 1         |          0 |         0 |       0 | X1        | See Table 276. | Dual Edge Capture    | Continuous Capturemode                                                        |

## Table 276. Dual Edge Capture Mode - Edge Polarity Selection

|   ELSB |   ELSA | Channel Port Enable   | Detected Edges           |
|--------|--------|-----------------------|--------------------------|
|      0 |      0 | Disabled              | No edge                  |
|      0 |      1 | Enabled               | Rising edge              |
|      1 |      0 | Enabled               | Falling edge             |
|      1 |      1 | Enabled               | Rising and falling edges |

## 43.5.5 Input Capture Mode

The Input Capture mode is selected when:

- DECAPEN = 0
- MCOMBINE = 0
- COMBINE = 0
- CPWMS = 0
- MSB:MSA = 0:0, and
- ELSB:ELSA  0:0

When a selected edge occurs on the channel input, the current value of the FTM counter is captured into the CnV register, at the same time the CHF bit is set and the channel interrupt is generated if enabled by CHIE = 1. See the following figure.

When a channel is configured for input capture, the FTMxCHn pin is an edge-sensitive input. ELSB:ELSA bits determine which edge, falling or rising, triggers input-capture event.

Writes to the CnV register are ignored in input capture mode.

While in Debug mode, the input capture function works as configured. When a selected edge event occurs, the FTM counter value, which is frozen because of Debug, is captured into the CnV register and the CHF bit is set.

FlexTimer (FTM)

<!-- image -->

## 43.5.5.1 Filter for Input Capture Mode

The filter is only available on channels 0, 1, 2, and 3.

If FLTPS[3:0] = 0, the channel input after being synchronized by FTM input clock (Figure 264) is the filter input.

<!-- image -->

If FLTPS[3:0]  0, the channel input after being synchronized by FTM input clock and being sampled by FTM filter clock (Figure 265) is the filter input.

FlexTimer (FTM)

<!-- image -->

## NOTE

The maximum frequency for the channel input to be detected correctly is FTM filter clock divided by 4, which is required to meet Nyquist criteria for signal sampling.

When there is a state change in the channel input, the counter is reset and starts counting up. As long as the new state is stable on the channel input, the counter continues to increment. When the counter is equal to CHnFVAL[3:0], the new channel input signal value is validated. It is then transmitted as a pulse to the edge detector.

If the opposite edge appears on the channel input signal before it can be validated, the counter is reset. At the next input transition, the counter starts counting again. If a pulse is sampled as a value less than (CHnFVAL[3:0] x 4) consecutive rising edges of FTM filter clock, it is regarded as a glitch and is not passed on to the edge detector.

The table below shows the delay that is added by the FTM channel input filter according to its configuration.

Table 277. FTM Channel Input Filter Delay

| FTM channel input filter                                                                           | FLTPS[3:0] bits   | Number of rising edges between the selected edge on channel input and setting CHF bit               |
|----------------------------------------------------------------------------------------------------|-------------------|-----------------------------------------------------------------------------------------------------|
|  channel does not have the input filter, or  channel input filter is disabled (CHnFVAL[3:0] = 0) | FLTPS[3:0] = 0    |  3 rising edges of FTM input clock                                                                 |
|  channel does not have the input filter, or  channel input filter is disabled (CHnFVAL[3:0] = 0) | FLTPS[3:0]  0    |  3 rising edges of FTM input clock, plus  1 rising edge of FTM filter clock                       |
|  channel has the input filter, and  channel input filter is enabled (CHnFVAL[3:0]  0)           | FLTPS[3:0] = 0    |  (4 + 4  CHnFVAL[3:0]) rising edges of FTM input clock                                            |
|  channel has the input filter, and  channel input filter is enabled (CHnFVAL[3:0]  0)           | FLTPS[3:0]  0    |  4 rising edges of FTM input clock, plus  (1 + 4  CHnFVAL[3:0]) rising edges of FTM filter clock |

The following figures illustrate two examples of channel input filter.

FlexTimer (FTM)

<!-- image -->

<!-- image -->

## 43.5.5.2 FTM Counter Reset in Input Capture Mode

If the channel (n) is in input capture mode and CnSC[ICRST = 1], then when the selected input capture event occurs in the channel (n) input signal, the current value of the FTM counter is captured into the CnV register, the CHF bit is set, the channel (n) interrupt is generated (if CHIE = 1) and the FTM counter is reset to the CNTIN register value.

This allows the FTM to measure a period/pulse being applied to the channel (n) input (number of the FTM input clocks) without having to implement a subtraction calculation in software subsequent to the event occurring.

The figure below shows the FTM counter reset when the selected input capture event is detected in a channel in input capture mode with ICRST = 1.

FlexTimer (FTM)

<!-- image -->

## NOTE

- It is expected that the ICRST bit be set only when the channel is in input capture mode.
- If the FTM counter is reset because the channel is in input capture mode with ICRST = 1, then the prescaler counter (Prescaler) is also reset.

## 43.5.6 Output Compare mode

The Output Compare mode is selected when:

- DECAPEN = 0
- MCOMBINE = 0
- COMBINE = 0
- CPWMS = 0, and
- MSB:MSA = 0:1

In Output Compare mode, the FTM can generate timed pulses with programmable position, polarity, duration, and frequency. When the counter matches the value in the CnV register of an output compare channel, the channel (n) output can be set, cleared, or toggled.

When a channel is initially configured to Toggle mode, the previous value of the channel output is held until the first output compare event occurs.

The CHF bit is set and the channel (n) interrupt is generated if CHIE = 1 at the channel (n) match (FTM counter = CnV).

<!-- image -->

<!-- image -->

If (ELSB:ELSA = 0:0) when the counter reaches the value in the CnV register, the CHF bit is set and the channel (n) interrupt is generated if CHIE = 1, however the channel (n) output is not modified and controlled by FTM.

## 43.5.7 Edge-Aligned PWM (EPWM) mode

The Edge-Aligned mode is selected when:

- QUADEN = 0
- DECAPEN = 0
- MCOMBINE = 0
- COMBINE = 0
- CPWMS = 0, and
- MSB = 1

The EPWM period is determined by (MOD - CNTIN + 0x0001) and the pulse width (duty cycle) is determined by (CnV - CNTIN).

The CHF bit is set and the channel (n) interrupt is generated if CHIE = 1 at the channel (n) match (FTM counter = CnV), that is, at the end of the pulse width.

This type of PWM signal is called edge-aligned because the leading edges of all PWM signals are aligned with the beginning of the period, which is the same for all channels within an FTM.

FlexTimer (FTM)

<!-- image -->

If (ELSB:ELSA = 0:0) when the counter reaches the value in the CnV register, the CHF bit is set and the channel (n) interrupt is generated if CHIE = 1, however the channel (n) output is not controlled by FTM.

If (ELSB:ELSA = 1:0), then the channel (n) output is forced high at the counter overflow when the CNTIN register value is loaded into the FTM counter, and it is forced low at the channel (n) match (FTM counter = CnV). See the following figure.

<!-- image -->

If (ELSB:ELSA = X:1), then the channel (n) output is forced low at the counter overflow when the CNTIN register value is loaded into the FTM counter, and it is forced high at the channel (n) match (FTM counter = CnV). See the following figure.

<!-- image -->

If (CnV = 0x0000), then the channel (n) output is a 0% duty cycle EPWM signal and CHF bit is not set even when there is the channel (n) match.

If (CnV &gt; MOD), then the channel (n) output is a 100% duty cycle EPWM signal and CHF bit is not set. Therefore, MOD must be less than 0xFFFF in order to get a 100% duty cycle EPWM signal.

## NOTE

When CNTIN is different from zero the following EPWM signals can be generated:

- 0% EPWM signal if CnV = CNTIN,
- EPWM signal between 0% and 100% if CNTIN &lt; CnV &lt;= MOD,
- 100% EPWM signal when CNTIN &gt; CnV or CnV &gt; MOD.

## 43.5.8 Center-Aligned PWM (CPWM) mode

The Center-Aligned mode is selected when:

- QUADEN = 0
- DECAPEN = 0
- MCOMBINE = 0
- COMBINE = 0, and
- CPWMS = 1

The CPWM pulse width (duty cycle) is determined by 2  (CnV - CNTIN) and the period is determined by 2  (MOD - CNTIN). See the following figure. MOD must be kept in the range of 0x0001 to 0x7FFF because values outside this range can produce ambiguous results.

In the CPWM mode, the FTM counter counts up until it reaches MOD and then counts down until it reaches CNTIN.

The CHF bit is set and channel (n) interrupt is generated (if CHIE = 1) at the channel (n) match (FTM counter = CnV) when the FTM counting is down (at the begin of the pulse width) and when the FTM counting is up (at the end of the pulse width).

This type of PWM signal is called center-aligned because the pulse width centers for all channels are aligned with the value of CNTIN.

The other channel modes are not compatible with the up-down counter (CPWMS = 1). Therefore, all FTM channels must be used in CPWM mode when (CPWMS = 1).

<!-- image -->

If (ELSB:ELSA = 0:0) when the FTM counter reaches the value in the CnV register, the CHF bit is set and the channel (n) interrupt is generated (if CHIE = 1), however the channel (n) output is not controlled by FTM.

If (ELSB:ELSA = 1:0), then the channel (n) output is forced high at the channel (n) match (FTM counter = CnV) when counting down, and it is forced low at the channel (n) match when counting up. See the following figure.

FlexTimer (FTM)

FlexTimer (FTM)

<!-- image -->

If (ELSB:ELSA = X:1), then the channel (n) output is forced low at the channel (n) match (FTM counter = CnV) when counting down, and it is forced high at the channel (n) match when counting up. See the following figure.

<!-- image -->

If (CnV = 0x0000) or CnV is a negative value, that is (CnV[15] = 1), then the channel (n) output is a 0% duty cycle CPWM signal and CHF bit is not set even when there is the channel (n) match.

If CnV is a positive value, that is (CnV[15] = 0), (CnV  MOD), and (MOD  0x0000), then the channel (n) output is a 100% duty cycle CPWM signal and CHF bit is not set even when there is the channel (n) match. This implies that the usable range of periods set by MOD is 0x0001 through 0x7FFE, 0x7FFF if you do not need to generate a 100% duty cycle CPWM signal. This is not a significant limitation because the resulting period is much longer than required for normal applications.

The CPWM mode must not be used when the FTM counter is a free running counter.

## 43.5.9 Combine mode

The Combine mode is selected when:

- QUADEN = 0
- DECAPEN = 0
- MCOMBINE = 0
- COMBINE = 1, and
- CPWMS = 0

In Combine mode, an even channel (n) and adjacent odd channel (n+1) are combined to generate a PWM signal in the channel (n) output.

In the Combine mode, the PWM period is determined by (MOD - CNTIN + 0x0001) and the PWM pulse width (duty cycle) is determined by (|C(n+1)V - C(n)V|).

FlexTimer (FTM)

The channel (n) CHF bit is set and its interrupt is generated, if channel (n) CHIE = 1, at the channel (n) match (FTM counter = C(n)V). The channel (n+1) CHF bit is set and its interrupt is generated, if channel (n+1) CHIE = 1, at the channel (n+1) match (FTM counter = C(n+1)V).

If channel (n) ELSB:ELSA = 1:0, then the channel (n) output is forced low at the beginning of the period (FTM counter = CNTIN) and at the channel (n+1) match (FTM counter = C(n+1)V). It is forced high at the channel (n) match (FTM counter = C(n)V). See the following figure.

If channel (n) ELSB:ELSA = X:1, then the channel (n) output is forced high at the beginning of the period (FTM counter = CNTIN) and at the channel (n+1) match (FTM counter = C(n+1)V). It is forced low at the channel (n) match (FTM counter = C(n)V). See the following figure.

In Combine mode, the channel (n+1) ELSB:ELSA bits are not used in the generation of the channels (n) and (n+1) output. However, if channel (n) ELSB:ELSA = 0:0, then the channel (n) output is not controlled by FTM, and if channel (n+1) ELSB:ELSA = 0:0, then the channel (n+1) output is not controlled by FTM.

<!-- image -->

The following figures illustrate the PWM signals generation using Combine mode.

<!-- image -->

FlexTimer (FTM)

<!-- image -->

<!-- image -->

<!-- image -->

<!-- image -->

<!-- image -->

## 43.5.9.1 Asymmetrical PWM

In Combine mode and Modified Combine PWM Mode, the PWM first edge (channel (n) match: FTM counter = C(n)V) is independent of the PWM second edge (channel (n+1) match: FTM counter = C(n+1)V).

## 43.5.10 Modified Combine PWM Mode

The Modified Combine PWM mode is selected when:

- QUADEN = 0
- DECAPEN = 0
- MCOMBINE = 1
- COMBINE = 1, and
- CPWMS = 0

The Modified Combine PWM mode is intended to support the generation of PWM signals where the period is not modified while the signal is being generated, but the duty cycle will be varied. In this mode, an even channel (n) and adjacent odd channel (n+1) are combined to generate a PWM signal in the channel (n) output. Thus, the channel (n) match edge is fixed and the channel (n+1) match edge can be varied.

When a pair of channels is in Modified Combine PWM mode, it is recommend that the other pairs also be in Modified Combine PWM mode.

In the Modified Combine PWM mode, assuming that CNTIN  0, MOD &gt; 0, and CNTIN &lt; MOD:

- The PWM period is determined by (MOD - CNTIN + 0x0001);
- The channel (n) PWM duty cycle is calculated according to the following table.

Table 278. Modified Combine PWM Mode - Duty Cycles

| Channel (n) PWM Duty Cycle     | Condition                                                                                                                                                                                      |
|--------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0% duty cycle                  | For CNTIN  (C(n)V and C(n+1)V)  MOD: C(n)V = C(n+1)V                                                                                                                                         |
| duty cycle between 0% and 100% | For CNTIN  (C(n)V and C(n+1)V)  MOD:  if (C(n)V < C(n+1)V), then the duty cycle is (C(n+1)V - C(n)V)  if (C(n)V > C(n+1)V), then the duty cycle is [(MOD - C(n)V) + (C(n+1)V - CNTIN) + 1] |
| 100% duty cycle                | CNTIN  C(n)V  MOD and C(n+1)V > MOD                                                                                                                                                          |

The channel (n) CHF bit is set and its interrupt is generated, if channel (n) CHIE = 1, at the channel (n) match (FTM counter = C(n)V). The channel (n+1) CHF bit is set and its interrupt is generated, if channel (n+1) CHIE = 1, at the channel (n+1) match (FTM counter = C(n+1)V).

If channel (n) ELSB:ELSA = 1:0, then the channel (n) output is forced high at the channel (n) match (FTM counter = C(n)V) and it is forced low at the channel (n+1) match (FTM counter = C(n+1)V).

If channel (n) ELSB:ELSA = X:1, then the channel (n) output is forced low at the channel (n) match (FTM counter = C(n)V) and it is forced high at the channel (n+1) match (FTM counter = C(n+1)V).

In Modified Combine PWM mode, the channel (n+1) ELSB:ELSA bits are not used in the generation of the channels (n) and (n+1) output. However, if channel (n) ELSB:ELSA = 0:0, then the channel (n) output is not controlled by FTM, and if channel (n+1) ELSB:ELSA = 0:0, then the channel (n+1) output is not controlled by FTM.

FlexTimer (FTM)

FlexTimer (FTM)

<!-- image -->

The Modified Combine PWM mode allows the offset addition of the duty cycle, thus, in some cases, the C(n+1)V match can happen on the next FTM counter period. For CNTIN  0, MOD &gt; 0, and CNTIN &lt; MOD, this situation happens when C(n)V &gt; C(n+1)V.

<!-- image -->

If more than one pair of channels are configured in Modified Combine PWM Mode, it is possible to fix an offset for the channel (n) match edge of each pair with respect to other pairs. This behavior is useful in the generation of lighting PWM control signals where it is desirable that edges are not coincident with each other pair to help eliminate noise generation. The C(n)V register value is the shift of the PWM pulse with respect to the beginning of FTM counter period (FTM counter = CNTIN).

<!-- image -->

## 43.5.10.1 Synchronization

In the Modified Combine Mode, the following registers should be updated when the FTM counter clock is disabled (CLKS[1:0] = 0:0).

- CNTIN (CNTIN register update)
- MOD (MOD and HCR registers update)
- C(n)V and C(n+1)V (CnV register update)

In the Modified Combine Mode, if (FTMEN = 1), (CLKS[1:0]  0:0), and there was a write to the register C(n+1)V, then the register C(n+1)V is updated with its write buffer value on the next channel (n) match (FTM counter = C(n)V). This feature allows to vary the PWM duty cycle value in this mode.

## NOTE

In the Modified Combine Mode, the bit SYNCEN(n) should be zero bit for the channels (n) and (n+1). So, the following features are not available for this mode.

- C(n)V and C(n+1)V register synchronization
- Reload Points
- Global Load

## 43.5.11 Complementary Mode

The Complementary mode is selected when:

- QUADEN = 0
- DECAPEN = 0
- COMP = 1

In Complementary mode, the channel (n+1) output is the inverse of the channel (n) output.

## NOTE

The Complementary Mode is not available on Output Compare mode.

The channel (n+1) output is the same as the channel (n) output when:

- QUADEN = 0
- DECAPEN = 0
- COMP = 0
- channels (n) and (n+1) are on Combine Mode or Modified Combine PWM Mode

The channel (n+1) output is independent from channel (n) output when:

- QUADEN = 0
- DECAPEN = 0
- COMP = 0
- channel (n) is on Output Compare Mode, EPWM or CPWM

<!-- image -->

## 43.5.12 Registers updated from write buffers

## 43.5.12.1 CNTIN register update

The following table describes when CNTIN register is updated:

Table 279. CNTIN register update

| When                                          | Then CNTIN register is updated                            |
|-----------------------------------------------|-----------------------------------------------------------|
| CLKS[1:0] = 0:0                               | When CNTIN register is written, independent of FTMEN bit. |
|  FTMEN = 0, or  CNTINC = 0                  | At the next FTM input clock after CNTIN was written.      |
|  FTMEN = 1,  SYNCMODE = 1, and  CNTINC = 1 | By the CNTIN register synchronization.                    |
|  CNTINC = 1, and  LDOK = 1                  | By the Reload Points.                                     |

## 43.5.12.2 MOD and HCR registers update

The following table describes when MOD or HCR registers are updated:

Table 280. MOD and HCR updates

| When                               | Then MOD or HCR is updated                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| CLKS[1:0] = 0:0                    | When MOD (or HCR) is written, independent of FTMEN bit.                                                                                                                                                                                                                                                                                                                                                                                                                   |
|  CLKS[1:0]  0:0, and  FTMEN = 0 | According to the CPWMS bit, that is:  If the selected mode is not CPWMthen MOD(or HCR) is updated after MOD(or HCR) register was written and the FTMcounter changes from MODtoCNTIN. If the FTM counter is at free-running counter mode then this update occurs when the FTM counter changes from 0xFFFF to 0x0000.  If the selectedmodeisCPWMthenMOD(orHCR)registerisupdatedafterMOD (or HCR) register was written and the FTMcounter changes fromMODto(MOD - 0x0001). |
|  CLKS[1:0]  0:0, and  FTMEN = 1 | By the MOD register synchronization. HCR follows the same procedure of MOD register in this case.                                                                                                                                                                                                                                                                                                                                                                         |
|  LDOK = 1                         | By the Reload Points.                                                                                                                                                                                                                                                                                                                                                                                                                                                     |

## 43.5.12.3 CnV register update

The following table describes when CnV register is updated:

Table 281. CnV register update

| When                   | Then CnV register is updated                            |
|------------------------|---------------------------------------------------------|
| CLKS[1:0] = 0:0        | When CnV register is written, independent of FTMEN bit. |
|  CLKS[1:0]  0:0, and | According to the selected mode, that is:                |
|  FTMEN = 0            |                                                         |

Table continues on the next page...

Table 281. CnV register update (continued)

| When                               | Then CnV register is updated                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                    |  If the selected mode is Output Compare, then CnV register is updated on the next FTM counter change, end of the prescaler counting, after CnV register was written.  If the selected mode is EPWM, then CnV register is updated after CnV register was written and the FTM counter changes from MOD to CNTIN. If the FTM counter is at free-running counter mode then this update occurs when the FTM counter changes from 0xFFFF to 0x0000.  If the selected mode is CPWM, then CnV register is updated after CnV register was written and the FTM counter changes from MOD to (MOD - 0x0001). |
|  CLKS[1:0]  0:0, and  FTMEN = 1 | According to the selected mode, that is:  If the selected mode is output compare then CnV register is updated according to the SYNCEN bit. If (SYNCEN = 0) then CnV register is updated after CnV register was written at the next change of the FTM counter, the end of the prescaler counting. If (SYNCEN = 1) then CnV register is updated by the C(n)V and C(n+1)V register synchronization.  If the selected mode is not output compare and (SYNCEN = 1) then CnV register is updated by the C(n)V and C(n+1)V register synchronization.                                                     |
|  SYNCEN = 1, and  LDOK = 1       | By the Reload Points.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |

## 43.5.13 PWM synchronization

The PWM synchronization provides an opportunity to update the MOD, HCR, CNTIN, CnV, OUTMASK, INVCTRL and SWOCTRL registers with their buffered value and force the FTM counter to the CNTIN register value.

## NOTE

The legacy PWM synchronization (SYNCMODE = 0) is a subset of the enhanced PWM synchronization (SYNCMODE = 1). Thus, only the enhanced PWM synchronization must be used.

## 43.5.13.1 Hardware trigger

Three hardware trigger signal inputs of the FTM module are enabled when TRIGn = 1, where n = 0, 1 or 2 corresponding to each one of the input signals, respectively. The hardware trigger input n is synchronized by the FTM input clock. The PWM synchronization with hardware trigger is initiated when a rising edge is detected at the enabled hardware trigger inputs.

If (HWTRIGMODE = 0) then the TRIGn bit is cleared when 0 is written to it or when the trigger n event is detected.

In this case, if two or more hardware triggers are enabled (for example, TRIG0 and TRIG1 = 1) and only trigger 1 event occurs, then only TRIG1 bit is cleared. If a trigger n event occurs together with a write setting TRIGn bit, then the synchronization is initiated, but TRIGn bit remains set due to the write operation.

FlexTimer (FTM)

<!-- image -->

If HWTRIGMODE = 1, then the TRIGn bit is only cleared when 0 is written to it.

## NOTE

The HWTRIGMODE bit must be 1 only with enhanced PWM synchronization (SYNCMODE = 1).

## 43.5.13.2 Software trigger

A software trigger event occurs when 1 is written to the SYNC[SWSYNC] bit. The SWSYNC bit is cleared when 0 is written to it or when the PWM synchronization, initiated by the software event, is completed.

If another software trigger event occurs (by writing another 1 to the SWSYNC bit) at the same time the PWM synchronization initiated by the previous software trigger event is ending, a new PWM synchronization is started and the SWSYNC bit remains equal to 1.

If SYNCMODE = 0 then the SWSYNC bit is also cleared by FTM according to PWMSYNC and REINIT bits. In this case if (PWMSYNC = 1) or (PWMSYNC = 0 and REINIT = 0) then SWSYNC bit is cleared at the next selected loading point after that the software trigger event occurred; see Synchronization Points and the following figure. If (PWMSYNC = 0) and (REINIT = 1) then SWSYNC bit is cleared when the software trigger event occurs.

If SYNCMODE = 1 then the SWSYNC bit is also cleared by FTM according to the SWRSTCNT bit. If SWRSTCNT = 0 then SWSYNC bit is cleared at the next selected loading point after that the software trigger event occurred; see the following figure. If SWRSTCNT = 1 then SWSYNC bit is cleared when the software trigger event occurs.

<!-- image -->

## 43.5.13.3 Synchronization Points

The synchronization points are points where the registers can be updated with their write buffer by PWM synchronization. These synchronization points are safe points because guarantee smooth transitions in the generated PWM signals.

In Up counting, the synchronization points are when the FTM counter changes from MOD to CNTIN. In this case, the synchronization points are enabled if (CNTMIN = 1) or (CNTMAX = 1).

In Up-down counting, the synchronization points are:

- if (CNTMAX = 1), when the FTM counter changes from (MOD) to (MOD - 1);
- if (CNTMIN = 1), when the FTM counter changes from (CNTIN) to (CNTIN + 1).

<!-- image -->

## 43.5.13.4 MOD register synchronization

The MOD register synchronization updates the MOD register with its buffer value. This synchronization is enabled if (FTMEN = 1).

The MOD register synchronization can be done by either the enhanced PWM synchronization (SYNCMODE = 1) or the legacy PWM synchronization (SYNCMODE = 0). However, it is expected that the MOD register be synchronized only by the enhanced PWM synchronization.

In the case of enhanced PWM synchronization, the MOD register synchronization depends on SWWRBUF, SWRSTCNT, HWWRBUF, and HWRSTCNT bits according to this flowchart:

FlexTimer (FTM)

FlexTimer (FTM)

<!-- image -->

In the case of legacy PWM synchronization, the MOD register synchronization depends on PWMSYNC and REINIT bits according to the following description.

If (SYNCMODE = 0), (PWMSYNC = 0), and (REINIT = 0), then this synchronization is made on the next selected loading point after an enabled trigger event takes place. If the trigger event was a software trigger, then the SWSYNC bit is cleared on the next selected loading point. If the trigger event was a hardware trigger, then the trigger enable bit (TRIGn) is cleared according to Hardware trigger. Examples with software and hardware triggers follow.

<!-- image -->

If (SYNCMODE = 0), (PWMSYNC = 0), and (REINIT = 1), then this synchronization is made on the next enabled trigger event. If the trigger event was a software trigger, then the SWSYNC bit is cleared according to the following example. If the trigger event was a hardware trigger, then the TRIGn bit is cleared according to Hardware trigger. Examples with software and hardware triggers follow.

<!-- image -->

FlexTimer (FTM)

<!-- image -->

If (SYNCMODE = 0) and (PWMSYNC = 1), then this synchronization is made on the next selected loading point after the software trigger event takes place. The SWSYNC bit is cleared on the next selected loading point:

<!-- image -->

## 43.5.13.5 CNTIN register synchronization

The CNTIN register synchronization updates the CNTIN register with its buffer value.

This synchronization is enabled if (FTMEN = 1), (SYNCMODE = 1), and (CNTINC = 1). The CNTIN register synchronization can be done only by the enhanced PWM synchronization (SYNCMODE = 1). The synchronization mechanism is the same as the MOD register synchronization done by the enhanced PWM synchronization; see MOD register synchronization.

## 43.5.13.6 C(n)V and C(n+1)V register synchronization

The C(n)V and C(n+1)V registers synchronization updates the C(n)V and C(n+1)V registers with their buffer values.

This synchronization is enabled if (FTMEN = 1) and (SYNCEN = 1). The synchronization mechanism is the same as the MOD register synchronization. However, it is expected that the C(n)V and C(n+1)V registers be synchronized only by the enhanced PWM synchronization (SYNCMODE = 1).

## 43.5.13.7 OUTMASK register synchronization

The OUTMASK register synchronization updates the OUTMASK register with its buffer value.

The OUTMASK register can be updated at each rising edge of FTM input clock (SYNCHOM = 0), by the enhanced PWM synchronization (SYNCHOM = 1 and SYNCMODE = 1) or by the legacy PWM synchronization (SYNCHOM = 1 and SYNCMODE = 0). However, it is expected that the OUTMASK register be synchronized only by the enhanced PWM synchronization.

In the case of enhanced PWM synchronization, the OUTMASK register synchronization depends on SWOM and HWOM bits. See the following flowchart:

<!-- image -->

In the case of legacy PWM synchronization, the OUTMASK register synchronization depends on PWMSYNC bit according to the following description.

If (SYNCMODE = 0), (SYNCHOM = 1), and (PWMSYNC = 0), then this synchronization is done on the next enabled trigger event. If the trigger event was a software trigger, then the SWSYNC bit is cleared on the next selected loading point. If the trigger event was a hardware trigger, then the TRIGn bit is cleared according to Hardware trigger. Examples with software and hardware triggers follow.

<!-- image -->

If (SYNCMODE = 0), (SYNCHOM = 1), and (PWMSYNC = 1), then this synchronization is made on the next enabled hardware trigger. The TRIGn bit is cleared according to Hardware trigger. An example with a hardware trigger follows.

<!-- image -->

## 43.5.13.8 INVCTRL register synchronization

The INVCTRL register synchronization updates the INVCTRL register with its buffer value.

FlexTimer (FTM)

The INVCTRL register can be updated at each rising edge of FTM input clock (INVC = 0) or by the enhanced PWM synchronization (INVC = 1 and SYNCMODE = 1) according to the following flowchart.

In the case of enhanced PWM synchronization, the INVCTRL register synchronization depends on SWINVC and HWINVC bits.

<!-- image -->

## 43.5.13.9 SWOCTRL register synchronization

The SWOCTRL register synchronization updates the SWOCTRL register with its buffer value.

The SWOCTRL register can be updated at each rising edge of FTM input clock (SWOC = 0) or by the enhanced PWM synchronization (SWOC = 1 and SYNCMODE = 1) according to the following flowchart.

In the case of enhanced PWM synchronization, the SWOCTRL register synchronization depends on SWSOC and HWSOC bits.

Figure 316. SWOCTRL register synchronization flowchart

<!-- image -->

## 43.5.13.10 FTM counter synchronization

The FTM counter synchronization is a mechanism that allows the FTM to restart the PWM generation at a certain point in the PWM period. The channels outputs are forced to their initial value, except for channels in Output Compare mode, and the FTM counter is forced to its initial counting value defined by CNTIN register.

FlexTimer (FTM)

The following figure shows the FTM counter synchronization. Note that after the synchronization event occurs, the channel (n) is set to its initial value and the channel (n+1) is not set to its initial value due to a specific timing of this figure in which the deadtime insertion prevents this channel output from transitioning to 1. If no deadtime insertion is selected, then the channel (n+1) transitions to logical value 1 immediately after the synchronization event occurs.

<!-- image -->

The FTM counter synchronization can be done by either the enhanced PWM synchronization (SYNCMODE = 1) or the legacy PWM synchronization (SYNCMODE = 0). However, the FTM counter must be synchronized only by the enhanced PWM synchronization.

In the case of enhanced PWM synchronization, the FTM counter synchronization depends on SWRSTCNT and HWRSTCNT bits according to the following flowchart.

FlexTimer (FTM)

<!-- image -->

In the case of legacy PWM synchronization, the FTM counter synchronization depends on REINIT and PWMSYNC bits according to the following description.

If (SYNCMODE = 0), (REINIT = 1), and (PWMSYNC = 0) then this synchronization is made on the next enabled trigger event. If the trigger event was a software trigger then the SWSYNC bit is cleared according to the following example. If the trigger event was a hardware trigger then the TRIGn bit is cleared according to Hardware trigger. Examples with software and hardware triggers follow.

<!-- image -->

If (SYNCMODE = 0), (REINIT = 1), and (PWMSYNC = 1) then this synchronization is made on the next enabled hardware trigger. The TRIGn bit is cleared according to Hardware trigger.

<!-- image -->

## 43.5.14 Inverting

The invert functionality swaps the signals between channel (n) and channel (n+1) outputs. The inverting operation is selected when:

- QUADEN = 0

- DECAPEN = 0
- COMP = 1, and
- INVm = 1 (where m represents a channel pair)

The INVm bit in INVCTRL register is updated with its buffer value according to INVCTRL register synchronization.

In combine mode with channel (n) ELSB:ELSA = 1:0, the channel (n) output is forced low at the beginning of the period (FTM counter = CNTIN), forced high at the channel (n) match and forced low at the channel (n+1) match. If the inverting is selected, the channel (n) output behavior is changed to force high at the beginning of the PWM period, force low at the channel (n) match and force high at the channel (n+1) match. See the following figure.

<!-- image -->

Note that the channel (n) ELSB:ELSA bits should be considered because they define the active state of the channels outputs. In combine mode with channel (n) ELSB:ELSA = X:1, the channel (n) output is forced high at the beginning of the period, forced low at the channel (n) match and forced high at the channel (n+1) match. When inverting is selected, the channels (n) and (n+1) present waveforms as shown in the following figure.

FlexTimer (FTM)

<!-- image -->

## NOTE

The Inverting is not available in Output Compare mode and Modified Combine PWM Mode.

## 43.5.15 Software Output Control Mode

The software output control forces the channel output according to software defined values at a specific time in the PWM generation.

The software output control is selected when:

- QUADEN = 0
- DECAPEN = 0, and
- CH(n)OC = 1

The CH(n)OC bit enables the software output control for a specific channel output and the CH(n)OCV selects the value that is forced to this channel output.

Both CH(n)OC and CH(n)OCV bits in SWOCTRL register are buffered and updated with their buffer value according to SWOCTRL register synchronization.

The following figure shows the channels (n) and (n+1) outputs signals when the software output control is used. In this case the channels (n) and (n+1) are set to Combine and Complementary mode.

Figure 324. Example of software output control in Combine and Complementary mode

<!-- image -->

Software output control forces the following values on channels (n) and (n+1) when the COMP bit is zero.

Table 282. Software output control behavior when (COMP = 0)

|   CH(n)OC |   CH(n+1)OC | CH(n)OCV   | CH(n+1)OCV   | Channel (n) Output      | Channel (n+1) Output    |
|-----------|-------------|------------|--------------|-------------------------|-------------------------|
|         0 |           0 | X          | X            | is not modified by SWOC | is not modified by SWOC |
|         1 |           1 | 0          | 0            | is forced to zero       | is forced to zero       |
|         1 |           1 | 0          | 1            | is forced to zero       | is forced to one        |
|         1 |           1 | 1          | 0            | is forced to one        | is forced to zero       |
|         1 |           1 | 1          | 1            | is forced to one        | is forced to one        |

Software output control forces the following values on channels (n) and (n+1) when the COMP bit is one.

Table 283. Software output control behavior when (COMP = 1)

|   CH(n)OC |   CH(n+1)OC | CH(n)OCV   | CH(n+1)OCV   | Channel (n) Output      | Channel (n+1) Output    |
|-----------|-------------|------------|--------------|-------------------------|-------------------------|
|         0 |           0 | X          | X            | is not modified by SWOC | is not modified by SWOC |
|         1 |           1 | 0          | 0            | is forced to zero       | is forced to zero       |
|         1 |           1 | 0          | 1            | is forced to zero       | is forced to one        |
|         1 |           1 | 1          | 0            | is forced to one        | is forced to zero       |
|         1 |           1 | 1          | 1            | is forced to one        | is forced to zero       |

## NOTE

- The CH(n)OC and CH(n+1)OC bits should be equal.
- The COMP bit must not be modified when software output control is enabled, that is, CH(n)OC = 1 and/or CH(n+1)OC = 1.
- Software output control has the same behavior with disabled or enabled FTM counter (see the CLKS field description in the Status and Control register).

## 43.5.16 Deadtime insertion

The deadtime insertion is enabled when DTEN is set and the concatenation {DTVALEX[3:0], DTVAL[5:0]} is non-zero.

DEADTIME register defines the deadtime delay that can be used for all FTM channels. The clock for the DEADTIME delay is the FTM input clock divided by DTPS bits, and the {DTVALEX[3:0], DTVAL[5:0]} bits define the deadtime modulo, that is, the number of the deadtime prescaler clocks.

The deadtime delay insertion ensures that no two complementary signals (channels (n) and (n+1)) drive the active state at the same time.

If POL(n) = 0, POL(n+1) = 0, and the deadtime is enabled, then when the channel (n) match (FTM counter = C(n)V) occurs, the channel (n) output remains at the low value until the end of the deadtime delay when the channel (n) output is set. Similarly, when the channel (n+1) match (FTM counter = C(n+1)V) occurs, the channel (n+1) output remains at the low value until the end of the deadtime delay when the channel (n+1) output is set. See the following figures.

If POL(n) = 1, POL(n+1) = 1, and the deadtime is enabled, then when the channel (n) match (FTM counter = C(n)V) occurs, the channel (n) output remains at the high value until the end of the deadtime delay when the channel (n) output is cleared. Similarly, when the channel (n+1) match (FTM counter = C(n+1)V) occurs, the channel (n+1) output remains at the high value until the end of the deadtime delay when the channel (n+1) output is cleared.

<!-- image -->

<!-- image -->

## NOTE

- The deadtime feature must be used only in Complementary mode.
- The deadtime feature is not available in Output Compare mode.

## 43.5.16.1 Deadtime insertion corner cases

If (PS[2:0] is cleared), (DTPS[1:0] = 0:0 or DTPS[1:0] = 0:1):

- and the deadtime delay is greater than or equal to the channel (n) duty cycle ((C(n+1)V - C(n)V)  FTM input clock), then the channel (n) output is always the inactive value (POL(n) bit value).
- and the deadtime delay is greater than or equal to the channel (n+1) duty cycle ((MOD - CNTIN + 1 - (C(n+1)V - C(n)V) )  FTM input clock), then the channel (n+1) output is always the inactive value (POL(n+1) bit value).

Although, in most cases the deadtime delay is not comparable to channels (n) and (n+1) duty cycle, the following figures show examples where the deadtime delay is comparable to the duty cycle.

<!-- image -->

<!-- image -->

## 43.5.17 Output mask

The output mask can be used to force channels output to their inactive state through software. For example: to control a BLDC motor.

Any write to the OUTMASK register updates its write buffer. The OUTMASK register is updated with its buffer value by PWM synchronization; see OUTMASK register synchronization.

If CH(n)OM = 1, then the channel (n) output is forced to its inactive state (POLn bit value). If CH(n)OM = 0, then the channel (n) output is unaffected by the output mask. See the following figure.

<!-- image -->

The following table shows the output mask result before the polarity control.

Table 284. Output mask result for channel (n) before the polarity control

|   CH(n)OM | Output Mask Input   | Output Mask Result   |
|-----------|---------------------|----------------------|
|         0 | inactive state      | inactive state       |
|         0 | active state        | active state         |
|         1 | inactive state      | inactive state       |
|         1 | active state        | inactive state       |

## 43.5.18 Polarity Control

The POLn bit selects the channel (n) output polarity:

- If POLn = 0, the channel (n) output polarity is high, so the logical one is the active state and the logical zero is the inactive state.
- If POLn = 1, the channel (n) output polarity is low, so the logical zero is the active state and the logical one is the inactive state.

## 43.5.19 Initialization

The initialization forces the CH(n)OI bit value to the channel (n) output when 1 is written to the INIT bit.

The initialization depends on COMP and DTEN bits. The following table shows the values that channels (n) and (n+1) are forced by initialization when the COMP and DTEN bits are zero.

Table 285. Initialization behavior when (COMP = 0 and DTEN = 0)

|   CH(n)OI |   CH(n+1)OI | Channel (n) Output   | Channel (n+1) Output   |
|-----------|-------------|----------------------|------------------------|
|         0 |           0 | is forced to zero    | is forced to zero      |
|         0 |           1 | is forced to zero    | is forced to one       |
|         1 |           0 | is forced to one     | is forced to zero      |
|         1 |           1 | is forced to one     | is forced to one       |

The following table shows the values that channels (n) and (n+1) are forced by initialization when (COMP = 1) or (DTEN = 1).

Table 286. Initialization behavior when (COMP = 1 or DTEN = 1)

|   CH(n)OI | CH(n+1)OI   | Channel (n) Output   | Channel (n+1) Output   |
|-----------|-------------|----------------------|------------------------|
|         0 | X           | is forced to zero    | is forced to one       |
|         1 | X           | is forced to one     | is forced to zero      |

## NOTE

The initialization feature must be used only with disabled FTM counter. See the description of the CLKS field in the Status and Control register.

## 43.5.20 Features Priority

The following figure shows the priority of the features used at the generation of channels (n) and (n+1) outputs signals.

FlexTimer (FTM)

<!-- image -->

## NOTE

The Initialization must not be used with Inverting and Software Output Control Mode.

## 43.5.21 External Trigger

If the CH(n)TRIG bit (register EXTTRIG) is set, where n = 0, 1, 2, 3, 4, 5, 6 or 7, then the FTM generates a trigger when the channel (n) match occurs (FTM counter = C(n)V) at the FTM external trigger output.

The width of a channel (n) trigger is one FTM input clock and the FTM is able to generate multiple triggers in one PWM period. See the figure below.

<!-- image -->

## 43.5.22 Initialization Trigger

Initialization trigger allows FTM to generate a trigger in some specific points of FTM counter cycle. This feature is controlled by the bits INITTRIGEN and ITRIGR. The INITTRIGEN bit enables the initialization trigger generation and the ITRIGR bit selects when the initialization trigger is generated.

If INITTRIGEN = 1 and ITRIGR = 1, then the initialization trigger is generated when FTM counter reaches a reload point according to the frequency of the reload opportunities (Reload Points).

NOTE

For this configuration of initialization trigger and in CPWM mode, the bits CNTMAX and CNTMIN select where the initialization trigger is generated.

If  INITTRIGEN = 1 and ITRIGR = 0, then the initialization trigger is generated when FTM counter is updated with the CNTIN register value. See the cases below.

1. When FTM counter is updated with CNTIN register value automatically.

<!-- image -->

2. When there is a write to CNT register.

<!-- image -->

## NOTE

This behavior is not available in CPWM mode.

3. When there is the FTM counter synchronization.

<!-- image -->

## NOTE

This behavior is not available in CPWM mode.

4. If (CNT = CNTIN), (CLKS[1:0] = 0:0), and a value different from zero is written to CLKS[1:0] bits.

FlexTimer (FTM)

<!-- image -->

## NOTE

This behavior is not available in CPWM mode.

5. If the channel (n) is in Input Capture mode, (ICRST = 1) and the selected input capture event occurs in the channel (n) input.

Figure 336. Example of the generation of the initialization trigger in the case 5.

<!-- image -->

## 43.5.23 Capture Test Mode

The Capture Test mode allows to test the CnV registers, the FTM counter and the interconnection logic between the FTM counter and CnV registers.

In this test mode, all channels must be configured for Input Capture Mode and FTM counter must be configured to the Up counting.

When the Capture Test mode is enabled (CAPTEST = 1), the FTM counter is frozen and any write to CNT register updates directly the FTM counter; see the following figure. After it was written, all CnV registers are updated with the written value to CNT register and CHF bits are set. Therefore, the FTM counter is updated with its next value according to its configuration. Its next value depends on CNTIN, MOD, and the written value to FTM counter.

FlexTimer (FTM)

The next reads of CnV registers return the written value to the FTM counter and the next reads of CNT register return FTM counter next value.

<!-- image -->

## 43.5.24 DMA

The channel generates a DMA transfer request according to DMA and CHIE bits. See the following table.

Table 287. Channel DMA transfer request

|   DMA |   CHIE | Channel DMA Transfer Request                                | Channel Interrupt                                |
|-------|--------|-------------------------------------------------------------|--------------------------------------------------|
|     0 |      0 | The channel DMA transfer request is not generated.          | The channel interrupt is not generated.          |
|     0 |      1 | The channel DMA transfer request is not generated.          | The channel interrupt is generated if (CHF = 1). |
|     1 |      0 | The channel DMA transfer request is not generated.          | The channel interrupt is not generated.          |
|     1 |      1 | The channel DMA transfer request is generated if (CHF = 1). | The channel interrupt is not generated.          |

If DMA = 1, the CHF bit is cleared either by channel DMA transfer done or reading CnSC while CHF is set and then writing a zero to CHF bit according to CHIE bit. See the following table.

Table 288. Clear CHF bit when DMA = 1

|   CHIE | How CHF Bit Can Be Cleared                                                                                                           |
|--------|--------------------------------------------------------------------------------------------------------------------------------------|
|      0 | CHF bit is cleared either when the channel DMA transfer is done or by reading CnSC while CHF is set and then writing a 0 to CHF bit. |
|      1 | CHF bit is cleared when the channel DMA transfer is done.                                                                            |

## 43.5.25 Dual Edge Capture Mode

The dual edge capture mode is enabled if DECAPEN = 1. This mode allows to measure a pulse width or period of the channel (n) input where n = 0, 2, 4 or 6. The channel (n) filter can be enabled for n = 0 or 2.

<!-- image -->

Figure 338. Diagram for Dual Edge Capture Mode when FLTPS[3:0] = 0

<!-- image -->

The channel (n) MSA bit defines if the dual edge capture mode is one-shot or continuous.

The channel (n) ELSB:ELSA bits select the edge that is captured by channel (n), and channel (n+1) ELSB:ELSA bits select the edge that is captured by channel (n+1). If both channel (n) ELSB:ELSA and channel (n+1) ELSB:ELSA bits select the same edge, then it is the period measurement. If these bits select different edges, then it is a pulse width measurement.

In the dual edge capture mode, only channel (n) input is used and channel (n+1) input is ignored.

FlexTimer (FTM)

If the selected edge by channel (n) bits is detected at channel (n) input, then channel (n) CHF bit is set and the channel (n) interrupt is generated (if channel (n) CHIE = 1). If the selected edge by channel (n+1) bits is detected at channel (n) input and (channel (n) CHF = 1), then channel (n+1) CHF bit is set and the channel (n+1) interrupt is generated (if channel (n+1) CHIE = 1).

The C(n)V register stores the FTM counter value when the selected edge by channel (n) is detected at channel (n) input. The C(n+1)V register stores the FTM counter value when the selected edge by channel (n+1) is detected at channel (n) input.

In this mode, a coherency mechanism (for channels (n) and (n+1)) ensures coherent data when the C(n)V and C(n+1)V registers are read. The only requirement is that C(n)V must be read before C(n+1)V.

## NOTE

- The dual edge capture mode must be used with channel (n) ELSB:ELSA = 0:1 or 1:0, channel (n+1) ELSB:ELSA = 0:1 or 1:0 and the FTM counter in Free running counter.

## 43.5.25.1 One-Shot Capture mode

The One-Shot Capture mode is selected when (DECAPEN = 1), and (channel (n) MSA = 0). In this capture mode, only one pair of edges at the channel (n) input is captured. The channel (n) ELSB:ELSA bits select the first edge to be captured, and channel (n+1) ELSB:ELSA bits select the second edge to be captured.

The edge captures are enabled while DECAP bit is set. For each new measurement in One-Shot Capture mode, first the channel (n) CHF and channel (n+1) CHF bits must be cleared, and then the DECAP bit must be set.

In this mode, the DECAP bit is automatically cleared by FTM when the edge selected by channel (n+1) is captured. Therefore, while DECAP bit is set, the one-shot capture is in process. When this bit is cleared, both edges were captured and the captured values are ready for reading in the C(n)V and C(n+1)V registers.

Similarly, when the channel (n+1) CHF bit is set, both edges were captured and the captured values are ready for reading in the C(n)V and C(n+1)V registers.

## 43.5.25.2 Continuous Capture mode

The Continuous Capture mode is selected when (DECAPEN = 1), and (channel (n) MSA = 1). In this capture mode, the edges at the channel (n) input are captured continuously. The channel (n) ELSB:ELSA bits select the initial edge to be captured, and channel (n+1) ELSB:ELSA bits select the final edge to be captured.

The edge captures are enabled while DECAP bit is set. For the initial use, first the channel (n) CHF and channel (n+1) CHF bits must be cleared, and then DECAP bit must be set to start the continuous measurements.

When the channel (n+1) CHF bit is set, both edges were captured and the captured values are ready for reading in the C(n)V and C(n+1)V registers. The latest captured values are always available in these registers even after the DECAP bit is cleared.

In this mode, it is possible to clear only the channel (n+1) CHF bit. Therefore, when the channel (n+1) CHF bit is set again, the latest captured values are available in C(n)V and C(n+1)V registers.

For a new sequence of the measurements in the Dual Edge Capture - Continuous mode, clear the channel (n) CHF and channel (n+1) CHF bits to start new measurements.

## 43.5.25.3 Pulse width measurement

If the channel (n) is configured to capture rising edges (channel (n) ELSB:ELSA = 0:1) and the channel (n+1) to capture falling edges (channel (n+1) ELSB:ELSA = 1:0), then the positive polarity pulse width is measured. If the channel (n) is configured to capture falling edges (channel (n) ELSB:ELSA = 1:0) and the channel (n+1) to capture rising edges (channel (n+1) ELSB:ELSA = 0:1), then the negative polarity pulse width is measured.

The pulse width measurement can be made in One-Shot Capture mode or Continuous Capture mode.

The following figure shows an example of the Dual Edge Capture - One-Shot mode used to measure the positive polarity pulse width. The DECAPEN bit selects the Dual Edge Capture mode, so it remains set. The DECAP bit is set to enable the measurement of next positive polarity pulse width. The channel (n) CHF bit is set when the first edge of this pulse is detected, that is, the edge selected by channel (n) ELSB:ELSA bits. The channel (n+1) CHF bit is set and DECAP bit is cleared when the second edge of this

FlexTimer (FTM)

pulse is detected, that is, the edge selected by channel (n+1) ELSB:ELSA bits. Both DECAP and channel (n+1) CHF bits indicate when two edges of the pulse were captured and the C(n)V and C(n+1)V registers are ready for reading.

<!-- image -->

The following figure shows an example of the Dual Edge Capture - Continuous mode used to measure the positive polarity pulse width. The DECAPEN bit selects the Dual Edge Capture mode, so it remains set. While the DECAP bit is set the configured measurements are made. The channel (n) CHF bit is set when the first edge of the positive polarity pulse is detected, that is, the edge selected by channel (n) ELSB:ELSA bits. The channel (n+1) CHF bit is set when the second edge of this pulse is detected, that is, the edge selected by channel (n+1) ELSB:ELSA bits. The channel (n+1) CHF bit indicates when two edges of the pulse were captured and the C(n)V and C(n+1)V registers are ready for reading.

FlexTimer (FTM)

<!-- image -->

## 43.5.25.4 Period measurement

If the channels (n) and (n+1) are configured to capture consecutive edges of the same polarity, then the period of the channel (n) input signal is measured. If both channels (n) and (n+1) are configured to capture rising edges (channel (n) ELSB:ELSA = 0:1 and channel (n+1) ELSB:ELSA = 0:1), then the period between two consecutive rising edges is measured. If both channels (n) and (n+1) are configured to capture falling edges (channel (n) ELSB:ELSA = 1:0 and channel (n+1) ELSB:ELSA = 1:0), then the period between two consecutive falling edges is measured.

The period measurement can be made in One-Shot Capture mode or Continuous Capture mode.

The following figure shows an example of the Dual Edge Capture - One-Shot mode used to measure the period between two consecutive rising edges. The DECAPEN bit selects the Dual Edge Capture mode, so it remains set. The DECAP bit is set to enable the measurement of next period. The channel (n) CHF bit is set when the first rising edge is detected, that is, the edge selected by channel (n) ELSB:ELSA bits. The channel (n+1) CHF bit is set and DECAP bit is cleared when the second rising edge is detected, that is, the edge selected by channel (n+1) ELSB:ELSA bits. Both DECAP and channel (n+1) CHF bits indicate when two selected edges were captured and the C(n)V and C(n+1)V registers are ready for reading.

FlexTimer (FTM)

<!-- image -->

The following figure shows an example of the Dual Edge Capture - Continuous mode used to measure the period between two consecutive rising edges. The DECAPEN bit selects the Dual Edge Capture mode, so it remains set. While the DECAP bit is set the configured measurements are made. The channel (n) CHF bit is set when the first rising edge is detected, that is, the edge selected by channel (n) ELSB:ELSA bits. The channel (n+1) CHF bit is set when the second rising edge is detected, that is, the edge selected by channel (n+1) ELSB:ELSA bits. The channel (n+1) CHF bit indicates when two edges of the period were captured and the C(n)V and C(n+1)V registers are ready for reading.

FlexTimer (FTM)

<!-- image -->

## 43.5.25.5 Read coherency mechanism

The Dual Edge Capture mode implements a read coherency mechanism between the FTM counter value captured in C(n)V and C(n+1)V registers. The read coherency mechanism is illustrated in the following figure. In this example, the channels (n) and (n+1) are in Dual Edge Capture - Continuous mode for positive polarity pulse width measurement. Thus, the channel (n) is configured to capture the FTM counter value when there is a rising edge at channel (n) input signal, and channel (n+1) to capture the FTM counter value when there is a falling edge at channel (n) input signal.

When a rising edge occurs in the channel (n) input signal, the FTM counter value is captured into channel (n) capture buffer. The channel (n) capture buffer value is transferred to C(n)V register when a falling edge occurs in the channel (n) input signal. C(n)V register has the FTM counter value when the previous rising edge occurred, and the channel (n) capture buffer has the FTM counter value when the last rising edge occurred.

When a falling edge occurs in the channel (n) input signal, the FTM counter value is captured into channel (n+1) capture buffer. The channel (n+1) capture buffer value is transferred to C(n+1)V register when the C(n)V register is read.

In the following figure, the read of C(n)V returns the FTM counter value when the event 1 occurred and the read of C(n+1)V returns the FTM counter value when the event 2 occurred.

FlexTimer (FTM)

<!-- image -->

C(n)V register must be read prior to C(n+1)V register in dual edge capture one-shot and continuous modes for the read coherency mechanism works properly.

## 43.5.26 Quadrature Decoder Mode

The quadrature decoder mode is enabled if QUADEN = 1. The quadrature decoder mode uses the input signals phase A and B to control the FTM counter increment and decrement.

<!-- image -->

<!-- image -->

Each one of input signals phase A and B has a filter that is equivalent to the channel input filter (Filter for Input Capture Mode). The phase A input filter is enabled by PHAFLTREN bit and its value is defined by CH0FVAL[3:0] bits. The phase B input filter is enabled by PHBFLTREN bit and its value is defined by CH1FVAL[3:0] bits.

Except for CH0FVAL[3:0] and CH1FVAL[3:0] bits, no channel logic is used in quadrature decoder mode.

## NOTE

The FTM counter is clocked by the phase A and B input signals when quadrature decoder mode is enabled. Therefore it is expected that the quadrature decoder mode be used only with the FTM channels in input capture or output compare modes.

## NOTE

An edge at phase A must not occur together an edge at phase B and vice-versa.

The PHAPOL bit selects the polarity of the phase A input, and the PHBPOL bit selects the polarity of the phase B input.

The QUADMODE selects the encoding mode used in the quadrature decoder mode. If QUADMODE = 1, then the count and direction encoding mode is enabled; see the following figure. In this mode, the phase B input value indicates the counting direction, and the phase A input defines the counting rate. The FTM counter is updated when there is a rising edge at phase A input signal.

<!-- image -->

If QUADMODE = 0, then the phase A and phase B Encoding mode is enabled; see the following figure. In this mode, the relationship between phase A and B signals indicates the counting direction, and phase A and B signals define the counting rate. The FTM counter is updated when there is an edge either at the phase A or phase B signals.

If PHAPOL = 0 and PHBPOL = 0, then the FTM counter increment happens when:

- there is a rising edge at phase A signal and phase B signal is at logic zero;
- there is a rising edge at phase B signal and phase A signal is at logic one;
- there is a falling edge at phase B signal and phase A signal is at logic zero;
- there is a falling edge at phase A signal and phase B signal is at logic one;

and the FTM counter decrement happens when:

- there is a falling edge at phase A signal and phase B signal is at logic zero;
- there is a falling edge at phase B signal and phase A signal is at logic one;
- there is a rising edge at phase B signal and phase A signal is at logic zero;
- there is a rising edge at phase A signal and phase B signal is at logic one.

Figure 348. Quadrature Decoder - Phase A and Phase B Encoding Mode

<!-- image -->

The following figure shows the FTM counter overflow in up counting. In this case, when the FTM counter changes from MOD to CNTIN, TOF and TOFDIR bits are set. TOF bit indicates the FTM counter overflow occurred. TOFDIR indicates the counting was up when the FTM counter overflow occurred.

Figure 349. FTM Counter Overflow in Up Counting for Quadrature Decoder Mode

<!-- image -->

The following figure shows the FTM counter overflow in down counting. In this case, when the FTM counter changes from CNTIN to MOD, TOF bit is set and TOFDIR bit is cleared. TOF bit indicates the FTM counter overflow occurred. TOFDIR indicates the counting was down when the FTM counter overflow occurred.

<!-- image -->

## 43.5.26.1 Quadrature Decoder boundary conditions

The following figures show the FTM counter responding to motor jittering typical in motor position control applications.

<!-- image -->

The following figure shows motor jittering produced by the phase B and A pulses respectively:

Figure 352. Motor position jittering near maximum and minimum count value

<!-- image -->

The first highlighted transition causes a jitter on the FTM counter value near the maximum count value (MOD). The second indicated transition occurs on phase A and causes the FTM counter transition between the maximum and minimum count values which are defined by MOD and CNTIN registers.

The appropriate settings of the phase A and phase B input filters are important to avoid glitches that may cause oscillation on the FTM counter value. The preceding figures show examples of oscillations that can be caused by poor input filter setup. Thus, it is important to guarantee a minimum pulse width to avoid these oscillations.

## 43.5.27 Debug mode

When the chip is in Debug mode, the BDMMODE[1:0] bits select the behavior of the FTM counter, the channel (n) CHF bit, the channels output, and the writes to the MOD, CNTIN, and C(n)V registers according to the following table.

Table 289. FTM behavior when the chip Is in Debug mode

|   BDMMODE | FTM Counter     | channel (n) CHF bit   | FTM Channels Output                                                       | Writes to MOD, CNTIN, and C(n)V Registers              |
|-----------|-----------------|-----------------------|---------------------------------------------------------------------------|--------------------------------------------------------|
|        00 | Stopped         | can be set            | Functional mode                                                           | Writes to these registers bypass the registers buffers |
|        01 | Stopped         | is not set            | The channels outputs are forced to their safe value according to POLn bit | Writes to these registers bypass the registers buffers |
|        10 | Stopped         | is not set            | The channels outputs are frozen when the chip enters in Debug mode        | Writes to these registers bypass the registers buffers |
|        11 | Functional mode | can be set            | Functional mode                                                           | Functional mode                                        |

Note that if BDMMODE[1:0] = 2'b00 then the channels outputs remain at the value when the chip enters in Debug mode, because the FTM counter is stopped. However, the following situations modify the channels outputs in this Debug mode.

- Write any value to CNT register; see Counter reset. In this case, the FTM counter is updated with the CNTIN register value and the channels outputs are updated to the initial value - except for those channels set to Output Compare mode.

FlexTimer (FTM)

- FTM counter is reset by PWM Synchronization mode; see FTM counter synchronization. In this case, the FTM counter is updated with the CNTIN register value and the channels outputs are updated to the initial value - except for channels in Output Compare mode.
- In the channels outputs initialization, the channel (n) output is forced to the CH(n)OI bit value when the value 1 is written to INIT bit. See Initialization.

## NOTE

If CLKS[1:0] = 2'b00 in Debug, a non-zero value is written to CLKS in Debug, and CnV = CNTIN when the Debug is disabled, then the CHF bit is set (since if the channel is a 0% EPWM signal) when the Debug is disabled.

## 43.5.28 Reload Points

This feature allows to update the registers CNTIN, HCR, MOD and C(n)V with the value of their write buffer at the selected reload point.

## NOTE

- This feature is independent of the PWM synchronization.
- At these reload points neither the channels outputs nor the FTM counter are changed. Software must select these reload points at the safe points in time.

## 43.5.28.1 Reload Opportunities

The reload opportunities are:

1. At the half cycle

This reload opportunity is enabled if (HCSEL = 1) and it happens at the half cycle (FTM counter = HCR register). The software should calculate the half cycle value according to the FTM counter configuration, then writes this value to the register HCR.

2. At the channel (n) match

This reload opportunity is enabled if (CH(n)SEL = 1) and it happens at the channel (n) match (FTM counter = C(n)V).

3. When the FTM counter is an up counter

This reload opportunity is when the FTM counter changes from (MOD) to (CNTIN - 1) and it is always enabled.

The following figure shows an example of the reload opportunities at the half cycle, at the channels match, and when the FTM counter is an up counter.

<!-- image -->

4. When the FTM counter is an up-down counter

In this case, the reload opportunities are enabled by the bits CNTMAX and CNTMIN according to Table 290.

Table 290. Reload opportunities enabled by the bits CNTMAX and CNTMIN when the FTM counter is up-down counter

|   CNTMAX |   CNTMIN | Reload Opportunities                                                                                                     |
|----------|----------|--------------------------------------------------------------------------------------------------------------------------|
|        0 |        0 | when the FTM counter changes from (MOD) to (MOD - 1)                                                                     |
|        0 |        1 | when the FTM counter changes from (CNTMIN) to (CNTMIN + 1)                                                               |
|        1 |        0 | when the FTM counter changes from (MOD) to (MOD - 1)                                                                     |
|        1 |        1 |  when the FTM counter changes from (MOD) to (MOD - 1), and  when the FTM counter changes from (CNTMIN) to (CNTMIN + 1) |

The following figure shows an example of the reload opportunities at the half cycle, at the channels match, and when the FTM counter is an up-down counter.

<!-- image -->

## 43.5.28.2 Frequency of Reload Opportunities

The LDFQ[4:0] bits define the number of enabled reload opportunities should happen until an enabled reload opportunity becomes a reload point. The following figure shows an example when the LDFQ[4:0] = 4.

<!-- image -->

If LDFQ[4:0] = 0, then all reload opportunities are reload points.

The counter of the reload opportunities is reset when there is a write to the register CNT.

The RF bit is set at each reload point (see the figure above) independent of LDOK bit value. The reload point interrupt is generated when (RF = 1) and (RIE = 1).

## 43.5.28.3 Update of the Registers

After writing new value to the registers with write buffer, selecting which of them will be updated (according to Table 291), selecting the reload opportunities, selecting the frequency of the reload opportunities, thus the LDOK bit should be set to enable the update of these registers at the next reload point.

Table 291. Additional conditions to update the registers

| Register          | Additional Condition                                           |
|-------------------|----------------------------------------------------------------|
| CNTIN             | CNTINC = 1                                                     |
| HCR               | -                                                              |
| MOD               | -                                                              |
| C(n)V and C(n+1)V | SYNCENm = 1, where m is the pair of the channels (n) and (n+1) |

## 43.5.29 Global Load

The global load mechanism allows several modules to have their double buffered registers synchronously reloaded after a synchronization event if a write to one operation is performed in the global load OK (GLDOK) bit in the PWMLOAD register. Global load may be enabled or disabled configuring the global load enable (GLEN) bit in the PWMLOAD register. Writing one in the GLDOK bit with GLEN enabled has the same effect of writing one in the LDOK bit. Refer to SoC specific information about global load connections.

Global load mechanism allows MOD, HCR, CNTIN, and C(n)V registers to be updated with the content of the register buffer at configurable reload point. The figure below shows an example of connection between FTM global load inputs and outputs considering that GLDOK bit is implemented outside from FTM module.

<!-- image -->

## 43.5.30 Global time base (GTB)

The global time base (GTB) is a FTM function that allows the synchronization of multiple FTM modules on a chip. The following figure shows an example of the GTB feature used to synchronize two FTM modules. In this case, the FTM A and B channels can behave as if just one FTM module was used, that is, a global time base.

FlexTimer (FTM)

<!-- image -->

The GTB functionality is implemented by the GTBEEN and GTBEOUT bits in the CONF register, the input signal gtb\_in, and the output signal gtb\_out. The GTBEEN bit enables gtb\_in to control the FTM counter enable signal:

- If GTBEEN = 0, each one of FTM modules works independently according to their configured mode.
- If GTBEEN = 1, the FTM counter update is enabled only when gtb\_in is 1.

In the configuration described in the preceding figure, FTM modules A and B have their FTM counters enabled if at least one of the gtb\_out signals from one of the FTM modules is 1. There are several possible configurations for the interconnection of the gtb\_in and gtb\_out signals, represented by the example glue logic shown in the figure. Note that these configurations are chip-dependent and implemented outside of the FTM modules. See the chip-specific FTM information for the chip's specific implementation.

## NOTE

- In order to use the GTB signals to synchronize the FTM counter of different FTM modules, the configuration of each FTM module should guarantee that its FTM counter starts counting as soon as the gtb\_in signal is 1.
- The GTB feature does not provide continuous synchronization of FTM counters, meaning that the FTM counters may lose synchronization during FTM operation. The GTB feature only allows the FTM counters to start their operation synchronously.

## 43.5.30.1 Enabling the global time base (GTB)

To enable the GTB feature, follow these steps for each participating FTM module:

1. Stop the FTM counter: Write 00b to SC[CLKS].
2. Program the FTM to the intended configuration. The FTM counter mode needs to be consistent across all participating modules.
3. Write 1 to CONF[GTBEEN] and write 0 to CONF[GTBEOUT] at the same time.
4. Select the intended FTM counter clock source in SC[CLKS]. The clock source needs to be consistent across all participating modules.
5. Reset the FTM counter: Write any value to the CNT register.

To initiate the GTB feature in the configuration described in the preceding figure, write 1 to CONF[GTBEOUT] in the FTM module used as the time base.

## 43.5.31 Channel trigger output

The channel trigger output provides a trigger signal which has one FTM input clock period width in the channel (n) output.

If the TRIGMODE bit of the CnSC register is set (TRIGMODE = 1), a trigger pulse with one FTM input clock width is generated in the channel (n) output when a match occurs. It is only allowed to use trigger mode when channel (n) is in EPWM or CPWM modes.

The figures below show some cases of channel (n) trigger generation in the channel (n) output.

<!-- image -->

## 43.5.32 External Control of Channels Output

The channel (n) PWMEN bit can be used in an FTM external logic to control the final value of the channel (n) output. The following figure shows an example of this external logic.

The term "channel (n) output" means the channel (n) output value after the Polarity Control. See Features Priority and Polarity Control for more details.

<!-- image -->

## 43.5.33 Dithering

FTM implements a fractional delay to achieve fine resolution on the generated PWM signals using dithering. The dithering can be used by applications where more resolution than one unit of the FTM counter is needed.

Two kinds of dithering are available: PWM period dithering and edge dithering.

## 43.5.33.1 PWM Period Dithering

The PWM period dithering is enabled when a non-zero value is written to FRACMOD.

The internal accumulator used in the PWM period dithering is reset when:

- the field MOD of the register MOD\_MIRROR is updated with the value of its write buffer,
- the FRACMOD is updated with the value of its write buffer, or
- the FTM counter is stopped.

## NOTE

For the PWM period dithering, the register MOD\_MIRROR should be used instead of the register MOD.

To avoid inconsistencies, the field FRACMOD is cleared when the field MOD of the register MOD is updated with the value of its write buffer.

The PWM period dithering is not available:

- when the FTM counter is a free running counter
- when the FTM is in quadrature decoder mode

## 43.5.33.1.1 Up Counting

When the FTM counter is an up counter and the PWM period dithering is enabled, at the end of each PWM period, the FRACMOD value is added to an internal 5-bit accumulator. When this accumulator overflows (that is, the result of the adding is greater or equal than 0x20), then one unit of FTM counter is added to the end of the current PWM period, and the accumulator remains with the rest of the subtraction: (the result of this adding - 0x20).

Due to one unit of FTM counter that can be added to the PWM period, the largest valid value for MOD is 0xFFFE for PWM period dithering with unsigned counting and 0x7FFE for PWM period dithering with signed counting.

The following figures show some examples of PWM period dithering when the FTM counter is an up counter.

<!-- image -->

## Assuming:

- the FTM counter is an up counter,
- T is one unit of FTM counter,
- the PWM period without period dithering is [(MOD - CNTIN + 1) x T],
- the number of PWM periods with period dithering is FRACMOD,
- the PWM period with period dithering is [(MOD - CNTIN + 1 + 1) x T],

thus, the average period (in decimal) is [(MOD - CNTIN + 1) + (FRACMOD/32)] x T, where the integer value is (MOD - CNTIN + 1) and the fractional value is (FRACMOD/32). See the example below.

<!-- image -->

## NOTE

For the generation of 100% PWM signal in the channel (n) (with channel (n) ELSB:ELSA = 2'b10) using EPWM mode and PWM Period Dithering, it is recommended to use (C(n) &gt; MOD + 1).

For the generation of PWM signals in the channel (n) (with channel (n) ELSB:ELSA = 2'b10) using Combine mode and PWM Period Dithering, it is recommended to use:

- For 0% PWM signal: (C(n)V &gt; MOD + 1) and (C(n+1)V &gt; MOD + 1);
- For 100% PWM signal: (C(n)V = CNTIN) and (C(n+1)V &gt; MOD + 1).

For the generation of PWM signals in the channel (n) (with channel (n) ELSB:ELSA = 2'b10) using Modified Combine PWM mode and PWM Period Dithering, it is recommended to use:

- For 0% PWM signal: (C(n)V &gt; MOD + 1) and (CNTIN  C(n+1)V  MOD);
- For 100% PWM signal: (CNTIN  C(n)V  MOD) and (C(n+1)V &gt; MOD + 1).

## 43.5.33.1.2 Up-Down Counting

When the FTM counter is an up-down counter and the PWM period dithering is enabled, at the end of each PWM period, the FRACMOD value is added to an internal 5-bit accumulator. When this accumulator overflows (that is, the result of the adding is greater or equal than 0x20), then one unit of FTM counter is added to the end of the current PWM period and other unit is added to the begin of the next PWM period (see the figure below). After the accumulator overflows, the accumulator remains with the rest of the subtraction: (the result of this adding - 0x20).

Due to one unit of FTM counter that can be added to the PWM period, the largest valid value for MOD is 0x7FFE for PWM period dithering in up-down counting (CPWM mode).

FlexTimer (FTM)

## NOTE

For the PWM edge dithering, the register C(n)V\_MIRROR should be used instead of the register C(n)V.

To avoid inconsistencies, the field FRACVAL is cleared when the field VAL of the register C(n)V is updated with the value of its write buffer.

The PWM edge dithering is not available:

- to the channel in input modes, and
- to the channel in output compare mode.

## 43.5.33.2.1 EPWM Mode

The PWM edge dithering for channel (n) in EPWM mode is enabled when a non-zero value is written to the channel (n) FRACVAL.

If the channel (n) is in EPWM mode and the PWM edge dithering is enabled, at the end of each EPWM period, the channel (n) FRACVAL value is added to the channel (n) internal 5-bit accumulator. When this accumulator overflows (that is, the result of the adding is greater or equal than 0x20), the accumulator remains with the rest of the subtraction: (the result of this adding - 0x20).

In this configuration, the initial edge of EPWM duty cycle happens when (FTM counter = CNTIN), its position is not modified by the PWM edge dithering. If there was not the overflow of the channel (n) accumulator in the current EPWM period, then the final edge of EPWM duty cycle happens on the channel (n) match (FTM counter = C(n)V), that is, its position is not modified by the edge dithering. However, if there was the overflow of the channel (n) accumulator in the current EPWM period, then the final edge of EPWM duty cycle happens when (FTM counter = C(n)V + 0x0001).

The following figures show some examples of PWM edge dithering when the channel (n) is in EPWM mode.

FlexTimer (FTM)

<!-- image -->

## NOTE

For the generation of 100% PWM signal in the channel (n) (with channel (n) ELSB:ELSA = 2'b10) using CPWM mode and PWM Period Dithering, it is recommended to use (C(n)V[15] = 0) and (C(n)V &gt; MOD + 1) and (MOD  0x0000).

## 43.5.33.2 PWM Edge Dithering

The channel (n) internal accumulator used in the PWM edge dithering is reset when:

- the field VAL of the register C(n)V\_MIRROR is updated with the value of its write buffer,
- the FRACVAL is updated with the value of its write buffer, or
- the FTM counter is stopped.

FlexTimer (FTM)

<!-- image -->

## Assuming:

- the channel (n) is in EPWM mode,
- T is one unit of FTM counter,
- the EPWM duty cycle without edge dithering is [(C(n)V - CNTIN) x T],
- the number of PWM periods which duty cycle that has edge dithering is FRACVAL,
- the EWM duty cycle with edge dithering is [(C(n)V - CNTIN + 1) x T],

thus, the average duty cycle (in decimal) is [(C(n)V - CNTIN) + (FRACVAL/32)] x T, where the integer value is (C(n)V - CNTIN) and the fractional value is (FRACVAL/32). See the example below.

Figure 365. Example of Average Duty Cycle when the Channel (n) is in EPWM Mode with PWM Edge Dithering

<!-- image -->

## 43.5.33.2.2 CPWM Mode

The PWM edge dithering for channel (n) in CPWM mode is enabled when a non-zero value is written to the channel (n) FRACVAL.

If the channel (n) is in CPWM mode and the PWM edge dithering is enabled, at the end of each CPWM period, the channel (n) FRACVAL value is added to the channel (n) internal 5-bit accumulator. When this accumulator overflows (that is, the result of the adding is greater or equal than 0x20), the accumulator remains with the rest of the subtraction: (the result of this adding - 0x20).

In this configuration, if there was not the overflow of the channel (n) accumulator in the current CPWM period, then the duty cycle is not modified by the PWM edge dithering, that is, the initial edge of CPWM duty cycle happens on channel (n) match (FTM counter = C(n)V) when the FTM counter is decrementing, and the final edge of CPWM duty cycle on channel (n) match when the FTM counter is incrementing.

However, if there was the overflow of the channel (n) accumulator in the current CPWM period, then the initial edge of CPWM duty cycle happens when (FTM counter = C(n)V + 0x0001) and the FTM counter is decrementing, and the final edge of CPWM duty cycle when (FTM counter = C(n)V + 0x0001) and the FTM counter is incrementing.

The following figure shows an example of PWM edge dithering when the channel (n) is in CPWM mode.

<!-- image -->

## 43.5.33.2.3 Combine Mode

In the Combine mode, the PWM edge dithering can be done:

- in the channel (n) match (FTM counter = C(n)V) edge or
- in the channel (n+1) match (FTM counter = C(n+1)V) edge.

The channel (n) match edge dithering is enabled when a non-zero value is written to the channel (n) FRACVAL.

For the channel (n) match edge dithering, the channel (n) has an internal 5-bit accumulator. At the end of each PWM period, the channel (n) FRACVAL value is added to the channel (n) accumulator. When this accumulator overflows (that is, the result of the adding is greater or equal than 0x20), the accumulator remains with the rest of the subtraction: (the result of this adding - 0x20).

If there was not the overflow of the channel (n) accumulator in the current PWM period, the channel (n) match edge is not modified, that is, it happens on channel (n) match. However, if there was the overflow of the channel (n) accumulator, the channel (n) match edge happens when (FTM counter = C(n)V + 0x0001).

The following figure shows an example of the channel (n) match edge dithering when the channels (n) and (n+1) are in Combine mode.

<!-- image -->

The channel (n+1) match edge dithering is enabled when a non-zero value is written to the channel (n+1) FRACVAL.

For the channel (n+1) match edge dithering, the channel (n+1) has an internal 5-bit accumulator. At the end of each PWM period, the channel (n+1) FRACVAL value is added to the channel (n+1) accumulator. When this accumulator overflows (that is, the result of the adding is greater or equal than 0x20), the accumulator remains with the rest of the subtraction: (the result of this adding - 0x20).

If there was not the overflow of the channel (n+1) accumulator in the current PWM period, the channel (n+1) match edge is not modified, that is, it happens on channel (n+1) match. However, if there was the overflow of the channel (n+1) accumulator, the channel (n+1) match edge happens when (FTM counter = C(n+1)V + 0x0001).

The following figure shows an example of the channel (n+1) match edge dithering when the channels (n) and (n+1) are in Combine mode.

FlexTimer (FTM)

FlexTimer (FTM)

<!-- image -->

## NOTE

It is recommended to use only one PWM Edge Dithering (channel (n) PWM Edge Dithering or channel (n+1) PWM Edge Dithering) at a time.

For the generation of 0% PWM in the channel (n) (with channel (n) ELSB:ELSA = 2'b10) using Combine mode and PWM Edge Dithering, it is recommended to use:

- (C(n)V &lt; CNTIN or C(n)V &gt; MOD) and (channel (n) FRACVAL is zero) and
- (channel (n+1) FRACVAL is zero).

For the generation of 100% PWM in the channel (n) (with channel (n) ELSB:ELSA = 2'b10) using Combine mode and PWM Edge Dithering, it is recommended to use:

- (C(n)V = CNTIN) and (channel (n) FRACVAL is zero) and
- (C(n+1)V &lt; CNTIN or C(n+1)V &gt; MOD) and (channel (n+1) FRACVAL is zero).

## 43.5.33.2.4 Modified Combine PWM Mode

In the Modified Combine PWM mode, the PWM edge dithering can be done:

- in the channel (n) match (FTM counter = C(n)V) edge or
- in the channel (n+1) match (FTM counter = C(n+1)V) edge.

The channel (n) match edge dithering is enabled when a non-zero value is written to the channel (n) FRACVAL.

For the channel (n) match edge dithering, the channel (n) has an internal 5-bit accumulator. At the end of each PWM period, the channel (n) FRACVAL value is added to the channel (n) accumulator. When this accumulator overflows (that is, the result of the adding is greater or equal than 0x20), the accumulator remains with the rest of the subtraction: (the result of this adding - 0x20).

If there was not the overflow of the channel (n) accumulator in the current PWM period, the channel (n) match edge is not modified, that is, it happens on channel (n) match. However, if there was the overflow of the channel (n) accumulator, the channel (n) match edge happens when (FTM counter = C(n)V + 0x0001).

The following figure shows an example of the channel (n) match edge dithering when the channels (n) and (n+1) are in Modified Combine PWM mode.

<!-- image -->

The channel (n+1) match edge dithering is enabled when a non-zero value is written to the channel (n+1) FRACVAL.

For the channel (n+1) match edge dithering, the channel (n+1) has an internal 5-bit accumulator. At the end of each PWM period, the channel (n+1) FRACVAL value is added to the channel (n+1) accumulator. When this accumulator overflows (that is, the result of the adding is greater or equal than 0x20), the accumulator remains with the rest of the subtraction: (the result of this adding - 0x20).

If there was not the overflow of the channel (n+1) accumulator in the current PWM period, the channel (n+1) match edge is not modified, that is, it happens on channel (n+1) match. However, if there was the overflow of the channel (n+1) accumulator, the channel (n+1) match edge happens when (FTM counter = C(n+1)V + 0x0001).

The following figure shows an example of the channel (n+1) match edge dithering when the channels (n) and (n+1) are in Modified Combine PWM mode.

<!-- image -->

## NOTE

It is recommended to use only one PWM Edge Dithering (channel (n) PWM Edge Dithering or channel (n+1) PWM Edge Dithering) at a time.

For the generation of 0% PWM in the channel (n) (with channel (n) ELSB:ELSA = 2'b10) using Modified Combine PWM mode and PWM Edge Dithering, it is recommended to use:

- (C(n)V &lt; CNTIN or C(n)V &gt; MOD) and (channel (n) FRACVAL is zero) and
- (CNTIN  C(n+1)V  MOD) and (channel (n+1) FRACVAL is zero).

For the generation of 100% PWM in the channel (n) (with channel (n) ELSB:ELSA = 2'b10) using Modified Combine PWM mode and PWM Edge Dithering, it is recommended to use:

- (CNTIN  C(n)V  MOD) and (channel (n) FRACVAL is zero) and
- (C(n+1)V &lt; CNTIN or C(n+1)V &gt; MOD) and (channel (n+1) FRACVAL is zero).

## 43.6 Reset Overview

The FTM is reset whenever any chip reset occurs.

When the FTM exits from reset:

- the FTM counter and the prescaler counter are zero and are stopped (CLKS[1:0] = 2'b00);
- the timer overflow interrupt is zero (Timer Overflow Interrupt);
- the channels interrupts are zero (Channel (n) Interrupt);
- the channels are in input capture mode (Input Capture Mode);
- the channels outputs are zero;
- the channels ELSB:ELSA = 0:0 (Channel Modes) and PWMEN = 0 (External Control of Channels Output).

The following figure shows the FTM behavior after the reset. At the reset (item 1), the FTM counter is disabled (CLKS[1:0] = 2'b00), its value is updated to zero and the pins are not controlled by FTM (Channel Modes).

After the reset, the FTM should be configured (item 2). It is necessary to define the FTM counter mode, the FTM counting limits (MOD and CNTIN registers value), the channels mode and CnV registers value according to the channels mode.

Thus, it is recommended to write any value to CNT register (item 3). This write updates the FTM counter with the CNTIN register value and the channels output with its initial value (except for channels in output compare mode) (Counter reset).

The next step is to select the FTM counter clock by the CLKS[1:0] bits (item 4). It is important to highlight that the pins are only controlled by FTM when CLKS[1:0] bits are different from zero.

<!-- image -->

The following figure shows an example when the channel (n) is in Output Compare mode and the channel (n) output is toggled when there is a match. In the Output Compare mode, the channel output is not updated to its initial value when there is a write to CNT register (item 3). In this case, use the software output control (Software Output Control Mode) or the initialization (Initialization) to update the channel output to the selected value (item 4).

Figure 372. FTM behavior after reset when the channel (n) is in Output Compare mode

<!-- image -->

## 43.7 FTM Interrupts

## 43.7.1 Timer Overflow Interrupt

The timer overflow interrupt is generated when (TOIE = 1) and (TOF = 1).

## 43.7.2 Reload Point Interrupt

The Reload Point interrupt is generated when (RIE = 1) and (RF = 1).

## 43.7.3 Channel (n) Interrupt

The channel (n) interrupt is generated when (CHIE = 1) and (CHF = 1).

## 43.8 Initialization Procedure

The following initialization procedure is recommended to configure the FlexTimer. This procedure can also be used to do a new configuration.

1. Define the POL bits.
2. Mask the channels outputs using SYNCHOM = 0. Two clocks after the write to OUTMASK, the channels outputs are in the safe value.
3. (Re)Configuration FTM counter and channels to generation of periodic signals:
- a. Disable the clock. Disable the Quadrature Decoder mode.
- b. Examples of (re)configuration:
- Write to MOD
- Write to CNTIN
- Configure the channels that will be used
- Write to CnV for the channels in output modes
- (Re)Configure deadtime
- Do not use the SWOC without SW synchronization (see item 6)
- Do not use the Inverting without SW synchronization (see item 6)
- Do not use the Initialization
- Do not change the polarity control
- Do not configure the HW synchronization
4. Write any value to CNT. The FTM Counter is reset and the channels outputs are updated according to new configuration.
5. Enable the clock. Write to CLKS[1:0] bits a value different from zero. Enable the Quadrature Decoder mode (if it is desired).
6. Configure the SW synchronization for SWOC (if it is necessary), Inverting (if it is necessary) and Output Mask (always)
- a. Select synchronization for Output Mask
- Write to SYNC (SWSYNC = 0, TRIG2 = 0, TRIG1 = 0, TRIG0 = 0, SYNCHOM = 1, REINIT = 0, CNTMAX = 0, CNTMIN = 0)
- b. Write to SYNCONF
- HW Synchronization can not be enabled (HWSOC = 0, HWINVC = 0, HWOM = 0, HWWRBUF = 0, HWRSTCNT = 0, HWTRIGMODE = 0)
- SW Synchronization for SWOC (if it is necessary): SWSOC = [0/1] and SWOC = [0/1]
- SW Synchronization for Inverting (if it is necessary): SWINVC = [0/1] and INVC = [0/1]
- SW Synchronization for SWOM (always): SWOM = 1
- No enable the SW Synchronization for write buffers (because the writes to registers with write buffer are done using CLKS[1:0] = 2'b00): SWWRBUF = 0 and CNTINC = 0
- SW Synchronization for counter reset (always): SWRSTCNT = 1
- Enhanced synchronization (always): SYNCMODE = 1

- c. If the SWOC is used (SWSOC = 1 and SWOC = 1), then write to SWOCTRL register.
- d. If the Inverting is used (SWINVC = 1 and INVC = 1), then write to INVCTRL register.
- e. Write to OUTMASK to enable the masked channels.
7. Generate the Software Trigger
- Write to SYNC (SWSYNC = 1, TRIG2 = 0, TRIG1 = 0, TRIG0 = 0, SYNCHOM = 1, REINIT = 0, CNTMAX = 0, CNTMIN = 0)
8. Configure PWMEN bits (External Control of Channels Output).

FlexTimer (FTM)

## Chapter 44 Real Time Clock (RTC)

## 44.1 Chip-specific RTC information

## 44.1.1 RTC Clocking

The SIRC is the only clock available to the RTC module during the standby mode. For SIRC specs, refer to the SIRC section in the chip DataSheet.

## 44.2 Overview

The Real-Time Clock (RTC) is a free-running counter used for time keeping applications. The RTC can be configured to generate an interrupt at a pre-defined interval. The RTC also supports an API function used to generate a periodic wakeup request to exit a low-power mode or an interrupt request.

## 44.2.1 Block diagram

The following figure shows clock gating for RTC clocks.

<!-- image -->

The following figure shows the block diagram of RTC.

Figure 374. Block diagram

## 44.2.2 Features

RTC features include:

- 32-bit counter
- Selectable counter clock sources (IRCs and OSCs)
- Clock source 0
- Clock source 1
- Clock source 2
- Clock source 3
- Optional 512 prescaler and optional 32 prescaler to run the 32 bit counter.
- RTC interrupt with interrupt enable.
- Counter runs in all modes of operation.
- RTC counter is reset when the counter is disabled by software and by reset to RTC block.
- Autonomous periodic interrupt support includes:
- 32-bit compare value to support range of wakeup intervals/interrupts
- API logic has a separate enable to support changing compare value while RTC is running
- API interrupt with interrupt enable
- Operates in all modes
- API compare value can be modified while RTC is running
- Optional interrupt for RTC match, API match, and RTC rollover.

<!-- image -->

Real Time Clock (RTC)

## 44.3 Functional description

## 44.3.1 RTC

The RTC consists of a 32-bit free running counter enabled with the CNTEN bit (CNTEN, when negated, asynchronously resets the counter and synchronously enables the counter when enabled). After disabling CNTEN, RTCVAL, APIVAL,  needs to be written again for desired functionality. The value of the counter may be read via the RTC Counter register (RTCCNT) register. Note that because of clock synchronization, the RTC Counter register (RTCCNT) value may represent a previous counter value. The difference between the counter and the read value depends on the ratio of counter clock and bus clock. Maximum possible difference between the two is 6 count values.

The clock source to the counter is selected with the CLKSEL field, which gives four options for clocking the RTC/API. The four clock sources are assumed to be on these:Clock source 0, Clock source 1, Clock source 2, and Clock source 3. The output of the clock mux can be optionally divided by a combination of 512 and 32 to give various count periods for different clock sources. Note that the CNTEN bit should be disabled when the RTC/API clock source is switched.

When the RTC Counter register (RTCCNT) counter value for counter bits 31-0 match the 32-bit value in the RTCVAL field, then the RTCF interrupt flag bit is set (after proper clock synchronization). If the RTCIE interrupt enable bit is set, then the RTC interrupt request is generated. RTC Compare value register (RTCVAL) register can be written only when INV\_RTC bit is clear. Initially INV\_RTC=0, and hence RTC Compare value register (RTCVAL) can be written once and hence INV\_RTC gets set. This bit can now be cleared only by enabling the RTC counter. After the counter is enabled, RTC Compare value register (RTCVAL) can be written anytime, until RTC is disabled again. RTC Compare value register (RTCVAL) is first synchronized to the RTC clock domain, therefore, if RTC Compare value register (RTCVAL) is updated at the point where a counter match is due to happen in the next 2-3 RTC clocks because of previous RTC Compare value register (RTCVAL), the RTCF flag is set. However, if the RTC Compare value register (RTCVAL) is updated at the point where no counter match is due as per the previous RTC Compare value register (RTCVAL), the RTCF flag is set when the counter matches the new RTC Compare value register (RTCVAL).

If RTC Compare value register (RTCVAL) is updated just after counter match, new RTC Compare value register (RTCVAL) value should not be within next 6 RTC counter values.

A rollover interrupt can be generated when the RTC transitions from a count of 0xFFFF\_FFFF to 0x0000\_0000. The rollover flag is enabled by setting the ROVREN bit. If RTCIE is enabled, an interrupt request is generated for an RTC counter rollover.

All the flags and counter values are synchronized with the Bus clock. It is assumed that the Bus clock and RTC clock selected through CLKSEL follows the below relation:

Bus clock &gt;= (1.5 * RTC clock )/(div\_factor)

- if both DIV32EN and DIV512EN bits are disabled, div\_factor = 1
- if DIV32EN=1 and DIV512EN=0, div\_factor = 32
- if DIV32EN=0 and DIV512EN=1, div\_factor = 512
- if both DIV32EN and DIV512EN bits are enabled, div\_factor = 512*32 = 16384

In case, RTC wakeup's are used as a wakeup source, bus clock (system clock or register interface clock of RTC) should be disabled (to save power in standby mode) after enabling the required wakeup and ensuring sufficient time gap (3-6 bus clock or RTC clock (rtc\_clock) cycles, whichever is slower) between bus clock disabling and wakeup event. To ensure writing the register to enable the wakeup, the bus clock must be active, hence it should not be disabled before enabling wakeup. Correct operation is not guaranteed if the specification is not followed.

## 44.3.2 API functional description

Setting APIEN bit enables the autonomous interrupt function. The 32-bit APIVAL field selects the time interval for triggering an interrupt and/or wakeup event. Because the RTC is a free-running counter, the APIVAL is added to the current count to calculate an offset. When the counter reaches the offset count, an interrupt and/or wakeup request is generated. Then the offset value is recalculated and again re-triggers a new request when the new value is reached. API function is enabled only when CNTEN and APIEN bits are asserted and APIVAL is non-zero. Also APIVAL can be updated anytime. After APIVAL is updated, the first API interrupt is generated according to the previous value. From the second interrupt onwards, the API interrupt is generated with the new APIVAL. When a compare is reached, the APIF interrupt flag bit is set (after proper clock synchronization). If the APIIE

Real Time Clock (RTC)

## NOTE

Address offset - 0x18h should not be accessed by application as corresponding feature/s are not available. Therefore, transfer error will not be generated at this offset.

## NOTE

XFR error will be generated when RTCSUPV is accessed in user mode, any other register is accessed in user mode when SUPV bit is set, write attempt is made for RTCCNT register and any register accessed out of address range.

## 44.4.1 RTC memory map

RTC base address: 4006\_0000h

| Offset   | Register                                  |   Width (In bits) | Access   | Reset value   |
|----------|-------------------------------------------|-------------------|----------|---------------|
| 0h       | RTC Supervisor control register (RTCSUPV) |                32 | RW       | 8000_0000h    |
| 4h       | RTC Control register (RTCC)               |                32 | RW       | 0000_0000h    |
| 8h       | RTC Status register (RTCS)                |                32 | RW       | 0000_0000h    |
| Ch       | RTC Counter register (RTCCNT)             |                32 | R        | 0000_0000h    |
| 10h      | API Compare value register (APIVAL)       |                32 | RW       | 0000_0000h    |
| 14h      | RTC Compare value register (RTCVAL)       |                32 | RW       | 0000_0000h    |

Real Time Clock (RTC)

interrupt enable bit is set, then the API interrupt request is generated. If there is a match while being in the low-power mode, then the API first generates a wakeup request to force a wakeup into normal operation, and then the APIF flag is set.

When the CNTEN is de-asserted, the API function is reset , though wakeup API is not asynchronously de-asserted with CNTEN. If APIEN is disabled when counter matches the offset APIF can be missed.

## 44.3.3 Modes of operation

## 44.3.3.1 Functional mode

There are two functional modes of operation for RTC, normal operation and low-power mode. In normal operation, all RTC registers can be read or written . The RTC/API and associated interrupts are optionally enabled. In low-power mode, the bus interface is disabled. The RTC/API is enabled (if enabled prior to entry into low-power mode).

## 44.3.3.2 Debug mode

On entering into the debug mode, the RTC counter freezes on the last valid count if the FRZEN is set. On exit from debug mode, counter continues from the frozen value.

## 44.4 RTC register descriptions

The RTC registers are listed in this section.

## 44.4.2 RTC Supervisor control register (RTCSUPV)

## Offset

| Register   | Offset   |
|------------|----------|
| RTCSUPV    | 0h       |

## Function

The RTCSUPV register contains the SUPV bit that determines whether other registers are accessible in supervisor mode or user mode.

<!-- image -->

## Fields

| Field   | Function                                                                                                                                      |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| 31      | RTC Supervisor Bit                                                                                                                            |
| SUPV    | 0b - All registers are accessible in both user as well as supervisor mode 1b - All other registers are accessible in the supervisor mode only |
| 30-0 -  | Reserved                                                                                                                                      |

## 44.4.3 RTC Control register (RTCC)

## Offset

| Register   | Offset   |
|------------|----------|
| RTCC       | 4h       |

Real Time Clock (RTC)

## Diagram

<!-- image -->

| Bits    | 31     | 30    | 29     | 28      | 27        | 26       |   25 |   24 |   23 |   22 |   21 |   20 |   19 |   18 |   17 | 16        |
|---------|--------|-------|--------|---------|-----------|----------|------|------|------|------|------|------|------|------|------|-----------|
| R       | CNTE N | RTCIE | FRZE N | ROVR EN | 0         | 0        |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | 0         |
| W Reset | 0      | 0     | 0      | 0       | 0         | 0        |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | 0         |
| Bits    | 15     | 14    | 13     | 12      | 11        | 10       |    9 |    8 |    7 |    6 |    5 |    4 |    3 |    2 |    1 | 0         |
| R W     | APIEN  | APIIE | CLKSEL | CLKSEL  | DIV51 2EN | DIV32 EN |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | Reserv ed |
| Reset   | 0      | 0     | 0      | 0       | 0         | 0        |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | 0         |

## Fields

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                       |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 CNTEN  | Counter Enable TheCNTENbitenablestheRTCcounter.Setting CNTENbitto0bhastheeffect of asynchronously resetting (synchronous reset negation) all the RTC and API logic. This allows RTC configuration and clock source selection to be updated without causing synchronization issues. CNTEN should be disabled when INV_RTC, INV_API are cleared. NOTE 0b - Counter disabled 1b - Counter enabled |
| 30 RTCIE  | RTC Interrupt Enable The RTCIE bit enables interrupts requests to the system if RTCF is asserted. 0b - RTC interrupts disabled 1b - RTC interrupts enabled                                                                                                                                                                                                                                     |
| 29 FRZEN  | Freeze Enable Bit The counter freezes on entering the debug mode on the last valid count value if the FRZEN bit is set. After passing of the debug modecounter starts from the frozen value. This bit should notbechangedwhendebug mode is enabled. 0b - Counter does not freeze in debug mode 1b - Counter freezes in debug mode                                                              |
| 28 ROVREN | Counter Roll Over Interrupt Enable The ROVREN bit enables interrupt requests when the RTC has rolled over from 0xFFFF_FFFF to 0x0000_0000. The RTCIE bit must also be set in order to generate an interrupt from a counter rollover. 0b - RTC rollover interrupt disabled 1b - RTC rollover interrupt enabled                                                                                  |

Table continues on the next page...

Real Time Clock (RTC)

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                              |
|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 27-16 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                              |
| 15 APIEN     | Autonomous Periodic Interrupt Enable The APIEN bit enables the autonomous periodic interrupt function. Setting this bit to 0b, asynchronously disables API wakeup output of RTC as well. 0b - API disabled 1b - API enabled                                                                                                                                                           |
| 14 APIIE     | API Interrupt Enable The APIIE bit enables interrupts requests to the system if APIF is asserted. 0b - API interrupts disabled 1b - API interrupts enabled                                                                                                                                                                                                                            |
| 13-12 CLKSEL | Clock select The CLKSEL[1:0] bits select the clock source for the RTC. CLKSEL may only be updated when CNTEN is 0. The user should ensure that oscillator is enabled before selecting it as a clock source for RTC. Refer the RTC clocking section in the Clocking chapter of this document. NOTE 00b - Clock source 0 01b - Clock source 1 10b - Clock source 2 11b - Clock source 3 |
| 11 DIV512EN  | Divide by 512 enable The DIV512EN bit enables the 512 clock divider. DIV512EN may only be updated when CNTEN is 0. 0b - Divide by 512 is disabled 1b - Divide by 512 is enabled                                                                                                                                                                                                       |
| 10 DIV32EN   | Divide by 32 enable The DIV32EN bit enables the 32 clock divider. DIV32EN may only be updated when CNTEN is 0. 0b - Divide by 32 is disabled 1b - Divide by 32 is enabled                                                                                                                                                                                                             |
| 9-1 -        | Reserved                                                                                                                                                                                                                                                                                                                                                                              |
| 0 -          | Reserved                                                                                                                                                                                                                                                                                                                                                                              |

## 44.4.4 RTC Status register (RTCS)

## Offset

| Register   | Offset   |
|------------|----------|
| RTCS       | 8h       |

## Function

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26     | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18       | 17       | 16        |
|--------|------|------|------|------|------|--------|------|------|------|------|------|------|------|----------|----------|-----------|
| R      | 0    |      | RTCF |      |      |        |      |      |      |      |      |      |      | INV_ RTC | INV_ API | Reserv ed |
|        | W    |      | W1C  |      |      |        |      |      |      |      |      |      |      |          |          |           |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0        | 0        | 0         |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10     | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2        | 1        | 0         |
| R      | 0    |      | APIF | 0    |      | ROVR F | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0        | 0        | 0         |
| W      |      |      | W1C  |      |      | W1C    |      |      |      |      |      |      |      |          |          |           |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0        | 0        | 0         |

## Fields

| Field      | Function                                                                                                                                                                                                                                                                                      |
|------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-30 -    | Reserved                                                                                                                                                                                                                                                                                      |
| 29 RTCF    | RTC Interrupt Flag The RTCF bit indicates that the RTC counter has reached the counter value matching RTC Compare value register (RTCVAL). RTCF is cleared by writing a 1 to RTCF. Writing a 0 to RTCF has no effect. 0b - RTC counter is not equal to RTCVAL 1b - RTC counter matches RTCVAL |
| 28-19 -    | Reserved                                                                                                                                                                                                                                                                                      |
| 18 INV_RTC | Invalid RTC write                                                                                                                                                                                                                                                                             |

Table continues on the next page...

## NOTE

W1C has priority over setting of the RTCF, APIF and ROVRF bits, in case both clearing and setting occurs at the same time.

Real Time Clock (RTC)

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                              |
|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | This bit returns value 1 after a value is written to the RTCVAL register and the synchronization process is in progress. During this synchronization period, any attempt to write to the RTCVAL register again is ignored. Synchronization will complete only when CNTEN is set.                      |
| 17 INV_API | Invalid APIVAL write This bit returns value 1 after a value is written to the APIVAL register and the synchronization process is in progress. During this synchronization period, any attempt to write to the APIVAL register again is ignored. Synchronization will complete only when CNTEN is set. |
| 16 -       | Reserved                                                                                                                                                                                                                                                                                              |
| 15-14 -    | Reserved                                                                                                                                                                                                                                                                                              |
| 13 APIF    | API Interrupt Flag The APIF bit indicates that the RTCcounter has reached the counter value matching API offset value. APIF is cleared by writing a 1 to APIF. Writing a 0 to APIF has no effect. 0b - Counter is not equal to API offset value 1b - Counter matches the API offset value             |
| 12-11 -    | Reserved                                                                                                                                                                                                                                                                                              |
| 10 ROVRF   | Counter Roll Over Interrupt Flag The ROVRF bit indicates that the RTC has rolled over from 0xFFFF_FFFF to 0x0000_0000. ROVRF is cleared by writing a 1 to ROVRF. 0b - RTC has not rolled over 1b - RTC has rolled over                                                                                |
| 9-0 -      | Reserved                                                                                                                                                                                                                                                                                              |

## 44.4.5 RTC Counter register (RTCCNT)

## Offset

| Register   | Offset   |
|------------|----------|
| RTCCNT     | Ch       |

## Diagram

<!-- image -->

| Bits   | 31     | 30     | 29     | 28     | 27     | 26     | 25     | 24     | 23     | 22     | 21     | 20     | 19     | 18     | 17     | 16     |
|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
| R      | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT |
| W      |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |
| Reset  | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      |
| Bits   | 15     | 14     | 13     | 12     | 11     | 10     | 9      | 8      | 7      | 6      | 5      | 4      | 3      | 2      | 1      | 0      |
| R      | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT | RTCCNT |
| W      |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |
| Reset  | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      |

## Fields

| Field   | Function                                                                                   |
|---------|--------------------------------------------------------------------------------------------|
| 31-0    | RTC Counter Value                                                                          |
| RTCCNT  | Because of clock synchronization, the RTCCNT value may represent a previous counter value. |

## 44.4.6 API Compare value register (APIVAL)

## Offset

| Register   | Offset   |
|------------|----------|
| APIVAL     | 10h      |

## Function

The APIVAL offset bits are compared to the RTC counter bits and if a match occurs, an interrupt/wakeup request is asserted.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24     | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|--------|------|------|------|------|------|------|------|------|
| R W    |      |      |      |      |      |      |      | APIVAL |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8      | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R W    |      |      |      |      |      |      |      | APIVAL |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

Real Time Clock (RTC)

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | API Compare Value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| APIVAL  | APIVAL bits are added to the current count to calculate an offset. The APIVAL offset bits are compared to the RTC counter bits and if a match occurs, an interrupt/wakeup request is asserted. API functionality is active only when APIVAL is non zero. The first API interrupt takes two more cycles because of synchronization of APIVAL to RTC clock. After that, interrupts are periodic in nature and it takes APIVAL+1 cycles. The Minimum supported value of APIVAL is 4. This is because of synchronization. NOTE |

## 44.4.7 RTC Compare value register (RTCVAL)

## Offset

| Register   | Offset   |
|------------|----------|
| RTCVAL     | 14h      |

## Function

The RTCVAL bits are compared to the RTC counter bits and if a match occurs, RTCF is set. The minimum value of RTCVAL should be 4.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24     | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|--------|------|------|------|------|------|------|------|------|
| R W    |      |      |      |      |      |      |      | RTCVAL |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8      | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R W    |      |      |      |      |      |      |      | RTCVAL |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                 |
|---------|------------------------------------------------------------------------------------------|
| 31-0    | RTC Compare Value                                                                        |
| RTCVAL  | The RTCVAL bits are compared to the RTC counter bits and if a match occurs, RTCF is set. |

Real Time Clock (RTC)

## 44.5 Initialization

Recommended programming flow as follow

1. Program RTCVAL register with the value greater than 4 if RTCF related functionality is required.
2. Program APIVAL register with the value greater than 4 if API functionality is required.
3. Program all fields (as required) of RTC Control register (RTCC) register with CNTEN=1. After setting CNTEN field, counter starts running and RTC/API functionality will be active as per the configurations.
4. If RTCVAL or APIVAL needs to be updated during run, check corresponding INV\_RTC or INV\_API bit is cleared before writing and do meet all the restrictions of the corresponding register.
5. If CLKSEL or DIV32EN or DIV512EN needs to be updated, first update RTC Control register (RTCC) register with CNTEN=0 (when all INV\_RTC or INV\_API are 0) keeping other field values same. Wait for minimum 3 RTC clock cycles so that CNTEN will be synchronized to RTC clock domain. Then write the RTC Control register (RTCC) register with new configuration required with CNTEN=1.

Real Time Clock (RTC)

## Chapter 45 Inter-Integrated Circuit (I2C)

## 45.1 Overview

This chapter describes the Inter-Integrated Circuit (I 2 C) module implemented on this chip and presents the following topics:

- Introduction to I 2 C
- External signal descriptions
- I2C register descriptions
- Functional description
- Initialization/application information

## 45.2 Introduction to I 2 C

This section presents the following topics:

- Definition: I 2 C module
- Module block diagram
- Features
- Modes of operation
- Definition: I 2 C conditions

## 45.2.1 Definition: I 2 C module

The I 2 C module is a functional unit that provides a two-wire-serial data (SDA) and serial clock (SCL)-bidirectional serial bus. This bus provides a simple and efficient method of data exchange between this chip and other devices, such as microcontrollers, EEPROMs, real-time clock devices, analog-to-digital converters, and LCDs.

## 45.2.2 Module block diagram

<!-- image -->

## 45.2.3 Features

The I 2 C module has the following key features:

- Compatible with I 2 C bus standard [2]
- Operating speeds
- Up to 100 kbps in the Standard Mode defined by the I 2 C protocol specification
- Up to 400 kbps in the Fast Mode defined by the I 2 C protocol specification
- Actual baud rate dependent on the SCL rise time (which depends on external pullup resistor values and bus loading)
- Multi-master operation
- Software-programmable for one of 256 different serial clock frequencies
- Software-selectable acknowledge bit
- Interrupt-driven byte-by-byte data transfer
- Arbitration lost interrupt with automatic mode switching from master to slave
- Calling address identification interrupt
- Start and stop signal generation/detection
- Repeated start signal generation
- Acknowledge bit generation/detection
- Bus busy detection
- DMA interface

[2] Compliant with I 2 C 2.0 standard with the exception that HS (high speed) mode is not supported

## 45.2.4 Limitations

Operation up to 1 Mbps in the Fast Mode Plus mode (defined by the I 2 C protocol specification) is not supported.

## 45.2.5 Modes of operation

The I 2 C module supports the chip modes described in Table 292.

Table 292. Chip modes supported by the I 2 C module

| Chip mode   | Description                                                                                                                          | Important notes   |
|-------------|--------------------------------------------------------------------------------------------------------------------------------------|-------------------|
| RUN         | Basic mode of operation                                                                                                              | -                 |
| DEBUG       | Allows the chip to freeze all ongoing activities (such as an ongoing transaction, counter values, and register status) for debugging | See DEBUG mode.   |

In addition to chip modes, the I 2 C module has several module-specific modes. These are described in Table 293.

Table 293. Module-specific modes supported by the I 2 C module

| Module mode   | Description                                         | Important notes                                                                                                                                     |
|---------------|-----------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| Master mode   | The I 2 C module is the driver of the SDA line.     |  Do not use the I 2 Cmodule's slave address as a calling address.  The I 2 C module cannot be a master and a slave simultaneously.                |
| Slave mode    | The I 2 C module is not the driver of the SDA line. |  Enable the I 2 C module before a START condition from a non-I 2 C master is detected.  By default the I 2 C module performs as a slave receiver. |

## 45.2.6 Definition: I 2 C conditions

The following table shows the I 2 C-specific conditions defined for the I 2 C module.

Table 294. I 2 C conditions

| Condition      | Description                                                                                                                                                                                                                                    |
|----------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| START          | A condition that denotes the beginning of a new data transfer and awakens all slaves. Each data transfer contains several bytes of data. It is defined as a high-to-low transition of SDA while SCL is high, as shown in the following figure. |
| STOP           | A condition generated by the master to terminate a transfer and free the bus. It is defined as a low-to-high transition of SDA while SCL is high, as shown in the following figure.                                                            |
| Repeated START | A START condition that is generated without a STOP condition to terminate the previous transfer.                                                                                                                                               |

Inter-Integrated Circuit (I2C)

<!-- image -->

## 45.3 External signal descriptions

This section presents the following topics:

- Signal overview
- Detailed external signal descriptions

## 45.3.1 Signal overview

The I 2 C module uses the Serial Data (SDA) and Serial Clock (SCL) signals as a communication interconnect with other devices. The signal patterns driven on the SDA signal represent address, data, or read/write information at different stages of the protocol.

All devices connected to the SDA and SCL signals must have open-drain or open-collector outputs. The I 2 C bus connects the SDA lines of all devices together, thus performing a logical AND of the SDA signals. Similarly, the I 2 C bus connects all the SCL lines together, thus performing a logical AND of the SCL signals. The combined SDA and SCL lines also connect to their respective pullup resistors. For the electrical characteristics of these signals, see the data sheet for this chip.

## 45.3.2 Detailed external signal descriptions

The SDA and SCL signals are described in the following table.

## Table 295. External signal descriptions

| Signal   | Description                                                                                |
|----------|--------------------------------------------------------------------------------------------|
| SCL      | Bidirectional serial clock line of the module, compatible with the I 2 C bus specification |
| SDA      | Bidirectional serial data line of the module, compatible with the I 2 C bus specification  |

## 45.4 I2C register descriptions

The memory map for the I 2 C module is given below. The total address for each register is the sum of the base address for the I 2 C module and the address offset for each register.

Address location 0x0007 is a reserved location, but access to this location will not generate any bus error.

All registers are accessible via 8-bit, 16-bit, or 32-bit accesses. However, 16-bit accesses must align to 16-bit boundaries, and 32-bit accesses must align to 32-bit boundaries.

As an example, the IBFD is at address offset 0x01, and you can access it in any of the following ways:

- 8-bit R/W access of address offset 0x0001
- Second byte of 16-bit R/W access of address offset 0x0000
- Second byte of 32-bit R/W access of address offset 0x0000

You cannot access the IBFD register by a 16- or 32-bit RW operation at address offset 0x0001 because those operations require an address aligned to a 16- or 32-bit boundary.

## 45.4.1 I2C memory map

- I2C\_0 base address: 401E\_4000h

- I2C\_1 base address: 401E\_8000h

- I2C\_2 base address: 401E\_C000h

- I2C\_3 base address: 402D\_8000h

- I2C\_4 base address: 402D\_C000h

| Offset   | Register                               |   Width (In bits) | Access   | Reset value   |
|----------|----------------------------------------|-------------------|----------|---------------|
| 0h       | I2C Bus Address (IBAD)                 |                 8 | RW       | 00h           |
| 1h       | I2C Bus Frequency Divider (IBFD)       |                 8 | RW       | 00h           |
| 2h       | I2C Bus Control (IBCR)                 |                 8 | RW       | 80h           |
| 3h       | I2C Bus Status (IBSR)                  |                 8 | RW       | 80h           |
| 4h       | I2C Bus Data I/O (IBDR)                |                 8 | RW       | 00h           |
| 5h       | I2C Bus Interrupt Configuration (IBIC) |                 8 | RW       | 00h           |
| 6h       | I2C Bus Debug (IBDBG)                  |                 8 | RW       | 00h           |

## 45.4.2 I2C Bus Address (IBAD)

## Offset

| Register   | Offset   |
|------------|----------|
| IBAD       | 0h       |

## Function

Contains the address that the I 2 C bus responds to when addressed as a slave. This is not the address sent on the bus during the address transfer.

Access: Supervisor mode only (the module ignores user mode accesses and does not assert an error response if you access this register in user mode)

Inter-Integrated Circuit (I2C)

## Diagram

<!-- image -->

| Bits   | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
|--------|-----|-----|-----|-----|-----|-----|-----|-----|
| R      |     |     |     |     |     |     |     | 0   |
| W      |     |     |     | ADR |     |     |     |     |
| Reset  | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

## Fields

| Field   | Function                                                      |
|---------|---------------------------------------------------------------|
| 7-1     | Slave Address                                                 |
| ADR     | Specifies the slave address for the I 2 C module to use. NOTE |
| 0       | Reserved                                                      |

## 45.4.3 I2C Bus Frequency Divider (IBFD)

## Offset

| Register   | Offset   |
|------------|----------|
| IBFD       | 1h       |

## Function

Access: Supervisor mode only (the module ignores user mode accesses and does not assert an error response if you access this register in user mode)

## Diagram

<!-- image -->

| Bits    | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
|---------|-----|-----|-----|-----|-----|-----|-----|-----|
| R       |     |     |     | IBC |     |     |     |     |
| W Reset | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

## Fields

| Field   | Function                                                                          |
|---------|-----------------------------------------------------------------------------------|
| 7-0     | I-Bus Clock Rate                                                                  |
| IBC     | Prescales the bus clock for bit rate selection. See Clock rate and IBFD settings. |

Inter-Integrated Circuit (I2C)

## 45.4.4 I2C Bus Control (IBCR)

## Offset

| Register   | Offset   |
|------------|----------|
| IBCR       | 2h       |

## Function

Access: Supervisor mode only (the module ignores user mode accesses and does not assert an error response if you access this register in user mode)

## Diagram

<!-- image -->

| Bits   | 7    | 6    | 5    | 4    | 3     | 2    | 1     | 0        |
|--------|------|------|------|------|-------|------|-------|----------|
| R      | MDIS | IBIE | MSSL | TXRX | NOACK | 0    | DMAEN | Reserved |
| W      | MDIS | IBIE | MSSL | TXRX | NOACK | RSTA | DMAEN | Reserved |
| Reset  | 1    | 0    | 0    | 0    | 0     | 0    | 0     | 0        |

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 7 MDIS  | Module Disable Controls the software reset of the entire I 2 C module. If the I 2 C module is enabled in the middle of a byte transfer, the interface behaves as follows: slave mode ignores the current transfer on the bus and starts operating whenever a subsequent START condition is detected. Master mode will not be aware that the bus is busy, hence if a start cycle is initiated, the current bus cycle may become corrupt. This ultimately results in either the current bus master or the I 2 C module losing arbitration, after which bus operation returns to normal. NOTE 0b - The module is enabled. You must clear this field before any other IBCR fields have any effect. 1b - The module is reset and disabled. This is the power-on reset situation. When high, the interface is held in reset, but registers can still be accessed. Status register fields (IBSR) are not valid when the module is disabled. |
| 6 IBIE  | Bus Interrupt Enable 0b - Interrupts from I2C are disabled. This does not clear any currently pending interrupt condition. 1b - Interrupts from I2C are enabled. An I2C interrupt occurs if IBSR[IBIF]=1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 5 MSSL  | Master/Slave Mode Select Specifies the mode.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | When you change this field from 0 to 1, the module generates a START signal on the bus and selects the master mode. Whenyouchangethis field from 1 to 0, the module generates a STOPsignal and changes the operation modefrom master to slave. You should generate a STOPsignal only if IBSR[IBIF]=1. The module clears this field without generating a STOP signal when the master loses arbitration. 0b - Slave 1b - Master                                                                                                                                  |
| 4 TXRX  | Transmit/Receive Mode Select Specifies the direction of master and slave transfers. When the I 2 C module is addressed as a slave, your software must program this field based on IBSR[SRW]:  When IBSR[SRW]=0, program TXRX=0.  When IBSR[SRW]=1, program TXRX=1. In master mode, your software must program this field according to the type of transfer required. Therefore, for address cycles, this field will always be 1. 0b - Receive 1b - Transmit                                                                                                  |
| 3 NOACK | Data Acknowledge Disable Specifies the value driven onto SDA during data acknowledge cycles for both master and slave receivers. When the I 2 C module is enabled, it always acknowledges address matches, regardless of the value of NOACK. Values written to this field are only used whenthe I 2 Cmoduleis a receiver, not a transmitter. NOTE 0b - Send an acknowledge signal to the bus at the 9th clock bit after receiving one byte of data                                                                                                             |
| 2 RSTA  | Repeat START Generates repeated START. If the I 2 C module is the current bus master, and you write 1 to RSTA, the I 2 C module generates a repeated START condition. This field always reads as a 0. If you attempt a repeated START at the wrong time-if the bus is owned by another master-the result is loss of arbitration. 0b - No effect 1b - Generate repeated START condition                                                                                                                                                                         |
| 1 DMAEN | DMA Enable When this field is 1, and the I 2 C module requires data to be read or written to I2C Bus Data I/O (IBDR), the module asserts the DMATxand Rx lines. When DMAEN=1, the I 2 Cmodule does not generate an interrupt after the transfer of a byte is complete (that is, when the I 2 Cmodule detects the falling edge of the 9th clock cycle). However, the module generates an interrupt if arbitration is lost or the module is addressed as a slave. The DMAmodeisonlyvalid whenthe I 2 Cmoduleis configured as a master, and the DMAtransfer still |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                         |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | requires CPU intervention at the start and the end of each frame of data. See DMA application information for more details. 0b - Disable the DMA TX/RX request signals 1b - Enable the DMA TX/RX request signals |
| 0       | Reserved                                                                                                                                                                                                         |
| -       | Although this field supports read/write access, writing to this field is not required, and can produce unexpected results.                                                                                       |

## 45.4.5 I2C Bus Status (IBSR)

## Offset

| Register   | Offset   |
|------------|----------|
| IBSR       | 3h       |

## Function

Access: Supervisor mode only (the module ignores user mode accesses and does not assert an error response if you access this register in user mode)

## Diagram

| Bits   | 7   | 6    | 5   | 4    | 3   | 2   | 1    | 0    |
|--------|-----|------|-----|------|-----|-----|------|------|
| R      | TCF | IAAS | IBB | IBAL | 0   | SRW | IBIF | RXAK |
| W      |     |      |     | W1C  |     |     | W1C  |      |
| Reset  | 1   | 0    | 0   | 0    | 0   | 0   | 0    | 0    |

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                       |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 7       | Transfer Complete                                                                                                                                                                                                                                                                                                                                                              |
| TCF     | Indicates the status of a transfer. The I 2 Cmodule programs this field to 0 during the time that the module transfers one byte of data. After the I 2 C module detects the falling edge of the 9th clock of a byte transfer, the module programs this field to 1. This field is relevant to you only during or immediately after a transfer to or from the I 2 C module. NOTE |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 6 IAAS  | 1b - Complete Addressed As A Slave When its own specific address (I-Bus Address Register) is matched with the calling address, this field is set. The CPU is interrupted if IBCR[IBIE]=1. Then the CPU needs to check SRW and set the TXRX field accordingly. Writing to the I-Bus Control Register clears IAAS. 0b - Not addressed                                                                                                                                                                                                                                                                                      |
| 5 IBB   | Bus Busy Indicates the status of the bus. When a START signal is detected, IBB is set. If a STOP signal is detected, IBB is cleared and the bus enters idle state. Software must ensure that the I 2 C bus is idle by checking the IBSR[IBB] field (bus busy) before switching to master mode and attempting a START cycle. NOTE 0b - Idle                                                                                                                                                                                                                                                                               |
| 4 IBAL  | Arbitration Lost The I 2 C module changes IBAL to 1 when the arbitration procedure is lost. Arbitration is lost in the following circumstances:  SDA is sampled low when the master drives a high during an address or data transmit cycle.  SDA is sampled low when the master drives a high during the acknowledge bit of a data receive cycle.  A start cycle is attempted when the bus is busy.  A repeated start cycle is requested in slave mode.  A stop condition is detected when the master did not request it. You must return this field to zero by writing a one to it. A write of zero has no effect. |
| 3 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 2 SRW   | Slave Read/Write WhenIAAS=1,SRWindicatesthevalueoftheR/Wcommandbitofthecallingaddresssent from the master. SRW is valid only when all of these are true:  The I-Bus is in slave mode.  A complete address transfer has occurred with an address match.                                                                                                                                                                                                                                                                                                                                                                 |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         |  No other transfers have been initiated. By reading this field, the CPU can detect slave transmit/receive mode according to the command of the master. 0b - Slave receive, master writing to slave 1b - Slave transmit, master reading from slave                                                                                                                                                                                                                                                                                                                         |
| 1 IBIF  | Bus Interrupt Flag IBIF=1 when one of the following conditions occurs:  Arbitration lost (IBAL=1)  Byte transfer complete (TCF=1 and DMAEN=0)  Addressed as slave (IAAS=1)  NoAck from Slave (MS and Tx bits set)  I 2 C Bus going idle (IBB high-low transition and enabled by BIIE) A processor interrupt request will be caused if IBIE=1. Your software must clear IBIF by writing a one to it. A write of zero has no effect. In DMA mode (DMAEN set) a byte transfer complete condition will not trigger the setting of IBIF. All other conditions still apply. |
| 0 RXAK  | Received Acknowledge Indicates the value of SDA during the acknowledge bit of a bus cycle. If RXAK = 0, it indicates an acknowledge signal has been received after the completion of eight bits of data transmission on the bus. If RXAK = 1, it means no acknowledge signal is detected at the ninth clock. RXAK is valid only after transfer is complete. 0b - Acknowledge received 1b - No acknowledge received                                                                                                                                                         |

## 45.4.6 I2C Bus Data I/O (IBDR)

## Offset

| Register   | Offset   |
|------------|----------|
| IBDR       | 4h       |

## Function

In master transmit mode, when your software writes to IBDR, the I 2 C module initiates a data transfer. The module sends the most significant bit first.

In master receive mode, when your software reads IBDR, the I 2 C module initiates the reception of the next data byte.

In slave mode, the same functions are available after an address match has occurred.

## NOTE

The IBCR[TXRX] field must correctly reflect the desired direction of transfer in master and slave modes for the transmission to begin. For instance, if the I 2 C is configured for master transmit but a master receive is desired, then reading the IBDR will not initiate the receive.

When the the I 2 C module is configured for master-receive or slave-receive modes, and your software reads IBDR, the I 2 C module returns the most-recent byte received. The IBDR does not reflect every byte transmitted on the I 2 C bus. Your software also cannot verify that it wrote a byte to IBDR correctly by reading the byte back.

In master transmit mode, the I 2 C module takes the first byte of data written to IBDR after assertion of MSSL and uses this byte for the address transfer. This byte must comprise the calling address (in position DATA[7:1]) concatenated with the required R/W\_b bit (in position D0). (In the I 2 C bus specification, the R/W\_b bit is presented as R/W with an overbar on the W.)

Access: Supervisor mode only (the module ignores user mode accesses and does not assert an error response if you access this register in user mode)

## Diagram

<!-- image -->

| Bits   | 7   | 6   | 5   | 4    | 3   | 2   | 1   |    | 0   |
|--------|-----|-----|-----|------|-----|-----|-----|----|-----|
| R W    |     |     |     | DATA |     |     |     |    |     |
| Reset  | 0   | 0   | 0   | 0    | 0   | 0   |     | 0  | 0   |

## Fields

| Field   | Function                     |
|---------|------------------------------|
| 7-0     | Data transmitted or received |
| DATA    |                              |

## 45.4.7 I2C Bus Interrupt Configuration (IBIC)

## Offset

| Register   | Offset   |
|------------|----------|
| IBIC       | 5h       |

## Function

To program BIIE = 1, you must ensure that IBCR[MDIS] = 0.

Access: Supervisor mode only (the module ignores user mode accesses and does not assert an error response if you access this register in user mode)

Inter-Integrated Circuit (I2C)

## Diagram

<!-- image -->

## Fields

| Field      | Function                                                                                                                                                                                                                                                                                                                    |
|------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 7 BIIE     | Bus Idle Interrupt Enable Allows you to generate an interrupt after the I 2 C bus becomes idle. After BIIE=1, a high-to-low transition of IBSR[IBB] results in IBSR[IBIF]=1. You can use this feature to inform the CPU about the completion of a STOP on the I 2 C bus. 0b - Disable 1b - Enable                           |
| 6 BYTERXIE | Byte Receive Interrupt Enable Allows you to generate an interrupt every time the I 2 C master/slave receives a new byte. This feature can be useful when an I 2 C master receives data from a slave that transmits on an irregular basis. The I 2 C module updates BYTERXIE only when the module is enabled (IBCR[MDIS]=0). |
| 5-0 -      | Reserved                                                                                                                                                                                                                                                                                                                    |

## 45.4.8 I2C Bus Debug (IBDBG)

## Offset

| Register   | Offset   |
|------------|----------|
| IBDBG      | 6h       |

## Function

Access: Supervisor mode only (the module ignores user mode accesses and does not assert an error response if you access this register in user mode)

Inter-Integrated Circuit (I2C)

## Diagram

| Bits    |   7 | 6   | 5   | 4   | 3        | 2       | 1          | 0          |
|---------|-----|-----|-----|-----|----------|---------|------------|------------|
| R       |   0 |     |     |     | GLFLT_EN | BYTE_RX | IPG_DEB... | IPG_DEB... |
| W Reset |   0 | 0   | 0   | 0   | 0        | W1C 0   | 0          | 0          |

## Fields

| Field               | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|---------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 7-4 -               | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 3 GLFLT_EN          | Glitch Filter Enable Filters out any glitch on the SCLor SDAline that maycause the I 2 Cmodule to enter an unrecoverable state. When GLFLT_EN = 1, the effect of the SCL and SDA lines is delayed by six IPG clock cycles. So, in cases where a glitch is not expected at the SCLor SDAinputs, you should not program GLFLT_EN = 1. NOTE 0b - The I2C module allows all pulses on the SCL or SDA input lines to pass through. 1b - The I2C module filters out any pulse (rising or falling) on the SCL or SDA input line that is shorter than six IPG clock cycles. |
| 2 BYTE_RX           | Byte Receive I 2 C programs BYTE_RX=1 when an I 2 C master/slave receives a new byte. The module generates an interrupt if IBIC[BYTERXIE]=1.                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 1 IPG_DEBUG_H ALTED | Debug Halted Informs you whether I 2 C is still executing a transaction or has entered DEBUG mode. This is a status field that you can read back after asserting the debug enable signal. 0b - Still executing a transaction 1b - Entered DEBUG mode                                                                                                                                                                                                                                                                                                                |
| 0 IPG_DEBUG_E N     | Debug Enable Controls I 2 C's entry into DEBUGmodewhentheIPGDEBUGsignalishigh.All the registers, counter values and status bits are frozen and can be accessed by the CPU. If your software programs IPG_DEBUG_EN=1, and the IPG DEBUG signal becomes high in the middle of a transaction, the I 2 C module enters DEBUG mode only after successfully completing the current transaction, after which nofurther transactions can occur until the I 2 C module exits DEBUG mode. NOTE 0b - Normal operation; the bus idle interrupts are disabled 1b - In DEBUG mode |

Inter-Integrated Circuit (I2C)

## 45.5 Functional description

This section presents the following topics:

- Notes about module operation
- Transactions
- Arbitration procedure
- Clock behavior
- Interrupts
- DEBUG mode
- DMA interface

## 45.5.1 Notes about module operation

- The I 2 C module always performs as a slave receiver by default, unless explicitly programmed to be a master or slave transmitter.
- When the I 2 C module is acting as a master, it must not try to call its own slave address.

## 45.5.2 Transactions

This section presents the following topics:

- Protocol overview
- Transaction protocol definitions
- High-level protocol steps
- START condition
- Slave address transmission
- Data transmission
- STOP condition
- Repeated START condition

## 45.5.2.1 Protocol overview

The following figure shows the behavior of SCL and SDA during a typical I 2 C transaction.

Inter-Integrated Circuit (I2C)

Inter-Integrated Circuit (I2C)

<!-- image -->

## 45.5.2.2 Transaction protocol definitions

This section defines several important terms presented in Figure 377.

Table 296. I 2 C definitions

| Term                    | Definition                                                                                                                                                                                                                        |
|-------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| START                   | A START condition, as defined in Definition: I 2 C conditions                                                                                                                                                                     |
| STOP                    | A STOP condition, as defined in Definition: I 2 C conditions                                                                                                                                                                      |
| Calling (slave) address | A seven-bit address used to identify a slave on the I 2 C bus (see I 2 C calling address requirements for the requirements for specifying this address)                                                                           |
| Read/write (R/W)        | A bit that specifies the direction of the data transfer to the slave as follows:  0=The data is being transferred from the master to the slave ("write")  1=The data is being transferred from the slave to the master ("read") |
| Ack                     | A bit that specifies the acknowledgement of a calling address, indicated by pulling SDA low                                                                                                                                       |

## 45.5.2.3 I 2 C calling address requirements

The calling addresses of the devices used on an I 2 C network are subject to the following requirements:

- Each slave must have a unique calling address.
- A master must not transmit a calling address that is the same as its own slave address.

## 45.5.2.4 High-level protocol steps

The I 2 C protocol conceptually supports two types of transfers, as illustrated in Figure 377. The significant steps in these transfers are presented in the following table. Details of each of these steps are presented in subsequent sections.

## Table 297. I 2 C high-level protocol steps

| Standard transfer                                                                                                                                             | Repeated START transfer                                                                                                                                                                                                   |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1. START condition 2. Slave target or general call address transmission 3. Acknowledgment from slave 4. Data transfer 5. STOP condition 6. (repeat Steps 1-4) | 1. START condition 2. Slave target or general call address transmission 3. Acknowledgment from slave 4. Data transfer 5. Repeated START condition 6. (repeat Steps 2-4 as needed) 7. STOP condition 8. (repeat Steps 1-7) |

## 45.5.2.5 START condition

When the bus is free (no master device engages the bus; both SCL and SDA lines are at logical high), a master can initiate communication by sending a START condition (see Definition: I 2 C conditions). This signal denotes the beginning of a new data transfer (which may contain several bytes of data) and brings all slaves out of their idle states.

See Clock rate and IBFD settings and I2C Bus Frequency Divider (IBFD) for the associated timing requirements.

## 45.5.2.6 Slave address transmission

The master transmits the slave address on the next clock cycle after the START condition (see START condition). The following table presents the process of slave address transmission.

Table 298. Slave address transmission process

|   Step | Action                                                                                                                                                                                                                                                                                                             |
|--------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|      1 | The master transmits the seven-bit slave address.                                                                                                                                                                                                                                                                  |
|      2 | The master transmits the R/W bit.                                                                                                                                                                                                                                                                                  |
|      3 | Each slave examines the transmitted address and compares it to its own. If the addresses match, the slave device returns the acknowledge bit on the ninth SCL clock cycle.                                                                                                                                         |
|      4 | The master waits for the acknowledge bit and determines the next step as follows:  The acknowledge bit is set: The master must initiate a data transfer followed by either a STOPcondition or a repeated START condition.  The acknowledge bit is cleared: The master must wait for SCL to return to logic zero. |

## 45.5.2.7 Data transmission

A data transfer session has the following characteristics:

- Can transmit one or more bytes of data
- Awakens all slaves
- Proceeds on a byte-by-byte basis in the direction specified by the R/W bit sent by the calling master

The transmitted data is subject to the following requirements:

- Each data byte must consist of 8 bits.
- Data bits can be changed only while SCL is low and must be held stable while SCL is high.
- One data bit is transmitted during one SCL clock pulse.
- The most significant bit (msb) must be transmitted first.
- Each data byte must be followed by an acknowledge bit on the ninth SCL clock pulse.

If the slave receiver does not acknowledge the master, the slave must leave the SDA line high. The master can then generate a STOP condition (to abort the data transfer) or a repeated START condition.

If the master receiver does not acknowledge the slave transmitter after a byte of transmission, the slave interprets that as reaching the end of data. The slave then releases the SDA line for the master to generate a STOP or a START condition.

## 45.5.2.8 STOP condition

The master can terminate the communication by generating a STOP condition (see Definition: I 2 C conditions). It can do so even if the slave has generated an acknowledge, at which point the slave must release the bus.

A master is not required to send a STOP condition at the end of every transfer. For more information, see Repeated START condition.

See Clock rate and IBFD settings and I2C Bus Frequency Divider (IBFD) for the associated timing requirements.

## 45.5.2.9 Repeated START condition

The I 2 C protocol also supports a repeated START condition, which can be generated without a preceding STOP condition. A master device can use this condition to communicate with another slave or with the same slave in a different mode without releasing the bus. This condition is illustrated in the second timing diagram of Figure 377.

## 45.5.3 Arbitration procedure

The I 2 C bus is a true multi-master bus that allows more than one master to be connected to the bus. If two or more masters try to control the bus at the same time, a clock synchronization procedure determines the bus clock. For this clock, the low period is equal to the longest clock low period and the high period is equal to the shortest period among the masters. A data arbitration procedure determines the relative priority of the contending masters. A bus master loses arbitration if it transmits logic "1" while another master transmits logic "0". The losing masters immediately switch over to slave mode and stop driving the SDA output. In this case, the transition from master to slave mode does not generate a STOP condition. Meanwhile, the I 2 C module sets IBSR[IBAL] to indicate loss of arbitration.

## 45.5.4 Clock behavior

This section presents the following topics:

- Clock synchronization
- Clock stretching
- Handshaking
- Clock rate and IBFD settings

## 45.5.4.1 Clock synchronization

Due to the wired-AND logic on the SCL line, a high-to-low transition on the SCL line affects all devices connected on the bus. The devices begin counting their low period when the master drives the SCL line low. After a device has driven SCL low, it holds the SCL line low until the clock high state is reached.

However, the change of low-to-high in a device clock may not change the state of the SCL line if another device is still within its low period. Therefore, the synchronized clock signal, SCL, is held low by the device with the longest low period. Devices with shorter low periods enter a high wait state during this time (see the following figure). When all devices concerned have counted off their

Inter-Integrated Circuit (I2C)

Inter-Integrated Circuit (I2C)

low period, the synchronized SCL line is released and pulled high. Then there is no difference between the devices' clocks and the state of the SCL line, and all the devices begin counting their high periods. The first device to complete its high period pulls the SCL line low again.

<!-- image -->

## 45.5.4.2 Clock stretching

Slaves can use the clock synchronization mechanism to slow down the bit rate of a transfer. After the master drives SCL low, the slave can drive SCL low for the required period and then release it. If the slave's SCL low period is greater than the master's SCL low period, the resulting SCL bus signal low period is stretched.

## 45.5.4.3 Handshaking

The clock synchronization mechanism can be used as a handshake in data transfer. Slave devices may hold the SCL low after completion of one byte transfer (nine bits). In such cases, it halts the bus clock and forces the master clock into wait state until the slave releases the SCL line.

## 45.5.4.4 Clock rate and IBFD settings

## 45.5.4.4.1 Timing definitions

Table 299. Timing definitions relevant to clock rate and IBFD settings

| Term        | Definition                                                                                                                         |
|-------------|------------------------------------------------------------------------------------------------------------------------------------|
| SCL Divider | The factor used to prescale the CPU clock for bit rate selection. This is relevant to:  Figure 379  Table 301  Table 302        |
| SCL period  | (CPU clock period)(SCL Divider)                                                                                                   |
| SCL Hold    | The required number of CPU clocks to generate a START or STOP condition. This is relevant to:  Figure 379  Table 301  Table 302 |
| SDA Hold    | This is relevant to:                                                                                                               |

Table continues on the next page...

Table 299. Timing definitions relevant to clock rate and IBFD settings (continued)

| Term   | Definition                           |
|--------|--------------------------------------|
|        |  Figure 380  Table 301  Table 302 |

<!-- image -->

## 45.5.4.4.2 Divider and hold values

Table 301 provides the values for:

- SCL Divider
- SDA Hold
- SCL Hold (start)
- SCL Hold (stop)

when the glitch filter is disabled. (To disable this filter, write IBDBG[GLFLT\_EN]=0.)

You have up to three MUL options available for all divider values, as shown in Table 300. Your choice of MUL determines the internal monitor rate of the I 2 C bus (SCL and SDA signals):

- A lower MUL value results in a higher sampling rate of the I 2 C signals.
- A higher MUL value results in a lower sampling rate of the I 2 C signals. This gives the I 2 C module greater immunity against glitches in the I 2 C signals.

## Table 300. MUL values as a function of IBC

| When IBC is...   |   MUL is... |
|------------------|-------------|
| 00h-3Fh          |           1 |
| 40h-7Fh          |           2 |
| 80h-BFh          |           4 |

## NOTE

The SCL clock frequency obtained using the divider values listed in Table 301 and Table 302 is the nominal frequency. The actual frequency depends on the rise time at the SCL pad. The observed I 2 C frequency may be higher or lower by 20%.

Table 301. I 2 C divider and hold values when glitch filter is disabled

| IBC (hex)   |   SCL Divider (clocks) |   SDA Hold (clocks) |   SCL Hold (start) |   SCL Hold (stop) |
|-------------|------------------------|---------------------|--------------------|-------------------|
| 00          |                     34 |                   7 |                  6 |                11 |
| 01          |                     36 |                   7 |                  7 |                12 |
| 02          |                     38 |                   8 |                  8 |                13 |
| 03          |                     40 |                   8 |                  9 |                14 |
| 04          |                     42 |                   9 |                 10 |                15 |
| 05          |                     44 |                   9 |                 11 |                16 |
| 06          |                     46 |                  10 |                 13 |                18 |
| 07          |                     54 |                  10 |                 16 |                21 |
| 08          |                     44 |                   7 |                 10 |                15 |
| 09          |                     48 |                   7 |                 12 |                17 |
| 0A          |                     52 |                   9 |                 14 |                19 |
| 0B          |                     56 |                   9 |                 16 |                21 |
| 0C          |                     60 |                  11 |                 18 |                23 |
| 0D          |                     64 |                  11 |                 20 |                25 |
| 0E          |                     72 |                  13 |                 24 |                29 |
| 0F          |                     84 |                  13 |                 30 |                35 |
| 10          |                     64 |                   9 |                 18 |                25 |
| 11          |                     72 |                   9 |                 22 |                29 |
| 12          |                     80 |                  13 |                 26 |                33 |
| 13          |                     88 |                  13 |                 30 |                37 |
| 14          |                     96 |                  17 |                 34 |                41 |
| 15          |                    104 |                  17 |                 38 |                45 |

Table continues on the next page...

Inter-Integrated Circuit (I2C)

Table 301. I 2 C divider and hold values when glitch filter is disabled (continued)

| IBC (hex)   |   SCL Divider (clocks) |   SDA Hold (clocks) |   SCL Hold (start) |   SCL Hold (stop) |
|-------------|------------------------|---------------------|--------------------|-------------------|
| 16          |                    120 |                  21 |                 46 |                53 |
| 17          |                    144 |                  21 |                 58 |                65 |
| 18          |                     96 |                   9 |                 38 |                41 |
| 19          |                    112 |                   9 |                 46 |                49 |
| 1A          |                    128 |                  17 |                 54 |                57 |
| 1B          |                    144 |                  17 |                 62 |                65 |
| 1C          |                    160 |                  25 |                 70 |                73 |
| 1D          |                    176 |                  25 |                 78 |                81 |
| 1E          |                    208 |                  33 |                 94 |                97 |
| 1F          |                    256 |                  33 |                118 |               121 |
| 20          |                    160 |                  17 |                 78 |                81 |
| 21          |                    192 |                  17 |                 94 |                97 |
| 22          |                    224 |                  33 |                110 |               113 |
| 23          |                    256 |                  33 |                126 |               129 |
| 24          |                    288 |                  49 |                142 |               145 |
| 25          |                    320 |                  49 |                158 |               161 |
| 26          |                    384 |                  65 |                190 |               193 |
| 27          |                    480 |                  65 |                238 |               241 |
| 28          |                    320 |                  33 |                158 |               161 |
| 29          |                    384 |                  33 |                190 |               193 |
| 2A          |                    448 |                  65 |                222 |               225 |
| 2B          |                    512 |                  65 |                254 |               257 |
| 2C          |                    576 |                  97 |                286 |               289 |
| 2D          |                    640 |                  97 |                318 |               321 |
| 2E          |                    768 |                 129 |                382 |               385 |

Table continues on the next page...

Inter-Integrated Circuit (I2C)

Table 301. I 2 C divider and hold values when glitch filter is disabled (continued)

| IBC (hex)   |   SCL Divider (clocks) |   SDA Hold (clocks) |   SCL Hold (start) |   SCL Hold (stop) |
|-------------|------------------------|---------------------|--------------------|-------------------|
| 2F          |                    960 |                 129 |                478 |               481 |
| 30          |                    640 |                  65 |                318 |               321 |
| 31          |                    768 |                  65 |                382 |               385 |
| 32          |                    896 |                 129 |                446 |               449 |
| 33          |                   1024 |                 129 |                510 |               513 |
| 34          |                   1152 |                 193 |                574 |               577 |
| 35          |                   1280 |                 193 |                638 |               641 |
| 36          |                   1536 |                 257 |                766 |               769 |
| 37          |                   1920 |                 257 |                958 |               961 |
| 38          |                   1280 |                 129 |                638 |               641 |
| 39          |                   1536 |                 129 |                766 |               769 |
| 3A          |                   1792 |                 257 |                894 |               897 |
| 3B          |                   2048 |                 257 |               1022 |              1025 |
| 3C          |                   2304 |                 385 |               1150 |              1153 |
| 3D          |                   2560 |                 385 |               1278 |              1281 |
| 3E          |                   3072 |                 513 |               1534 |              1537 |
| 3F          |                   3840 |                 513 |               1918 |              1921 |
| 40          |                     68 |                  14 |                 12 |                22 |
| 41          |                     72 |                  14 |                 14 |                24 |
| 42          |                     76 |                  16 |                 16 |                26 |
| 43          |                     80 |                  16 |                 18 |                28 |
| 44          |                     84 |                  18 |                 20 |                30 |
| 45          |                     88 |                  18 |                 22 |                32 |
| 46          |                     96 |                  20 |                 26 |                36 |
| 47          |                    108 |                  20 |                 32 |                42 |

Table continues on the next page...

Inter-Integrated Circuit (I2C)

Table 301. I 2 C divider and hold values when glitch filter is disabled (continued)

| IBC (hex)   |   SCL Divider (clocks) |   SDA Hold (clocks) |   SCL Hold (start) |   SCL Hold (stop) |
|-------------|------------------------|---------------------|--------------------|-------------------|
| 48          |                     88 |                  14 |                 20 |                30 |
| 49          |                     96 |                  14 |                 24 |                34 |
| 4A          |                    104 |                  18 |                 28 |                38 |
| 4B          |                    112 |                  18 |                 32 |                42 |
| 4C          |                    120 |                  22 |                 36 |                46 |
| 4D          |                    128 |                  22 |                 40 |                50 |
| 4E          |                    144 |                  26 |                 48 |                58 |
| 4F          |                    168 |                  26 |                 60 |                70 |
| 50          |                    128 |                  18 |                 36 |                50 |
| 51          |                    144 |                  18 |                 44 |                58 |
| 52          |                    160 |                  26 |                 52 |                66 |
| 53          |                    176 |                  26 |                 60 |                74 |
| 54          |                    192 |                  34 |                 68 |                82 |
| 55          |                    208 |                  34 |                 76 |                90 |
| 56          |                    240 |                  42 |                 92 |               106 |
| 57          |                    288 |                  42 |                116 |               130 |
| 58          |                    192 |                  18 |                 76 |                82 |
| 59          |                    224 |                  18 |                 92 |                98 |
| 5A          |                    256 |                  34 |                108 |               114 |
| 5B          |                    288 |                  34 |                124 |               130 |
| 5C          |                    320 |                  50 |                140 |               146 |
| 5D          |                    356 |                  50 |                156 |               162 |
| 5E          |                    416 |                  66 |                188 |               194 |
| 5F          |                    512 |                  66 |                236 |               242 |
| 60          |                    320 |                  34 |                156 |               162 |

Table continues on the next page...

Inter-Integrated Circuit (I2C)

Table 301. I 2 C divider and hold values when glitch filter is disabled (continued)

| IBC (hex)   |   SCL Divider (clocks) |   SDA Hold (clocks) |   SCL Hold (start) |   SCL Hold (stop) |
|-------------|------------------------|---------------------|--------------------|-------------------|
| 61          |                    384 |                  34 |                188 |               194 |
| 62          |                    448 |                  66 |                220 |               226 |
| 63          |                    512 |                  66 |                252 |               258 |
| 64          |                    576 |                  98 |                284 |               290 |
| 65          |                    640 |                  98 |                316 |               322 |
| 66          |                    768 |                 130 |                380 |               386 |
| 67          |                    960 |                 130 |                476 |               482 |
| 68          |                    640 |                  66 |                316 |               322 |
| 69          |                    768 |                  66 |                380 |               386 |
| 6A          |                    896 |                 130 |                444 |               450 |
| 6B          |                   1024 |                 130 |                508 |               514 |
| 6C          |                   1152 |                 194 |                572 |               578 |
| 6D          |                   1280 |                 194 |                636 |               642 |
| 6E          |                   1536 |                 258 |                764 |               770 |
| 6F          |                   1920 |                 258 |                956 |               962 |
| 70          |                   1280 |                 130 |                636 |               642 |
| 71          |                   1536 |                 130 |                764 |               770 |
| 72          |                   1792 |                 258 |                892 |               898 |
| 73          |                   2048 |                 258 |               1020 |              1026 |
| 74          |                   2304 |                 386 |               1148 |              1154 |
| 75          |                   2560 |                 386 |               1276 |              1282 |
| 76          |                   3072 |                 514 |               1532 |              1538 |
| 77          |                   3840 |                 514 |               1916 |              1922 |
| 78          |                   2560 |                 258 |               1276 |              1282 |
| 79          |                   3072 |                 258 |               1532 |              1538 |

Table continues on the next page...

Inter-Integrated Circuit (I2C)

Table 301. I 2 C divider and hold values when glitch filter is disabled (continued)

| IBC (hex)   |   SCL Divider (clocks) |   SDA Hold (clocks) |   SCL Hold (start) |   SCL Hold (stop) |
|-------------|------------------------|---------------------|--------------------|-------------------|
| 7A          |                   3584 |                 514 |               1788 |              1794 |
| 7B          |                   4096 |                 514 |               2044 |              2050 |
| 7C          |                   4608 |                 770 |               2300 |              2306 |
| 7D          |                   5120 |                 770 |               2556 |              2562 |
| 7E          |                   6144 |                1026 |               3068 |              3074 |
| 7F          |                   7680 |                1026 |               3836 |              3842 |
| 80          |                    136 |                  28 |                 24 |                44 |
| 81          |                    144 |                  28 |                 28 |                48 |
| 82          |                    152 |                  32 |                 32 |                52 |
| 83          |                    160 |                  32 |                 36 |                56 |
| 84          |                    168 |                  36 |                 40 |                60 |
| 85          |                    176 |                  36 |                 44 |                64 |
| 86          |                    192 |                  40 |                 52 |                72 |
| 87          |                    216 |                  40 |                 64 |                84 |
| 88          |                    176 |                  28 |                 40 |                60 |
| 89          |                    192 |                  28 |                 48 |                68 |
| 8A          |                    208 |                  36 |                 56 |                76 |
| 8B          |                    224 |                  36 |                 64 |                84 |
| 8C          |                    240 |                  44 |                 72 |                92 |
| 8D          |                    256 |                  44 |                 80 |               100 |
| 8E          |                    288 |                  52 |                 96 |               116 |
| 8F          |                    336 |                  52 |                120 |               140 |
| 90          |                    256 |                  36 |                 72 |               100 |
| 91          |                    288 |                  36 |                 88 |               116 |
| 92          |                    320 |                  52 |                104 |               132 |

Table continues on the next page...

Inter-Integrated Circuit (I2C)

Table 301. I 2 C divider and hold values when glitch filter is disabled (continued)

| IBC (hex)   |   SCL Divider (clocks) |   SDA Hold (clocks) |   SCL Hold (start) |   SCL Hold (stop) |
|-------------|------------------------|---------------------|--------------------|-------------------|
| 93          |                    352 |                  52 |                120 |               148 |
| 94          |                    384 |                  68 |                136 |               164 |
| 95          |                    416 |                  68 |                152 |               180 |
| 96          |                    480 |                  84 |                184 |               212 |
| 97          |                    576 |                  84 |                232 |               260 |
| 98          |                    358 |                  36 |                152 |               164 |
| 99          |                    448 |                  36 |                184 |               196 |
| 9A          |                    512 |                  68 |                216 |               228 |
| 9B          |                    576 |                  68 |                248 |               260 |
| 9C          |                    640 |                 100 |                280 |               292 |
| 9D          |                    704 |                 100 |                312 |               324 |
| 9E          |                    832 |                 132 |                376 |               388 |
| 9F          |                   1024 |                 132 |                472 |               484 |
| A0          |                    640 |                  68 |                312 |               324 |
| A1          |                    768 |                  68 |                376 |               388 |
| A2          |                    896 |                 132 |                440 |               452 |
| A3          |                   1024 |                 132 |                504 |               516 |
| A4          |                   1152 |                 196 |                568 |               580 |
| A5          |                   1280 |                 196 |                632 |               644 |
| A6          |                   1536 |                 260 |                760 |               772 |
| A7          |                   1920 |                 260 |                952 |               964 |
| A8          |                   1280 |                 132 |                632 |               644 |
| A9          |                   1536 |                 132 |                760 |               772 |
| AA          |                   1792 |                 260 |                888 |               900 |
| AB          |                   2048 |                 260 |               1016 |              1028 |

Table continues on the next page...

Inter-Integrated Circuit (I2C)

Table 301. I 2 C divider and hold values when glitch filter is disabled (continued)

| IBC (hex)   |   SCL Divider (clocks) |   SDA Hold (clocks) |   SCL Hold (start) |   SCL Hold (stop) |
|-------------|------------------------|---------------------|--------------------|-------------------|
| AC          |                   2304 |                 388 |               1144 |              1156 |
| AD          |                   2560 |                 388 |               1272 |              1284 |
| AE          |                   3072 |                 516 |               1528 |              1540 |
| AF          |                   3840 |                 516 |               1912 |              1924 |
| B0          |                   2560 |                 260 |               1272 |              1284 |
| B1          |                   3072 |                 260 |               1528 |              1540 |
| B2          |                   3584 |                 516 |               1784 |              1796 |
| B3          |                   4096 |                 516 |               2040 |              2052 |
| B4          |                   4608 |                 772 |               2296 |              2308 |
| B5          |                   5120 |                 772 |               2552 |              2564 |
| B6          |                   6144 |                1028 |               3064 |              3076 |
| B7          |                   7680 |                1028 |               3832 |              3844 |
| B8          |                   5120 |                 516 |               2552 |              2564 |
| B9          |                   6144 |                 516 |               3064 |              3076 |
| BA          |                   7168 |                1028 |               3576 |              3588 |
| BB          |                   8192 |                1028 |               4088 |              4100 |
| BC          |                   9216 |                1540 |               4600 |              4612 |
| BD          |                  10240 |                1540 |               5112 |              5124 |
| BE          |                  12288 |                2052 |               6136 |              6148 |
| BF          |                  15360 |                2052 |               7672 |              7684 |

Table 302 provides the values for:

- SCL Divider
- SDA Hold
- SCL Hold (start)
- SCL Hold (stop)

when the glitch filter is enabled. (To enable this filter, write IBDBG[GLFLT\_EN]=1.)

Table 302. I 2 C divider and hold values when glitch filter is enabled

| IBC (hex)   |   SCL Divider (clocks) |   SDA Hold (clocks) |   SCL Hold (start) |   SCL Hold (stop) |
|-------------|------------------------|---------------------|--------------------|-------------------|
| 00          |                     34 |                  14 |                  6 |                18 |
| 01          |                     36 |                  14 |                  7 |                19 |
| 02          |                     38 |                  15 |                  8 |                20 |
| 03          |                     40 |                  15 |                  9 |                21 |
| 04          |                     42 |                  16 |                 10 |                22 |
| 05          |                     44 |                  16 |                 11 |                23 |
| 06          |                     48 |                  17 |                 13 |                25 |
| 07          |                     54 |                  17 |                 16 |                28 |
| 08          |                     44 |                  15 |                 10 |                23 |
| 09          |                     48 |                  15 |                 12 |                25 |
| 0A          |                     52 |                  17 |                 14 |                27 |
| 0B          |                     56 |                  17 |                 16 |                29 |
| 0C          |                     60 |                  19 |                 18 |                31 |
| 0D          |                     64 |                  19 |                 20 |                33 |
| 0E          |                     72 |                  21 |                 24 |                37 |
| 0F          |                     84 |                  21 |                 30 |                43 |
| 10          |                     64 |                  17 |                 18 |                33 |
| 11          |                     72 |                  17 |                 22 |                37 |
| 12          |                     80 |                  21 |                 26 |                41 |
| 13          |                     88 |                  21 |                 30 |                45 |
| 14          |                     96 |                  25 |                 34 |                49 |
| 15          |                    104 |                  25 |                 38 |                53 |
| 16          |                    120 |                  29 |                 46 |                61 |
| 17          |                    144 |                  29 |                 58 |                73 |
| 18          |                     96 |                  17 |                 38 |                49 |
| 19          |                    112 |                  17 |                 46 |                57 |
| 1A          |                    128 |                  25 |                 54 |                65 |
| 1B          |                    144 |                  25 |                 62 |                73 |
| 1C          |                    160 |                  33 |                 70 |                81 |
| 1D          |                    176 |                  33 |                 78 |                89 |
| 1E          |                    208 |                  41 |                 94 |               105 |

Table continues on the next page...

Inter-Integrated Circuit (I2C)

Table 302. I 2 C divider and hold values when glitch filter is enabled (continued)

| 1F   |   256 |   41 |   11 |   129 |
|------|-------|------|------|-------|
| 20   |   160 |   17 |   78 |    81 |
| 21   |   192 |   17 |   94 |    97 |
| 22   |   224 |   33 |  110 |   113 |
| 23   |   256 |   33 |  126 |   129 |
| 24   |   288 |   49 |  142 |   145 |
| 25   |   320 |   49 |  158 |   161 |
| 26   |   384 |   65 |  190 |   193 |
| 27   |   480 |   65 |  238 |   241 |
| 28   |   320 |   33 |  158 |   161 |
| 29   |   384 |   33 |  190 |   193 |
| 2A   |   448 |   65 |  222 |   225 |
| 2B   |   512 |   65 |  254 |   257 |
| 2C   |   576 |   97 |  286 |   289 |
| 2D   |   640 |   97 |  318 |   321 |
| 2E   |   768 |  129 |  382 |   385 |
| 2F   |   960 |  129 |  478 |   481 |
| 30   |   640 |   65 |  318 |   321 |
| 31   |   768 |   65 |  382 |   385 |
| 32   |   896 |  129 |  446 |   449 |
| 33   |  1024 |  129 |  510 |   513 |
| 34   |  1152 |  193 |  574 |   577 |
| 35   |  1280 |  193 |  638 |   641 |
| 36   |  1536 |  257 |  766 |   769 |
| 37   |  1920 |  257 |  958 |   961 |
| 38   |  1280 |  129 |  638 |   641 |
| 39   |  1536 |  129 |  766 |   769 |
| 3A   |  1792 |  257 |  894 |   897 |
| 3B   |  2048 |  257 | 1022 |  1025 |
| 3C   |  2304 |  385 | 1150 |  1153 |
| 3D   |  2560 |  385 | 1278 |  1281 |
| 3E   |  3072 |  513 | 1534 |  1537 |
| 3F   |  3840 |  513 | 1918 |  1921 |

Table continues on the next page...

Table 302. I 2 C divider and hold values when glitch filter is enabled (continued)

| 40   |   68 |   28 |   12 |   36 |
|------|------|------|------|------|
| 41   |   72 |   28 |   14 |   38 |
| 42   |   76 |   30 |   16 |   40 |
| 43   |   80 |   30 |   18 |   42 |
| 44   |   84 |   32 |   20 |   44 |
| 45   |   88 |   32 |   22 |   46 |
| 46   |   96 |   34 |   26 |   50 |
| 47   |  108 |   34 |   32 |   56 |
| 48   |   88 |   30 |   20 |   46 |
| 49   |   96 |   30 |   24 |   50 |
| 4A   |  104 |   34 |   28 |   54 |
| 4B   |  112 |   34 |   32 |   58 |
| 4C   |  120 |   38 |   36 |   62 |
| 4D   |  128 |   38 |   40 |   66 |
| 4E   |  144 |   42 |   48 |   74 |
| 4F   |  168 |   42 |   60 |   86 |
| 50   |  128 |   34 |   36 |   66 |
| 51   |  144 |   34 |   44 |   74 |
| 52   |  160 |   42 |   52 |   82 |
| 53   |  176 |   42 |   60 |   90 |
| 54   |  192 |   50 |   68 |   98 |
| 55   |  208 |   50 |   76 |  106 |
| 56   |  240 |   58 |   92 |  122 |
| 57   |  288 |   58 |  116 |  146 |
| 58   |  192 |   34 |   76 |   98 |
| 59   |  224 |   34 |   92 |  114 |
| 5A   |  256 |   50 |  108 |  130 |
| 5B   |  288 |   50 |  124 |  146 |
| 5C   |  320 |   66 |  140 |  162 |
| 5D   |  352 |   66 |  156 |  178 |
| 5E   |  416 |   82 |  188 |  210 |
| 5F   |  512 |   82 |  236 |  258 |
| 60   |  320 |   34 |  156 |  162 |

Table continues on the next page...

Table 302. I 2 C divider and hold values when glitch filter is enabled (continued)

| 61   |   384 |   34 |   188 |   194 |
|------|-------|------|-------|-------|
| 62   |   448 |   66 |   220 |   226 |
| 63   |   512 |   66 |   252 |   258 |
| 64   |   576 |   98 |   284 |   290 |
| 65   |   640 |   98 |   316 |   322 |
| 66   |   768 |  130 |   380 |   386 |
| 67   |   960 |  130 |   476 |   482 |
| 68   |   640 |   66 |   316 |   322 |
| 69   |   768 |   66 |   380 |   386 |
| 6A   |   896 |  130 |   444 |   450 |
| 6B   |  1024 |  130 |   508 |   514 |
| 6C   |  1152 |  194 |   572 |   578 |
| 6D   |  1280 |  194 |   636 |   642 |
| 6E   |  1536 |  258 |   764 |   770 |
| 6F   |  1920 |  258 |   956 |   962 |
| 70   |  1280 |  130 |   636 |   642 |
| 71   |  1536 |  130 |   764 |   770 |
| 72   |  1792 |  258 |   892 |   898 |
| 73   |  2048 |  258 |  1020 |  1026 |
| 74   |  2304 |  386 |  1148 |  1154 |
| 75   |  2560 |  386 |  1276 |  1282 |
| 76   |  3072 |  514 |  1532 |  1538 |
| 77   |  3840 |  514 |  1916 |  1922 |
| 78   |  2560 |  258 |  1276 |  1282 |
| 79   |  3072 |  258 |  1532 |  1538 |
| 7A   |  3584 |  514 |  1788 |  1794 |
| 7B   |  4096 |  514 |  2044 |  2050 |
| 7C   |  4608 |  770 |  2300 |  2306 |
| 7D   |  5120 |  770 |  2556 |  2562 |
| 7E   |  6144 | 1026 |  3068 |  3074 |
| 7F   |  7680 | 1026 |  3836 |  3842 |
| 80   |   136 |   56 |    24 |    72 |
| 81   |   144 |   56 |    28 |    76 |

Table continues on the next page...

Table 302. I 2 C divider and hold values when glitch filter is enabled (continued)

| 82   |   152 |   60 |   32 |   80 |
|------|-------|------|------|------|
| 83   |   160 |   60 |   36 |   84 |
| 84   |   168 |   64 |   40 |   88 |
| 85   |   176 |   64 |   44 |   92 |
| 86   |   192 |   68 |   52 |  100 |
| 87   |   216 |   68 |   64 |  112 |
| 88   |   176 |   60 |   40 |   92 |
| 89   |   192 |   60 |   48 |  100 |
| 8A   |   208 |   68 |   56 |  108 |
| 8B   |   224 |   68 |   64 |  116 |
| 8C   |   240 |   76 |   72 |  124 |
| 8D   |   256 |   76 |   80 |  132 |
| 8E   |   288 |   84 |   96 |  148 |
| 8F   |   336 |   84 |  120 |  172 |
| 90   |   256 |   68 |   72 |  132 |
| 91   |   288 |   68 |   88 |  148 |
| 92   |   320 |   84 |  104 |  164 |
| 93   |   352 |   84 |  120 |  180 |
| 94   |   384 |  100 |  136 |  196 |
| 95   |   416 |  100 |  152 |  212 |
| 96   |   480 |  116 |  184 |  244 |
| 97   |   576 |  116 |  232 |  292 |
| 98   |   384 |   68 |  152 |  196 |
| 99   |   448 |   68 |  184 |  228 |
| 9A   |   512 |  100 |  216 |  260 |
| 9B   |   576 |  100 |  248 |  292 |
| 9C   |   640 |  132 |  280 |  324 |
| 9D   |   704 |  132 |  312 |  356 |
| 9E   |   832 |  164 |  376 |  420 |
| 9F   |  1024 |  164 |  472 |  516 |
| A0   |   640 |   68 |  312 |  324 |
| A1   |   768 |   68 |  376 |  388 |
| A2   |   896 |  132 |  440 |  452 |

Table continues on the next page...

Table 302. I 2 C divider and hold values when glitch filter is enabled (continued)

| A3   |   1024 |   132 |   504 |   516 |
|------|--------|-------|-------|-------|
| A4   |   1152 |   196 |   568 |   580 |
| A5   |   1280 |   196 |   632 |   644 |
| A6   |   1536 |   260 |   760 |   772 |
| A7   |   1920 |   260 |   952 |   964 |
| A8   |   1280 |   132 |   632 |   644 |
| A9   |   1536 |   132 |   760 |   772 |
| AA   |   1792 |   260 |   888 |   900 |
| AB   |   2048 |   260 |  1016 |  1028 |
| AC   |   2304 |   388 |  1144 |  1156 |
| AD   |   2560 |   388 |  1272 |  1284 |
| AE   |   3072 |   516 |  1528 |  1540 |
| AF   |   3840 |   516 |  1912 |  1924 |
| B0   |   2560 |   260 |  1272 |  1284 |
| B1   |   3072 |   260 |  1528 |  1540 |
| B2   |   3584 |   516 |  1784 |  1796 |
| B3   |   4096 |   516 |  2040 |  2052 |
| B4   |   4608 |   772 |  2296 |  2308 |
| B5   |   5120 |   772 |  2552 |  2564 |
| B6   |   6144 |  1028 |  3064 |  3076 |
| B7   |   7680 |  1028 |  3832 |  3844 |
| B8   |   5120 |   516 |  2552 |  2564 |
| B9   |   6144 |   516 |  3064 |  3076 |
| BA   |   7168 |  1028 |  3576 |  3588 |
| BB   |   8192 |  1028 |  4088 |  4100 |
| BC   |   9216 |  1540 |  4600 |  4612 |
| BD   |  10240 |  1540 |  5112 |  5124 |
| BE   |  12288 |  2052 |  6136 |  6148 |
| BF   |  15360 |  2052 |  7672 |  7684 |

## 45.5.5 Interrupts

This section presents the following topics:

- Interrupt vector
- Interrupt description

## 45.5.5.1 Interrupt vector

The I 2 C module uses only one interrupt vector.

## Table 303. Interrupt summary

| Interrupt       | Offset   | Vector   | Priority   | Source                              | Description                                                                                                                                                                                                                                                                 |
|-----------------|----------|----------|------------|-------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| I 2 C interrupt | -        | -        | -          | IBAL, TCF, IAAS, IBB fields in IBSR | When any of IBAL, TCF, or IAAS fields are 1, the I 2 C module may cause an interrupt based on Arbitration lost, Transfer Complete, or Address Detect conditions. If enabled by BIIE, the de- assertion of IBB can also cause an interrupt, indicating that the bus is idle. |

## 45.5.5.2 Interrupt description

There are five types of internal interrupts in the I 2 C. The interrupt service routine can determine the interrupt type by reading the Status register.

I 2 C Interrupt can be generated on the following events:

- Arbitration Lost condition (IBSR[IBAL]=1)
- Byte Transfer condition (IBSR[TCF]=1 and IBCR[DMAEN]=0)
- Address Detect condition (IBSR[IAAS]=1)
- No Acknowledge from slave received when expected
- Bus idle (IBSR[IBB]=0)

The IBCR[IBIE] field enables the I 2 C interrupt. To clear this field, program IBSR[IBIF]=1 in the interrupt service routine.

To use the Bus idle interrupt, you must enable it by using the IBIC[BIIE] field.

## 45.5.6 DEBUG mode

This mode allows the CPU to debug the I 2 C module by freezing all the counters, registers, and status bits. To enter this mode, the I 2 C module must receive a DEBUG mode request, defined as this combination of actions:

- Another module on the chip sends an internal debug signal to the I 2 C module.
- You program IBDBG[IPG\_DEBUG\_EN]=1.

The I 2 C module completes all the ongoing transactions and comes to a graceful halt after receiving a DEBUG mode request.

The I 2 C module programs IBDBG[IPG\_DEBUG\_HALTED]=1 to indicate that the module has successfully serviced the DEBUG mode request.

The I 2 C module programs IBDBG[IPG\_DEBUG\_HALTED]=0 after the module that sent the DEBUG mode request ends that request and you program IBDBG[IPG\_DEBUG\_EN]=0.

As soon as the I 2 C module enters DEBUG mode:

- No transaction can take place.
- All the registers, counters and status bits are frozen. They all can be accessed by the CPU to enable the debugging.

The I 2 C module enters this mode only after successfully completing the current ongoing transaction. For example, if the current transaction consists of eight bytes and you initiated DEBUG mode at the time of the second byte, the IPG Debug Halted signal will be asserted after the eighth byte is transmitted/received. See the simulation result in Figure 381 for more details.

Inter-Integrated Circuit (I2C)

Inter-Integrated Circuit (I2C)

<!-- image -->

The I 2 C module enters DEBUG mode after completing the transmission or reception of the current byte when both of these conditions are true:

- Any DMA transaction (transmit or receive) is in progress
- The I 2 C module receives a DEBUG mode request at the same time that a byte reception or transmission occurs

As soon as the module exits DEBUG mode, transmission or reception of the remaining bytes resumes. See the simulation snapshot shown in Figure 382 for details where the I 2 C is transmitting eight bytes using DMA and the I 2 C module receives a DEBUG mode request while the module is transmitting the second byte. The I 2 C module enters DEBUG mode after the module successfully transmits the second byte (IPG Debug Halted signal asserted). As soon as the module exits DEBUG mode and deasserts the IPG Debug Halted signal, transmission resumes successfully.

<!-- image -->

No more transactions can occur until the module that sent the DEBUG mode request ends that request. At that time, the I 2 C module starts functioning normally. You can examine the IBDBG[IPG\_DEBUG\_HALTED] field to determine whether the I 2 C module is in DEBUG mode. See Figure 383 for more details.

<!-- image -->

Figure 384 shows a case of DEBUG mode with repeated START transaction. In this case, if another module on the chip sends an internal debug signal to the I 2 C module in the middle of a transaction, the I 2 C module completes the entire transaction with multiple repeated START before the module enters DEBUG mode.

Inter-Integrated Circuit (I2C)

<!-- image -->

## 45.5.7 DMA interface

The I 2 C module implements a simple DMA interface so that the module can request data transfers with minimal support from the CPU (see DMA application information). You enable DMA mode by programming IBCR[DMAEN].

The DMA interface is operational when the I 2 C module is configured for Master mode.

You must transfer at least three bytes of data per frame to/from the slave when using DMA mode. However, in practice, DMA mode is only worthwhile when you have a large number of data bytes to transfer per frame.

The I 2 C module uses two internal signals-TX request and RX request-to signal the DMA controller when the I 2 C module must write data to IBDR or read data from IBDR.

See Initialization/application information for further details of the DMA interface.

## 45.6 Initialization/application information

This section presents the following topics:

- Recommended interrupt service flow
- General programming guidelines (for both master and slave mode)
- Programming guidelines specific to Master mode
- Programming guidelines specific to Slave mode
- DMA application information

## 45.6.1 Recommended interrupt service flow

The following figure shows a flowchart for the recommended I 2 C interrupt service routine. Deviation from the flowchart may result in unpredictable I 2 C bus behavior.

Inter-Integrated Circuit (I2C)

<!-- image -->

## 45.6.2 General programming guidelines (for both master and slave mode)

This section provides programming guidelines recommended for the I 2 C module in both master and slave mode. It presents the following topics:

- Initializing the I 2 C module
- Software response after a transfer

## 45.6.2.1 Initializing the I 2 C module

The following table describes how to initialize the I 2 C module.

## Table 304. I 2 C initialization procedure

|   Step | Action                                                                                                                         |
|--------|--------------------------------------------------------------------------------------------------------------------------------|
|      1 | Use I2C Bus Frequency Divider (IBFD) to select the required division ratio to obtain SCL frequency from the system clock.      |
|      2 | Use I2C Bus Address (IBAD) to define the slave address.                                                                        |
|      3 | Clear the MDIS field in I2C Bus Control (IBCR) to enable the I 2 C interface system.                                           |
|      4 | Use I2C Bus Control (IBCR) to select Master/Slave mode, Transmit/Receive mode, and whether interrupts are enabled or disabled. |
|      5 | (Optional) Use I2C Bus Interrupt Configuration (IBIC) to further refine the interrupt behavior.                                |

## 45.6.2.2 Software response after a transfer

Transmission or reception of a byte causes the I 2 C module to program IBSR[TCF]=1. This indicates that the I 2 C module transmitted one byte. The I 2 C module also programs the interrupt flag IBSR[IBIF]=1 and generates an interrupt if your software enabled the interrupt function (by programming IBCR[IBIE]=1) during initialization. Your software can clear IBSR[IBIF] by writing a 1 to that field (in the interrupt service routine, if interrupts are used).

The I 2 C module programs IBSR[TCF]=0 to indicate data transfer in progress whenever your software:

- Writes to IBDR in transmit mode
- Reads the IBDR in receive mode

Do not use IBSR[TCF] as a "data transfer complete" flag. This is because the flag timing depends on a number of factors, including the I 2 C bus frequency. This field may not conclusively provide an indication of a transfer-complete situation. Your software must detect transfer-complete situations by using IBSR[IBIF].

Your software may service the I 2 C I/O in the main program by monitoring IBSR[IBIF] if your software disabled the interrupt function. Your software must poll IBSR[IBIF] instead of IBSR[TCF] because these fields function differently when arbitration is lost.

When a "Transfer Complete" interrupt occurs at the end of the address cycle, the master will always be in transmit mode-that is, the I 2 C module transmits the address. If master receive mode is required, indicated by R/W bit sent with slave calling address, then the master's IBCR[TXRX] field must be toggled at this stage. If Master does not receive an ACK from Slave, then transmission must be re-initiated or terminated.

In slave mode, the I 2 C module programs IBSR[IAAS]=1 if the Slave address (I2C Bus Address (IBAD)) matches the Master calling address. This is an indication that Master-Slave data communication can now start. During address cycles (IBSR[IAAS]=1), your software reads IBSR[SRW] to determine the direction of the subsequent transfer and programs IBCR[TXRX] accordingly. For slave mode data cycles (IBSR[IAAS]=0), IBSR[SRW] is not valid. Your software must read IBCR[TXRX] to determine the direction of the current transfer.

## 45.6.3 Programming guidelines specific to Master mode

This section presents the following topics:

- Generating START
- Transmit/receive sequence
- Generating STOP
- Generating repeated START
- Loss of arbitration

## 45.6.3.1 Generating START

After the I 2 C module completes its initialization procedure, the module can transmit serial data when your software selects the master transmitter mode. If the device is connected to a multi-master bus system, your software must test the state of IBSR[IBB] to check whether the serial bus is free.

Your software can configure the I 2 C module to send the START condition and the first byte (the slave address) if the bus is free (IBSR[IBB]=0). The data that your software writes to the data register (I2C Bus Data I/O (IBDR)) comprises the slave calling address and the LSB. Your software configures the LSB to indicate the direction of transfer required from the slave.

The bus free time (the time between a STOP condition and the following START condition) is built into the I 2 C module that generates the START cycle. Depending on the relative frequencies of the system clock and the SCL period, your software must wait until the I 2 C bus is busy after writing the calling address to the IBDR before proceeding with the next instructions. This is illustrated in the following example.

Here is an example of the sequence of events which generates the START signal and transmits the first byte of data (slave address):

```
while (IBSR[IBB]==1)               // wait in loop for IBB flag to clear IBCR[MS/MSL] and IBCR[]Tx/Rx] = 1  // master and transmit mode, that is, // generate start condition IBDR = calling_address             // send the calling address to the data register while (bit 5, IBSR ==0)            // wait in loop for IBB flag to be set
```

## 45.6.3.2 Transmit/receive sequence

The following tables present the sequences for:

- Master transmit
- Master receive
- Slave transmit
- Slave receive

## Table 305. Master transmit sequence

| Step   | Action                                                                                                                                       |
|--------|----------------------------------------------------------------------------------------------------------------------------------------------|
| a      | Use I2C Bus Frequency Divider (IBFD) to select the required division ratio to obtain SCL frequency from platform clock/2.                    |
| b      | Write a 0 to IBCR[MDIS] to enable the I 2 C interface system.                                                                                |
| c      | Use I2C Bus Control (IBCR) to select Master mode, Transmit mode, and interrupt enable.                                                       |
| d      | Write a 0 to IBSR[IBIF].                                                                                                                     |
| e      | Write data to I2C Bus Data I/O (IBDR).                                                                                                       |
| f      | Observe changes in IBSR[TCF]:  When IBSR[TCF] becomes 0, the transfer is in progress.  When IBSR[TCF] becomes 1, the transfer is complete. |
| g      | Wait until IBSR[IBIF] becomes 1.                                                                                                             |
| h      | Read the fields in I2C Bus Status (IBSR) to determine what happened:  If TCF = 1, the transfer completed.                                   |

Table continues on the next page...

Inter-Integrated Circuit (I2C)

## Table 305. Master transmit sequence (continued)

| Step   | Action                                                                                                                                                                                                                                                                              |
|--------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|        |  If RXAK = 1, a No Acknowledge condition occurred.  If IBB = 0, the bus transitioned from Busy to Idle state.  If IBB = 1, you can ignore check of Arbitration Loss (IBAL = 1). You can ignore Address Detect (IAAS = 1) for master mode (it is valid only for slave mode). NOTE |
| i      | Examine IBSR[RXAK] for an acknowledgment from the slave.                                                                                                                                                                                                                            |
| j      | Repeat steps d through i to transfer the next consecutive bytes of data.                                                                                                                                                                                                            |

## Table 306. Master receive sequence

| Step   | Action                                                                                                                                                                                                                                                                                                                   |
|--------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| a      | Execute steps a through i in Table 305 for address dispatch.                                                                                                                                                                                                                                                             |
| b      | Write a 0 to IBSR[IBIF].                                                                                                                                                                                                                                                                                                 |
| c      | Write a 0 IBCR[TXRX] to select Receive mode.                                                                                                                                                                                                                                                                             |
| d      | Perform a dummy read of I2C Bus Data I/O (IBDR) to initiate the receive operation.                                                                                                                                                                                                                                       |
| e      | Wait until IBSR[TCF] becomes 1. This proves that the transfer is complete.                                                                                                                                                                                                                                               |
| f      | Wait until IBSR[IBIF] becomes 1.                                                                                                                                                                                                                                                                                         |
| g      | Read the fields in I2C Bus Status (IBSR) to determine what happened:  If TCF = 1, the reception completed.  If IBB = 0, the bus transitioned from Busy to Idle state.  If IBB = 1, you can ignore check of Arbitration Loss (IBAL = 1). You can ignore the No Acknowledge condition (RXAK = 1) for receive mode. NOTE |
| h      | Read I2C Bus Data I/O (IBDR) to determine the data received from the slave.                                                                                                                                                                                                                                              |
| i      | Change IBSR[IBIF] and IBSR[TCF] to 0 by writing 1 to those fields.                                                                                                                                                                                                                                                       |
| j      | Repeat steps e through i to read subsequent bytes.                                                                                                                                                                                                                                                                       |

## Table 307. Slave transmit sequence

| Step   | Action                                                        |
|--------|---------------------------------------------------------------|
| a      | Use I2C Bus Address (IBAD) to define the slave address.       |
| b      | Write a 0 to IBCR[MDIS] to enable the I 2 C interface system. |
| c      | Examine fields in I2C Bus Status (IBSR) as follows:           |

Table continues on the next page...

## Table 307. Slave transmit sequence (continued)

| Step   | Action                                                            |
|--------|-------------------------------------------------------------------|
| d      | Write data to I2C Bus Data I/O (IBDR).                            |
| e      | Wait until IBSR[IBIF] becomes 1.                                  |
| f      | Wait until IBSR[RXAK] becomes 0.                                  |
| g      | Write a 0 to IBSR[IBIF].                                          |
| h      | Repeat steps d through g for the next consecutive data transfers. |

## Table 308. Slave receive sequence

| Step   | Action                                                                                                                                                                                                                                                                                                                   |
|--------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| a      | Use I2C Bus Address (IBAD) to define the slave address.                                                                                                                                                                                                                                                                  |
| b      | Write a 0 to IBCR[MDIS] to enable the I 2 C interface system.                                                                                                                                                                                                                                                            |
| c      | Examine fields in I2C Bus Status (IBSR) as follows:  If IAAS = 1, examine IBSR[SRW].  If IAAS = 1 and SRW = 0, write a 0 to IBCR[TXRX] to select Receive mode.                                                                                                                                                         |
| d      | Write a 0 to IBSR[IBIF].                                                                                                                                                                                                                                                                                                 |
| e      | Perform a dummy read of I2C Bus Data I/O (IBDR) to initiate the receive operation.                                                                                                                                                                                                                                       |
| f      | Wait until IBSR[TCF] becomes 1. This proves that the transfer is complete.                                                                                                                                                                                                                                               |
| g      | Wait until IBSR[IBIF] becomes 1.                                                                                                                                                                                                                                                                                         |
| h      | Read the fields in I2C Bus Status (IBSR) to determine what happened:  If TCF = 1, the reception completed.  If IBB = 0, the bus transitioned from Busy to Idle state.  If IBB = 1, you can ignore check of Arbitration Loss (IBAL = 1). You can ignore the No Acknowledge condition (RXAK = 1) for receive mode. NOTE |
| i      | Read I2C Bus Data I/O (IBDR) to determine the data received from the master.                                                                                                                                                                                                                                             |
| j      | Change IBSR[IBIF] and IBSR[TCF] to 0 by writing 1 to those fields.                                                                                                                                                                                                                                                       |
| k      | Repeat steps f through j to read subsequent bytes.                                                                                                                                                                                                                                                                       |

## 45.6.3.3 Generating STOP

A data transfer ends with a STOP condition generated by the master device. A master transmitter can simply generate a STOP condition after it transmits all the data. Here is an example showing how a master transmitter generates a STOP condition.

```
if (tx_count == 0) or     // check to see if all data bytes have been transmitted (bit 0, IBSR == 1) {    // or if no ACK generated clear bit 5, IBCR     // generate STOP condition } else { IBDR = data_to_transmit  // write byte of data to DATA register
```

Inter-Integrated Circuit (I2C)

```
tx_count --            // decrement counter }                        // return from interrupt
```

If a master receiver wants to terminate a data transfer, it must inform the slave transmitter by not acknowledging the last byte of data. The master receiver can do this by programming IBCR[NOACK]=1 before reading the second-to-last byte of data. Before reading the last byte of data, the master receiver must first generate a STOP condition. Here is an example showing how a master receiver generates a STOP condition.

```
rx_count --            // decrease the rx counter if (rx_count ==1)      // 2nd last byte to be read ? bit 3, IBCR = 1       // disable ACK if (rx_count == 0)    // last byte to be read ? bit 5, IBCR = 0       // generate STOP condition else data_received = IBDR   // read RX data and store
```

## 45.6.3.4 Generating repeated START

At the end of data transfer, if the master still wants to communicate on the bus, it can generate another START signal followed by another slave address without first generating a STOP signal. Here is a program example.

```
bit 2, IBCR = 1             // generate another start (restart) IBDR == calling_address     // transmit the calling address
```

## 45.6.3.5 Loss of arbitration

If several masters try to engage the bus simultaneously, only one master wins and the others lose arbitration. The devices that lost arbitration are immediately switched to slave mode by the I 2 C module. Their data output to the SDA line is stopped, but SCL is still generated until the end of the byte during which arbitration was lost. An interrupt occurs at the falling edge of the ninth clock of this transfer with IBSR[IBAL]=1 and IBCR[MSSL]=0. If one master attempts to start transmission while the bus is being engaged by another master, the hardware:

- Inhibits the transmission
- Switches IBCR[MSSL] from 1 to 0 without generating a STOP condition
- Generates an interrupt to the CPU
- Programs IBSR[IBAL]=1 to indicate that the attempt to engage the bus is failed
- Does not program IBSR[TCF]=1 due to the loss of data during arbitration

When considering these cases, your slave service routine should test IBSR[IBAL] first and your software should program IBSR[IBAL]=0 if IBSR[IBAL]=1.

## 45.6.4 Programming guidelines specific to Slave mode

In the slave interrupt service routine, IBSR[IAAS] should be tested to check if a calling of its own address has just been received. If IBSR[IAAS]=1, software should program IBCR[TXRX]=1 according to IBSR[SRW]. Writing to the IBCR clears IBSR[IAAS] automatically. The only time you will read a value of 1 from IBSR[IAAS] is from the interrupt at the end of the address cycle where an address match occurred. Interrupts resulting from subsequent data transfers will have IAAS cleared.

A data transfer may now be initiated by writing information to IBDR for slave transmits or dummy reading from IBDR in slave receive mode. The slave will drive SCL low between byte transfers. SCL is released when the IBDR is accessed in the required mode.

Inter-Integrated Circuit (I2C)

Inter-Integrated Circuit (I2C)

In slave transmitter routine, IBSR[RXAK] must be tested before transmitting the next byte of data. Setting RXAK means an end-of-data signal from the master receiver, after which it must be switched from transmitter mode to receiver mode by software. A dummy read then releases the SCL line so that the master can generate a STOP signal.

## 45.6.5 DMA application information

The DMA interface on the I 2 C module is not completely autonomous and requires intervention from the CPU to start and to terminate the frame transfer. DMA mode is only valid for Master transmit and Master receive modes. Your software must ensure that the DMAEN field in I2C Bus Control (IBCR) is not set when the I 2 C module is configured in slave mode.

The DMA controller must only transfer one byte of data per Tx/Rx request. This is because the I 2 C module does not have a FIFO.

The CPU should also keep the I 2 C interrupt enabled during a DMA transfer to detect the arbitration lost condition and take action to recover from this situation. The DMAEN field in I2C Bus Control (IBCR) can disable the transfer complete interrupt. This means that during normal transfers (no errors) there will always be either an interrupt or a request to the DMA controller, depending on the setting of IBCR[DMAEN]. All error conditions will trigger an interrupt and require CPU intervention. The address match condition will not occur in DMA mode because the I 2 C should never be configured for slave operation.

The following sections provide details on setting up a DMA transfer and what intervention is required from the CPU. The sections assume that the system DMA controller can generate an interrupt after a certain number of DMA transfers have occurred.

The sections present the following topics:

- DMA mode, master transmit
- DMA mode, master reception
- Exiting DMA mode and system requirement considerations

## 45.6.5.1 DMA mode, master transmit

The following flowchart describes the exact operation for using a DMA controller to transmit n data bytes to a slave. The CPU always transmits the first byte (the slave calling address) and last byte. The DMA controller can transfer all other data bytes.

Inter-Integrated Circuit (I2C)

<!-- image -->

## 45.6.5.2 DMA mode, master reception

The following flowchart describes the exact operation for using a DMA controller to receive n data bytes from a slave. The CPU always transmits the first byte (the slave calling address) and the last two bytes. The DMA controller can read all other data bytes.

Inter-Integrated Circuit (I2C)

<!-- image -->

## 45.6.5.3 Exiting DMA mode and system requirement considerations

As described above, the CPU must request an interrupt to process the last few bytes of a TX or RX transfer. To change from DMA to interrupt-driven transfers in the I 2 C module, you must disable IBCR[DMAEN]. The trigger to exit the DMA mode is that the programmed DMA Transfer Control Descriptor (TCD) has completed all its transfers to/from the I 2 C module.

After the last DMA write (TX mode) to the I 2 C the module immediately starts the next I 2 C bus transfer. The same is true for receive mode. After the DMA read from the IBDR register the module initiates the next I 2 C bus transfer. This results in two possible scenarios in the DMA mode exiting scheme.

1. Fast reaction

IBCR[DMAEN] is cleared before the next I 2 C bus transfer completes. In this case, the I 2 C module raises an interrupt request to the CPU which can be serviced normally.

2. Slow reaction

Inter-Integrated Circuit (I2C)

IBCR[DMAEN] is cleared after the next I 2 C bus transfer has already completed. In this case, the I 2 C module does not raise an interrupt request to the CPU. Instead, IBSR[TCF] can be read to determine that the transfer completed and the I 2 C module is ready for further transfer.

What is fast/slow reaction?

The reaction time T R for the system to disable IBCR[DMAEN] after the last DMA controller access to the I 2 C is the time required for one byte transfer over the I 2 C. For a fast reaction, the disabling must occur before the 9 th  (ACK) bit of the data transfer. Therefore, the time available is eight times the SCL period.

In fast mode, with 400 kbit/s, T SCL is 2.5 s, so T R is 20 s.

Depending on the system and DMA controller there are different possibilities for the de-assertion of IBCR[DMAEN]. Three options are:

## 1. CPU intervention via interrupt

The DMA controller is programmed to signal an interrupt to the CPU. The CPU is then responsible for programming IBCR[DMAEN]=0. This scheme should be supported by most systems but it can result in a slow reaction time if other higher-priority interrupts interfere. Therefore, the interrupt handling routine can become complicated. This is because the routine must check which of the two cases happened (by checking IBSR[TCF]) and act accordingly. In case of a slow reaction, you can force an interrupt for the I 2 C in the interrupt controller to have the further transfer handled by the normal I 2 C interrupt routine.

## NOTE

The use of nested interrupts can still cause potential issues in this scenario, if someone tries to stall the DMA interrupt between the de-assertion and IBCR[DMAEN] and checks IBSR[TCF].

## 2. DMA channel linking

If the TCD in the DMA controller that performs the data transfer is linked to another channel that does a write to IBCR to disable the DMAEN field, this might probably be the fastest system solution, but it uses two DMA channels.

## NOTE

In this case, you must ensure-at the system level-that no higher-priority DMA requests occur between the two linked TCDs. Such requests could again create a scenario of slow reaction.

## 3. DMA scatter/gather process

If the TCD in the DMA controller that performs the data transfer has the scatter/gather feature activated, this feature initiates a reload of another TCD from system RAM after the completion of the first TCD. The new TCD will have its start bit already set and immediately start the required write to the IBCR to disable the DMAEN field. This TCD also has scatter/gather activated and is programmed to reload the initial TCD upon completion, bringing the system back into a "ready-for-I 2 C-transfer" state. The advantage over the two other solutions is that this requires neither CPU intervention nor a second DMA channel. This comes at the cost of 64 bytes RAM (two TCDs), some system bus transfer overhead, and a little increase in application code complexity.

## NOTE

Here you must ensure-at the system level-that no higher-priority DMA requests occur during the scatter/gather process. Such requests could again create a scenario of slow reaction.

Example latencies for a 32 MHz system with a full speed 32-bit AHB bus and an I 2 C connected via half-speed IPI bus:

- Accessing the I 2 C from the DMA controller via IPI bus typically requires four cycles (consecutive accesses to the I 2 C could be faster):

4TIPI = 4/16 MHz = 250 ns

- Reloading a new TCD (8 x 32-bit) via AHB to the DMA controller (scatter/gather process):

8TAHD = 8/32 MHz = 250 ns

Inter-Integrated Circuit (I2C)

Example latencies for a 150 MHz system with a full speed 32-bit AHB bus and an I 2 C connected via half speed IPI bus:

- Accessing the I 2 C from the DMA controller via IPI bus typically requires four cycles (consecutive accesses to the I 2 C could be faster):

4TIPI = 4/150 MHz = 26.6 ns

- Reloading a new TCD (4 x 64-bit) via AHB to the DMA controller (scatter/gather process):

<!-- formula-not-decoded -->

With the DMA scatter/gather process, the required IBCR access can finish in 0.5 s, leaving a large margin of 19.5 s for additional system delays. In this way, the slow reaction case can be prevented. You must decide which usage model best suits your overall requirement.

## Chapter 46 Gigabit Ethernet Media Access Controller (GMAC)

## 46.1 Chip-specific GMAC\_0 information

## 46.1.1 GMAC\_0 PHY mode selection

This table maps the following register field values to the PHY interface or mode they support.

## Table 309. GMAC\_0 PHY mode selection

| SRC_0.GMAC_0_CTRL_S TS[PHY_INTF_SEL]   | SRC_0.GMAC_0_CTRL_S TS[PHY_MODE]   | Fields in MAC_Configuration   | Fields in MAC_Configuration   | GMAC_0 PHY mode   |
|----------------------------------------|------------------------------------|-------------------------------|-------------------------------|-------------------|
| SRC_0.GMAC_0_CTRL_S TS[PHY_INTF_SEL]   | SRC_0.GMAC_0_CTRL_S TS[PHY_MODE]   | PS                            | FES                           | GMAC_0 PHY mode   |
| 000b                                   | 1                                  | 0                             | X                             | SGMII             |
| 000b                                   | 0                                  | 1                             | X                             | MII               |
| 001b                                   | 0                                  | X                             | X                             | RGMII             |
| 100b                                   | 0                                  | 1                             | X                             | RMII              |

## 46.1.2 GMAC reset sequence

GMAC and the chip exit the reset simultaneously.

Execute the following steps before using GMAC\_0.

| Do this                                                                        | By using                                                       |
|--------------------------------------------------------------------------------|----------------------------------------------------------------|
| 1. Select the PHY interface.                                                   | SRC_0.GMAC_0_CTRL_STS[PHY_INTF_SEL]                            |
| 2. Select the PHY mode.                                                        | SRC_0.GMAC_0_CTRL_STS[PHY_MODE]                                |
| 3. Assert the software reset to sample the PHY interface selection.            | GMAC_0_DMA_Mode[SWR]                                           |
| 4. Ensure that the software reset is complete.                                 | GMAC_0_DMA_Mode[SWR]                                           |
| 5. Select the Ethernet line speed and speed mode for the respective PHY modes. | MAC_Configuration[PS] and MAC_Configuration[FES], respectively |

## 46.1.3 GMAC limitations

## Table 310. GMAC limitations

| Function            | Limitation                                                                                                                                                                                                                                                                                                                                                                                                                             |
|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FTM trigger to GMAC | The GMAC_0 TS clock range is 5-200 MHz and FTM operates at a frequency of 80 MHz. GMAC_0 is triggered on the positive edge of a trigger pulse; therefore, the following FTM outputs are available for real-time application:  Generating the pulse output: Supported only when the GMAC_0 TS clock frequency is greater than the FTM clock frequency.  Setting the pulse output: Supported for all frequency ranges of the TS clock. |

Table continues on the next page...

Table 310. GMAC limitations (continued)

| Function            | Limitation                                                                                                                                                                                                             |
|---------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                     | Do not write 1 to SRC_0.GMAC_0_CTRL_STS[FTM0_SEL] and SRC_0.GMAC_0_CTRL_STS[FTM1_SEL]. NOTE                                                                                                                            |
| QoS support         | GMACsupports a 4-bit QoS; however, because NoCsupports only a 3-bit QoS, the upper bit of QoS drops. Therefore, for best performance, use DMA_CHn_Tx_Control[TQOS] to define the transmit QoS as 7 bits or fewer bits. |
| Media clock trigger | The frequency of the mcg_pst_trig_i signal must be in the range from 750 Hz-8 kHz.                                                                                                                                     |
| Burst length        | For best performance, write 0 to DMA_SysBus_Mode[BLEN32, BLEN64, BLEN128, BLEN256] to define the burst length for AXI transactions as 16 or less.                                                                      |

## NOTE

If Ethernet interrupts are enabled, write 01h or 02h to DMA\_Mode[INTM]. See GMACSUBSYSRM for details of this register and field.

## 46.1.4 Prerequisites for running GMAC in SGMII mode

GMAC supports a data rate of 1000 Mbps in SGMII mode over the GMII interface.

Before programming GMAC, perform the following procedure:

1. Write 1 to GMAC\_0\_CTRL\_STS[PHY\_MODE]. See GMACSUBSYSRM for details of this register and field.
2. Program SS\_RW\_REG\_0[SUBSYS\_MODE]. See S32G2SERDESRM for details of this register and field.
3. Deassert SerDes reset. See the S32G2SERDESRM for details.
4. Program the SerDes module. See the S32G2SERDESRM for details.

## 46.1.5 1588 timer interface signal connectivity

<!-- image -->

## 46.1.6 IO coherency configurations

For coherent accesses, you must program AxDOMAIN to inner or outer cacheable by configuring the registers AXI4\_Tx\_AR\_ACE\_Control, AXI4\_Rx\_AW\_ACE\_Control, and AXI4\_TxRx\_AWAR\_ACE\_Control. AxCACHE is don't care.

## 46.1.7 Availability of detailed documentation

GMAC subsystem details are provided in the GMAC Subsystem Reference Manual, document number GMACSUBSYSRM. Please contact your customer representative to obtain this document.

## 46.2 Introduction

## NOTE

The remaining sections in the chapter are Synopsys Proprietary. Used with permission.

GMAC enables a host application to transmit and receive data over an Ethernet network in compliance with IEEE 802.3-2015. GMAC supports 10/100/1000 Mbit/s [3]  applications.

Table 311. Terms and definitions

| Term         | Definition                                                                                                                                      |
|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| APB          | Advanced Peripheral Bus-An implementation of the Arm  AMBA  APB interface.                                                                    |
| AVB          | Audio Video Bridging-Transmission of audio and video signals over an Ethernet network.                                                          |
| AXI          | Advanced Extensible Interface-An implementationoftheArmAMBAAXIinterface.GMAChas an AXI master interface that connects to all GMAC DMA channels. |
| Backpressure | A mechanism for stalling reception of packets transmitted over an Ethernet network.                                                             |

Table continues on the next page...

[3] Supported PHY interface speeds vary per device

Table 311. Terms and definitions (continued)

| Term             | Definition                                                                                                                                        | Definition                                                                                                                                        |
|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| CRC              | Cyclic Redundancy Check-A calculation performed on received data packets used to detect corrupted data.                                           | Cyclic Redundancy Check-A calculation performed on received data packets used to detect corrupted data.                                           |
| DMA              | DirectMemoryAccess-HardwarewithinGMACthatenablesmovementofdatato/fromsystem memory with minimal intervention from the core.                       | DirectMemoryAccess-HardwarewithinGMACthatenablesmovementofdatato/fromsystem memory with minimal intervention from the core.                       |
| FIFO             | First In First Out-A type of data buffer from which data is retrieved in the same order in which it was stored in the buffer.                     | First In First Out-A type of data buffer from which data is retrieved in the same order in which it was stored in the buffer.                     |
| GMII             | Gigabit Media Independent Interface-A data interface and management interface that connects a MAC to a PHY, defining speeds of up to 1000 Mbit/s. | Gigabit Media Independent Interface-A data interface and management interface that connects a MAC to a PHY, defining speeds of up to 1000 Mbit/s. |
| IEEE 802.1AS-Rev | The enhanced IEEE standard for Timing and Synchronization for Time-Sensitive Applications (AVB, for example).                                     | The enhanced IEEE standard for Timing and Synchronization for Time-Sensitive Applications (AVB, for example).                                     |
| IEEE 802.1Q      | The IEEE standard for VLANs on an IEEE 802.3 Ethernet network.                                                                                    | The IEEE standard for VLANs on an IEEE 802.3 Ethernet network.                                                                                    |
| IEEE 802.1Qbu    | An amendment to the IEEE 802.1Q standard that supports frame preemption.                                                                          | An amendment to the IEEE 802.1Q standard that supports frame preemption.                                                                          |
| IEEE 802.1Qbv    | An amendment to the IEEE 802.1Q standard that supports scheduled traffic.                                                                         | An amendment to the IEEE 802.1Q standard that supports scheduled traffic.                                                                         |
| IEEE 802.3-2015  | The IEEE standard that specifies Ethernet network operation.                                                                                      | The IEEE standard that specifies Ethernet network operation.                                                                                      |
| IPv4, IPv6       | Internet Protocol version n -Refers to versions of the Internet Protocol specification.                                                           | Internet Protocol version n -Refers to versions of the Internet Protocol specification.                                                           |
| Layer 3, Layer 4 | Refers to layers defined within the Open System Interconnection (OSI) model of networking. The layers are:                                        | Refers to layers defined within the Open System Interconnection (OSI) model of networking. The layers are:                                        |
| Layer 3, Layer 4 | Layer                                                                                                                                             | Name                                                                                                                                              |
| Layer 3, Layer 4 | 1                                                                                                                                                 | Physical                                                                                                                                          |
| Layer 3, Layer 4 | 2                                                                                                                                                 | Data Link                                                                                                                                         |
| Layer 3, Layer 4 | 3                                                                                                                                                 | Network                                                                                                                                           |
| Layer 3, Layer 4 | 4                                                                                                                                                 | Transport                                                                                                                                         |
| Layer 3, Layer 4 | 5                                                                                                                                                 | Session                                                                                                                                           |
| Layer 3, Layer 4 | 6                                                                                                                                                 | Presentation                                                                                                                                      |
| Layer 3, Layer 4 | 7                                                                                                                                                 | Application                                                                                                                                       |
| MAC              | Media Access Controller-Refers to the data-link layer defined by the IEEE 802.3 standard.                                                         | Media Access Controller-Refers to the data-link layer defined by the IEEE 802.3 standard.                                                         |
| MDIO             | Management Data Input/Output-A serial interface used for PHY configuration.                                                                       | Management Data Input/Output-A serial interface used for PHY configuration.                                                                       |
| MII              | Media Independent Interface-A data interface and management interface that connects a MAC to a PHY. The IEEE 802.3 standard defines it..          | Media Independent Interface-A data interface and management interface that connects a MAC to a PHY. The IEEE 802.3 standard defines it..          |
| MTL              | MACTranslation Layer-The GMACcomponent that contains the receive and transmit FIFOs.                                                              | MACTranslation Layer-The GMACcomponent that contains the receive and transmit FIFOs.                                                              |
| Pause packet     | Refers to a mechanism defined by the IEEE 802.3x standard, used to request a temporary halt to data transmission on an Ethernet network.          | Refers to a mechanism defined by the IEEE 802.3x standard, used to request a temporary halt to data transmission on an Ethernet network.          |
| PHY              | The physical interface transceiver that implements the OSI physical layer for an Ethernet network. The IEEE 802.3 standard defines it.            | The physical interface transceiver that implements the OSI physical layer for an Ethernet network. The IEEE 802.3 standard defines it.            |

Table continues on the next page...

Table 311. Terms and definitions (continued)

| Term   | Definition                                                                                                                                                            |
|--------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| RGMII  | Reduced Gigabit Media Independent Interface-A GMII specification that has a reduced pin count.                                                                        |
| RMII   | Reduced Media Independent Interface-An MII specification with a reduced number of signals.                                                                            |
| RMON   | Remote Network Monitoring-An extension of the Simple Network Management Protocol (SNMP) that enables monitoring of Ethernet network statistics.                       |
| Rx     | Receive                                                                                                                                                               |
| SFD    | Start Frame Delimiter-A field within an Ethernet frame.                                                                                                               |
| SGMII  | Serial Gigabit Media Independent Interface-A variant of the GMII that has a reduced pin count and lower power consumption.                                            |
| TCP    | Transmission Control Protocol-A network protocol that provides a mechanism for transmitting and receiving an ordered and error-checked stream of information packets. |
| Tx     | Transmit                                                                                                                                                              |
| UDP    | User Datagram Protocol-A network protocol that provides higher speeds than TCP but does not include error checking.                                                   |
| VLAN   | Virtual Local Area Network.                                                                                                                                           |

## 46.3 Features

In addition to the default features defined in the IEEE 802.3 specifications, GMAC supports the following:

- MII (10/100/200 Mbit/s), RMII (10/100 Mbit/s), RGMII (100/1000 Mbit/s)
- GMII to support SGMII (1000 Mbps)
- Time Aware Shaper (IEEE 802.1Qbv), Time Synchronization (IEEE 802.1AS-Rev), and Frame Preemption (IEEE 802.1Qbu) for time-sensitive networking
- Media clock recovery and generation for AVB
- AXI4 master and APB3 slave
- RMII specification version 1.2 from RMII consortium
- RGMII specification version 2.6 from HP/Marvell
- Separate interfaces for transmit, receive, and control paths
- Full-duplex flow control operations (IEEE 802.3x pause packet and priority flow control)
- Network statistics with RMON counters
- Flexibility to control Pulse per Second (PPS) output signals and support for auxiliary snapshot input signals
- Ethernet packet timestamping as described in IEEE 1588-2002 and IEEE 1588-2008 (64-bit timestamps given in the transmit or receive status of PTP packet) (both one-step and two-step timestamping are supported in transmit direction)
- MDIO (clause 22 and clause 45) interface for configuration and management of the PHY
- Preamble and start of packet data (SFD) insertion/deletion
- Automatic CRC and pad generation/stripping option, with an option to disable CRC checking
- Programmable interpacket gap
- Source address insertion/replacement, VLAN insertion, replacement, and deletion in transmitted packets with per-packet or static-global control IEEE 802.1Q VLAN tag detection, and option to delete in received packets

Gigabit Ethernet Media Access Controller (GMAC)

- Programmable safety watchdog timeout limits
- Flexible address filtering modes:
- Up to 1 additional 48-bit perfect destination address filters with masks for each byte
- Up to one 48-bit source address comparison check with masks for each byte
- Optional 256-bit hash filter for multicast and unicast destination addresses
- Option to pass all multicast addressed packets
- Promiscuous mode to pass all packets without any filtering for network monitoring
- Pass all incoming packets (as per filter) with a status report
- Additional packet filtering:
- VLAN tag-based: Perfect match and optional hash-based filtering (filtering can be based on either outer or inner VLAN tag)
- Layer 3 and Layer 4-based TCP or UDP over IPv4 or IPv6
- Extended VLAN tag based filtering-32 filter selections
- Programmable lookup-table-based flexible parser for filtering and steering received packets

## 46.4 Architecture

The following figure is a system-level block diagram of GMAC.

<!-- image -->

Gigabit Ethernet Media Access Controller (GMAC)

Table 312. Block diagram components

| Component                                    | Function                                                                                                                                                                  | See                           |
|----------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|
| AXI interface                                | High-performance point-to-point interconnect                                                                                                                              | Interfaces                    |
| APB interface                                | Low-bandwidth interface                                                                                                                                                   | -                             |
| CSR                                          | GMAC Control and Status Registers (CSRs) provide an interface for software to manage:  Transmit and receive functions  DMA descriptors  Interrupt generation           | -                             |
| DMA arbiter                                  | Provides arbitration for both transmit and receive for all GMAC DMA channels                                                                                              | -                             |
| DMA controller                               | Manages data transfer operations                                                                                                                                          | DMA controller                |
| Interrupt block (not shown in block diagram) | Manages interrupt functions.                                                                                                                                              | Interrupts                    |
| MAC (Core + PHY)                             | Transmits data to the PHY and provides status.                                                                                                                            | Media Access Controller (MAC) |
| MAC Transaction Layer (MTL)                  | Manages transmit and receive FIFOs.                                                                                                                                       | MAC Transaction Layer (MTL)   |
| PHY interfaces                               | Supported interfaces include:  MII 10/100/200 Mbit/s interface  RMII 10/100 Mbit/s interface  RGMII 100/1000 Mbit/s interface  SGMII 1000 Mbps through GMII interface | Interfaces                    |

## 46.4.1 Interfaces

GMAC supports the following interfaces:

- AXI
- PHY interfaces.

The AXI interface connects to the chip's AXI master interface. It provides the path for transferring data to and from system memory.

The PHY supports the following interfaces, which you can use alone or in combination:

- Media Independent Interface (MII)
- Reduced GMII (RGMII)
- Serial GMII (SGMII) supported through GMII.

## 46.4.2 DMA controller

The GMAC DMA controller includes:

- Independent transmit and receive engines:
- The transmit engine transfers data from system memory to the device port (MTL).
- The receive engine transfers data from the device port to system memory.

- Control and status registers.

Based on data transfer profiles contained in DMA descriptors, the GMAC DMA controller efficiently moves data from source to destination with minimal intervention from the application core.

## 46.4.3 MAC Transaction Layer (MTL)

The MAC Transaction Layer (MTL) provides a FIFO memory interface to buffer and regulate packets being transferred between system memory and the MAC. It also enables data to be transferred between the application clock domain and the MAC clock domain. The MTL has two data paths-a transmit path and a receive path. The data path for each can be 64-bit wide.

## 46.4.4 Media Access Controller (MAC)

The MAC transmits data to the PHY and, when a transmission completes, provides the transmission status to the MTL. When the MAC detects a Start Frame Delimiter (SFD) on the interface, it begins receiving data from the PHY. The MAC also verifies the integrity of the transmitted packet via CRC and drops any packet that fails the CRC check.

## 46.4.5 Interrupts

Application software can configure GMAC to trigger interrupts based on events captured in status registers. You can independently enable or disable interrupt generation for each interrupt source. GMAC can generate interrupts from events associated with:

- MAC
- MTL
- GMAC DMA.

## 46.5 Transmit and receive FIFOs

The transmit FIFO buffers data transferred from the application to GMAC. Similarly, the receive FIFO stores packets received from the network interface until they are transferred to the application. Both FIFOs are asynchronous because they also transfer data between the application clock and the MAC line clock domains.

## 46.6 Flow control

GMAC supports Full-Duplex and Half-Duplex mode packet flow control for transmit operation, and full-duplex packet flow control for receive operation.

Transmit packet flow control involves transmitting pause packets in Full-Duplex mode and backpressure in Half-Duplex mode to control the flow of packets from the remote end.

Receive packet flow control is functional only in Full-Duplex mode. GMAC treats any pause packet received as a normal control packet.

## 46.7 Double VLAN tagging

This feature enables the MAC to process two VLAN tags, and supports:

- Insertion, replacement, or deletion of up to two VLAN tags in the transmit path
- Packet filtering and stripping based on either one of the two VLAN tags in the receive path
- Stripping and providing up to two VLAN tags in the receive path as a part of the receive status.

## 46.8 Descriptors

The GMAC DMA controller transfers data based on a ring of descriptors. Application software creates the descriptors in system memory. GMAC supports the following types of descriptors:

Gigabit Ethernet Media Access Controller (GMAC)

Gigabit Ethernet Media Access Controller (GMAC)

- A normal descriptor is used for packet data and provides control information for packets to be transmitted.
- A context descriptor provides control information for a packet to be transmitted.

Each normal descriptor contains two buffers and two address pointers. The buffers enable the adapter port to be compatible with various types of memory management schemes.

## 46.8.1 Descriptor structure

GMAC supports a ring structure for DMA descriptors as shown in the following figure. The Descriptor Tail Pointer register contains the pointer to the descriptor address (N). The base address of the descriptor ring and the Current Descriptor Pointer determine the address of the current descriptor that the GMAC DMA controller can process. The GMAC DMA controller has ownership of the descriptors up to the location before the one specified by the Descriptor Tail Pointer (N - 1). The GMAC DMA controller continues to process the descriptors until Current Descriptor Pointer == Descriptor Tail Pointer.

<!-- image -->

## 46.8.2 Transmit descriptor

The GMAC DMA controller requires at least one descriptor for a transmit packet. In addition to two buffers, two byte-count buffers, and two address pointers, the transmit descriptor contains fields that control MAC operation on a per-transmit packet basis.

## 46.8.3 Receive descriptor

The GMAC DMA controller attempts to read a descriptor only if the Descriptor Tail Pointer is not equal to the descriptor ring base address or the Current Descriptor Pointer. We recommend that you have a descriptor ring with a length that can accommodate at least two complete packets received by the MAC. Otherwise, the unavailability of the descriptors significantly degrades DMA performance. In this scenario, the receive FIFO in the MTL becomes full and starts dropping packets.

GMAC supports the following types of receive descriptors:

- Normal descriptors
- Context descriptors

Gigabit Ethernet Media Access Controller (GMAC)

Application software creates all receive descriptors. The GMAC DMA controller treats them as Normal descriptors. The GMAC DMA controller:

1. Reads a descriptor.
2. Transfers all or part of a received packet to the buffers pointed to by the descriptor.
3. Closes the descriptor with the appropriate packet status.

The configuration data within a Normal descriptor is insufficient for writing a complete status for some packets. In this case, the GMAC DMA controller writes the extended status to the next descriptor, without processing the buffers or pointers contained in the descriptor. The format and content of the descriptor is that of a Context descriptor.

## 46.9 Functional description

Prior to using GMAC functions, application software must perform configuration tasks to ensure proper operation:

- Configure the appropriate GMAC control and status registers for the desired behavior.
- Initialize the receive and transmit DMA descriptors. Among other options, software must provide the descriptors with pointers to the buffers where the GMAC DMA controller will transfer the data to/from.
- When application software transfers data via GMAC, it must manage the DMA descriptors:
- When GMAC receives one or more packets, the GMAC DMA controller transfers the data to buffers. Software must update the descriptors, including a new buffer address.
- When application software transmits data, it must:
- Update the transmit DMA descriptor(s) with the desired buffer addresses.
- Advance the Descriptor Tail Pointer.
- Set the appropriate ownership field (also called the "OWN bit") to 1.

The GMAC DMA controller then begins transferring the data until the Current Descriptor Pointer and Descriptor Tail Pointer values are equal or the descriptor is marked as owned by the application.

During chip operation, application software uses GMAC functions to transfer data between the application and network as detailed below:

- Transmitting data:
1. The GMAC DMA controller transfers data from the application buffer to the MTL transmit FIFO.
2. The MAC transfers packets to the PHY via the selected interface-RGMII, for example.
- Receiving data:
1. When the MAC receives a packet from the PHY, it saves it to the MTL receive FIFO.
2. The GMAC DMA controller transfers the data from the receive FIFO to the application buffer.

## 46.10 Availability of detailed documentation

Details of the GMAC subsystem are provided in the  GMAC Subsystem Reference Manual, document number GMACSUBSYSRM. Please contact your customer representative to obtain this document.

## Chapter 47 Packet Forwarding Engine (PFE)

## 47.1 Introduction

PFE offloads the processing of Ethernet packets from the host cores, yielding higher performance and lower power than pure software processing can achieve. PFE is capable of 2 Gbit/s packet forwarding even at small packet sizes, with virtually no host core load.

## 47.2 Features

- Three Ethernet ports (PFE\_MAC0, PFE\_MAC1 and PFE\_MAC2)
- Performs the IEEE 802.3 protocol for 10/100/1000
- MII: 10/100 Mbit/s
- RMII: 10/100 Mbit/s
- RGMII: 100/1000 Mbit/s
- SGMII: 100/1000 Mbit/s
- PFE\_MAC0 also supports 2.5 Gbit/s SGMII. When this mode is enabled, PFE\_MAC1 must be used in RGMII/RMII/MII mode if enabled.
- Supports packet sizes from 64 bytes up to 1522 bytes
- Capable of autonomously handling all packets belonging to a given stream, without host core intervention, following stream creation
- Capable of performing slow-path or fast-path processing of a packet
- Capable of addressing DDR, security co-processor (HSE\_H), and internal on-chip memory.

## NOTE

PFE can only access the memory space below C000\_0000h.

- Capable of routing/bridging an aggregate of 2 Gbit/s of traffic with a 64 byte packet size. Higher rates are achievable for larger packet sizes.
- Supports packet parsing based on standard L2/3/4 header fields or using a flexible parser to take forwarding decisions based on proprietary fields up to 208 bytes from start of frame
- Supports 802.1AS-Rev and IEEE 1588 precision clock synchronization protocol
- Supports one-step and two-step timestamping
- Full-duplex flow control with recognition of incoming pause frames and hardware generation of transmitted pause frames
- VLAN packet identification and tagging
- Quality of Service (QoS)
- On transmit, implements flexible configuration of shapers and schedulers
- Support for credit based shaper algorithm
- On receive, supports ingress QoS
- Classification of packets to be managed / unmanaged / reserved traffic
- Weighted Random Early Drop (WRED)
- Ingress port based rate shaper

- Four channel DMA host interface for slow path traffic
- Embedded DMA engine
- Interrupt per channel
- Supports interrupt coalescing
- Independent MDIO interface per MAC

## 47.3 Initialization

PFE is a firmware-based module. Load the firmware before using PFE. The PFE cores boot during initialization by the host core. After initialization completes, PFE moves to Normal mode and is ready for full operation. The NXP-provided host interface driver and the PFE firmware abstract the initialization.

## 47.4 Programming considerations

Here are the details of the platform setup before loading the PFE driver.

1. Set MAC interface modes as per the use-case by writing into the PFE\_EMACX\_INTF\_SEL register. This register is described in the System Resource Controller (SRC\_1) chapter.
2. IO configuration and routing: Configure the interface pins for each MAC to be used.
3. Clocking:
- a. Enable ACCELL\_PLL for PFE\_PE\_CLK and PFE\_SYS\_CLK as described in the "PFE clocking" section in this document. The only supported frequency for PFE \_PE\_CLK is 600 MHz.
- b. Configure the MAC interfaces clocking as described in sections, "PFE\_MAC\_0 clocking overview", "PFE\_MAC\_1 clocking overview", and "PFE\_MAC\_2 clocking overview".

## NOTE

For SGMII use case, the SerDes initialization must be done. You can trigger SerDes initialization and PFE initialization independently. However, SerDes initialization completion is a prerequisite for completing PFE initialization (MAC clock configurations). For SerDes initialization and mode specific configuration, see the chapter SerDes Subsystem and the steps described in the SerDes Subsystem Reference Manual.

- c. For PTP use-cases, enable GMAC\_TS\_CLK. See the S32G2 Data Sheet for the clock range. The recommended frequency is 100 MHz.
4. For Cortex-A53 core specific applications, configure coherency for PFE (see the PFE\_COH\_EN register's details in the Main General Purpose Registers (Main GPRs) chapter) and platform (see the Ncore chapter). Currently, only supported configurations are:
- DDR - Disabled
- HIF0 - HIF4 - Enabled
- Util - Disabled
5. Partition reset and clocking enable:
- a. Enable PFE COFB clocks in MC\_ME as described in the "MC\_ME partition 2 mapping" section in this document.
- b. Enable partition 1.
- c. Follow the steps as described in the "Software reset partition turn-on flowchart" section in this document.
6. Load the PFE driver.

## 47.5 Functional description

PFE is based on programmable packet processing engines (PE).

Packet Forwarding Engine (PFE)

Packet Forwarding Engine (PFE)

PFE implements a fast-path/slow-path architecture. Fast-path packets can be completely offloaded from host core processing. Slow-path packets (such as control packets) can handle packet processing on the host cores.

The classification module classifies and performs header modification tasks, such as network address translation (NAT). The classifier performs traffic management and also maintains packet counters for statistics.

## 47.6 Packet parsing

The classifier has many different options for parsing of the packets such as:

- VLAN
- Multicast
- Broadcast
- ARP
- IPv4
- IPv6
- UDP
- TCP
- ICMP

The parsing block parses each packet and uses a handshake mechanism to provide inputs to the PFE processing engines. Firmware then processes the packet routing.

## 47.7 Layer 2 parsing

The first step in the packet classifier module is the Layer 2 classification. The link layer headers (VLAN, and so on) of the packet are parsed and information is saved into the packet buffer's header structure. If the link layer header is unknown, the packet is marked with a special flag and sent to the slow path for proper processing. After parsing, the packet is sent to bridge processing if bridging is enabled. Otherwise, the packet is sent to route processing.

The MAC lookup table memory is divided between Normal Space and Collision Space of 256 entries each. A new entry is added to normal/hash space if the computed hash is unique, if not, the entry gets added to the collision space. As a result, a maximum of 512 MAC lookup entries are possible in the best-case scenario.

## 47.8 Bridge classifier

This module performs the following actions:

- Processes the packet after Layer-2 parsing
- Uses bridge groups and port related information
- Uses a bridge MAC address table for MAC destination address lookup to forward the packets onto transmit bridge ports
- Performs lookups of the source MAC address for learning and aging support
- Sends the packet to the slow path for processing if no matched entries are found as part of the lookup.

## 47.9 Layer 3 parsing

In route mode, the module looks into Layer 3 and Layer 4 protocol headers of the packet and updates the packet buffer header structure with the parsed information. The route classifier module uses the flow information extracted from the packet to decide which action to take. This module also performs:

- IP version check
- IP packet length check

- IP checksum verification
- Fragment packet identification
- Unknown layer 4 protocols
- TCP flags (SYN, FIN, RST )
- Identification of IPSec tunnel and transport headers

## 47.10 Route classifier

This module performs the following actions on the packet:

- Hash calculation using specific header fields
- Lookup in the route hash table to match with flow entry
- If no entry is matched, then send the packet to host for slow-path processing
- TTL decrement and increment checksum update
- Perform NAT processing if required
- Construct TX port related link layer headers
- Send the packet to the traffic manager unit

## 47.11 Queuing block

The queuing block:

- Takes packets and schedules them for the processing blocks
- Moves packet headers from internal/external memory to the PE data memory
- Tags the packets with a sequence number that is used to maintain packet ordering within the module

## 47.12 Traffic manager unit

Traffic manager unit implements the QoS functionality in the egress packet processing chain. The classifier sends the packets to the traffic manager unit after the packet is classified and modified. The classifier determines the queue mapping for the packet. The module works closely with the peripheral blocks and schedules the packets for transmission. The traffic manager unit has programmable queuing disciplines (WRR, WFQ or PQ) for implementing QoS.

The unit has weights (and credits) for guaranteed service and for distribution of the available bandwidths with the following features:

- Eight classes queues per port
- Programmable weights, scheduler tick, and max credits per class

In the case of multicast traffic, multiple references to the same buffer are written to the traffic manager unit and it processes them independently. The traffic manager unit contains four shaper units that implement a credit-based shaper algorithm. Association of a shaper to a queue/scheduler is not fixed in hardware, but is maintained by a software.

## 47.13 Buffer management

The buffer management module allocates and de-allocates buffers for the packets. Its structure is very generic and amenable to any operating system. The buffer allocation and freeing is managed within the buffer pool without calling time-consuming memory-allocation and memory-freeing functions for every packet.

Packet Forwarding Engine (PFE)

## 47.14 Host Interface (HIF)

The chip host cores transmit and receive packets via the PFE HIF. HIF has a built-in DMA controller that transfers the slow-path packets to/from the host cores. HIF supports chained buffer descriptors (BD). The host software prepares the buffer descriptors, allocates associated buffers, and chains the descriptors. Host software ensures that invalid buffer descriptors have their descriptor enable bit set to zero so that they are not processed erroneously. The end of the BD chain always has a BD with a descriptor-enable bit equal to 0. The host interface has four virtual channels to allow distribution of packets across multiple host cores. Each virtual channel has its own RX/TX buffer descriptor rings and also a dedicated interrupt signal to generate events on the host cores. See the chip interrupt mapping for details.

HIF implements interrupt coalescing. You can enable coalescing based on frame count and on a timer. If you enable only timer-based coalescing, PFE generates a coalesce interrupt after the timer reaches its value. If you enable only frame-based coalescing, PFE generates a coalesce interrupt after the number of interrupts equals the frame counter. If you enable both types of coalescing, PFE generates an interrupt when either of the previously-mentioned conditions is true.

## 47.15 PHY interface options

You have various pin-muxing options available to support a wide range of PHY interface modes and port numbers. For details on pin multiplexing options, see the IOMUX spreadsheet attached to this document.

## 47.16 PFE configuration

The software solutions described in the following sections abstract the PFE programming.

These software solutions allow configuration of the following features:

- IPv4/IPv6 forwarder/router
- NAPT
- IPSec offload
- Configuration API
- L2 bridging
- VLAN support
- VLAN table control API
- MAC table control API
- Port control API
- QoS control API
- Statistics

## 47.17 Software components

The PFE driver loads into the OS networking stack and provides access to PFE Ethernet interfaces. The driver supports basic networking functions such as:

- Frame transmission
- Frame reception
- Link status monitoring

Offload functions, including forwarding of Ethernet packets without host core intervention and QoS, are also implemented as part of the API.

For further details on the PFE software support (CMM and LibFCI), see the PFE software product brief and Fast Control Interface (FCI) API reference documents.

Packet Forwarding Engine (PFE)

## Chapter 48 LINFlexD

## 48.1 Chip-specific LINFlexD information

## 48.1.1 Filter and channel configuration

## Table 313. Filter and channel configuration

| Feature                                        | LINFlexD_0   | LINFlexD_1   | LINFlexD_2   |
|------------------------------------------------|--------------|--------------|--------------|
| Number of filters (no_of_filters)              | 0            | 0            | 0            |
| Number of transmit DMA channels (2 TX_CH_NUM ) | 1            | 1            | 1            |
| Number of receive DMA channels (2 RX_CH_NUM )  | 1            | 1            | 1            |
| Slave mode                                     | Enabled      | Enabled      | Enabled      |
| UART mode                                      | Enabled      | Enabled      | Enabled      |
| Auto synchronization                           | Disabled     | Disabled     | Disabled     |
| DMA support                                    | Available    | Available    | Available    |

## 48.1.2 LIN\_CLK and bus clock relationship

PBRIDGEn\_CLK = LIN\_CLK  2

## 48.1.3 Chip-specific reset value of LINSR[RDI]

LINSR[RDI] indicates the current status of the receive pin. Before using LINFlexD, you must drive the Rx pin to 0.

NOTE

The reset value of LINSR[RDI] is mentioned as 1 in the "LINFlexD register descriptions" section. However, the reset value is undefined.

## 48.1.4 Chip-specific reset value of LINSR[WUF]

LINSR[WUF] indicates the wake-up flag. LINFlexD sets this flag when LINFlexD detects a falling edge on the receive pin. As part of initialization, you must clear the flag.

## 48.2 Introduction

LINFlexD manages a high number of LIN messages efficiently with a minimum of CPU load. To reduce the CPU loading in Master mode, LINFlexD autonomously handles the LIN messages after you have triggered the header transmission, until the next header transmission request in transmitter mode or until checksum reception in the receiver mode.

## LINFlexD:

- Supports LIN protocol version 1.3
- Provides an 8-byte buffer for transmission/reception data
- Supports some of the basic UART transfers of 8-bit, 9-bit frames
- Supports multichannel and parametric DMA Tx/Rx interface in LIN/UART operating mode

## 48.2.1 Block diagram

<!-- image -->

## Notes:

1. The value of n depends on the no\_of\_filters parameter. See the chip-specific LINFlexD information for the value of no\_of\_filters used in this chip.
2. For LIN mode N = 16; you can program N in UART mode.
3. You cannot use FBRR when you enabled reduced oversampling in UART mode.

## 48.3 Main features

LINFlexD can operate in several modes, each of which has a distinct set of features that are described in the following sections. In addition, LINFlexD has several features common to all modes:

- Fractional baud rate generator

- Three operating modes for power saving and configuration registers lock:
- Initialization
- Normal
- Sleep
- Loop Back test mode
- Maskable interrupts

## 48.3.1 LIN mode features

- Supports these LIN protocol versions:
- 1.3
- 2.0
- 2.1
- Bit rates up to 20 Kbit/s (LIN protocol)
- Master or Slave modes
- Classic and enhanced checksum calculation and check
- Single 8-byte buffer or FIFO for transmission and reception
- Timeout management
- DMA interface
- Master mode with autonomous message handling
- Wake-up event on dominant bit detection
- True LIN field state machine
- Advanced LIN error detection
- Header, response, and frame timeout
- Slave mode
- Autonomous header handling
- Autonomous transmit and receive data handling

## 48.3.2 UART mode features

- Full-duplex communication
- Baud rate is a function of baud clock, LIN Integer Baud Rate Register (LINIBRR), and LIN Fractional Baud Rate Register (LINFBRR). See Baud rate generation for details.
- 7/8 bits data, parity
- 1/2/3 stop bits
- 4-byte buffer for reception
- 4-byte buffer for transmission
- 12-bit counter for timeout management
- For bit rate  LIN\_CLK/16 Mbit/s:
- 16 times oversampling
- 3:1 majority voting

LINFlexD

- For LIN\_CLK/16 Mbit/s &lt; bit rate  LIN\_CLK/8 Mbit/s:
- User-programmable reduced oversampling
- 3:1 majority voting for reduced oversampling of 8 samples per bit
- For LIN\_CLK/8 Mbit/s &lt; bit rate  LIN\_CLK/4 Mbit/s
- User-programmable reduced oversampling
- 1:1 voting for all reduced oversampling of 4, 5, and 6 samples per bit

## 48.4 Functional description

## 48.4.1 LIN protocol

LIN is a serial communication protocol. A LIN cluster consists of one master task and several slave tasks. A master node contains the master task as well as a slave task. All other nodes contain only a slave task. The master node decides when and which frame is transferred on the bus. The slave task provides the data that the frame transports.

## 48.4.1.1 Frames

A frame consists of:

- A header, which the master task provides.
- A response, which the slave task provides.

The header consists of a break, a sync pattern, and an identifier. The sync pattern follows the break, and the identifier follows the sync pattern. The slave task associated with the identifier provides the response. The response consists of a data field and checksum. The slave task designated to receive the data associated with the identifier receives the response and verifies the checksum.

Figure 392 and Figure 393 show how transmission or reception of LIN frames occurs.

<!-- image -->

## 48.4.1.2 Data field

The following figure shows the structure of the byte field that nodes and tasks use to transmit each byte. The LSB of the data is sent first and the MSB is sent last. The start bit is encoded as a bit with value zero (dominant) and the stop bit is encoded as bit value one (recessive).

LINFlexD

LINFlexD

<!-- image -->

## 48.4.1.3 Break field

The break field indicates the beginning of a new frame. It is the only field that does not comply with Data field. Only the master generates the break. The break must be at least 13 bits of dominant value including the start bit, followed by a break delimiter as shown in the following figure. The break delimiter be two bits in length to comply with LIN protocol 2.1.

<!-- image -->

## 48.4.1.4 Sync field

The following figure shows the sync field. This is a byte field with the data value of 55h.

<!-- image -->

## 48.4.1.5 Identifier field

The following figure shows the identifier field. This field consists of two subfields-the identifier and the identifier parity. Bits 0 to 5 are the identifier and bits 6 and 7 indicate the parity.

<!-- image -->

P0 = ID0 XOR ID1 XOR ID2 XOR ID4

P1 = NOT (ID1 XOR ID3 XOR ID4 XOR ID5)

## 48.4.1.6 Checksum

The last field of a frame is the checksum. The checksum contains the inverted 8-bit sum with carryover of all data bytes and the identifier. The following table shows the types of checksums.

Table 314. Checksum types

| Type     | Bytes used                               | Use                               |
|----------|------------------------------------------|-----------------------------------|
| Classic  | Only the data bytes                      | Communication with LIN 1.3 slaves |
| Enhanced | Data bytes and protected identifier byte | Communication with LIN 2.0 slaves |

## 48.4.2 LINFlexD features

## 48.4.2.1 Operating modes

LINFlexD includes these operating modes:

- Initialization (INIT)
- Normal (NM)
- Sleep (SM)

After a hardware reset, LINFlexD enters SM to reduce power consumption.

Figure 398 shows the state diagram of operating modes.

<!-- image -->

## 48.4.2.1.1 INITM

To enter or exit INITM, write 1 or 0, respectively, to LINCR1[INIT].

Use this mode only to configure LINFlexD. Do not initiate a data transmission in INITM.

When in INITM, LINFlexD stops all message transfers to and from the LIN bus and the status of LIN bus output LINTX is recessive (high). If you attempt to enter INITM when a bus transfer is in progress, LINFlexD aborts the transfer. Therefore, you must check the LIN state before writing 1 to LINCR1[INIT].

To initialize LINFlexD, you must:

1. Set up the baud rate registers.
2. Write 0 to UARTCR[UART].
3. Select the mode (Master or Slave).
4. Configure checksum control bits.

## 48.4.2.1.2 NM

After you initialize LINFlexD, you can enter NM by writing 0 to LINCR[INIT].

## 48.4.2.1.3 SM

To enter or exit this mode, write 1 or 0, respectively, to LINCR1[SLEEP].

This mode reduces power consumption. In this mode, the LINFlexD clock stops.

If you detect a wakeup pulse of 150 s on the LIN bus, you can request LINFlexD to wake up from SM. See Wakeup management.

## 48.4.2.2 STOP mode

This mode allows the software to put the LinflexD module in power-down state. After the LinflexD module receives a module-stop signal at the module's boundary, it completes all ongoing transactions and comes to a graceful halt.

As soon as the LinflexD module enters STOP mode:

- No transaction can take place as both transmitter and receiver are in IDLE mode.
- All registers are inaccessible.

The LinflexD module enters this mode only after successfully completing the current ongoing transaction. Hence the power-down request is acknowledged once the STOP condition occurs. To request STOP for ongoing transmission, you must wait until the transmission is complete.

See the figure below for more details:

180,000 ns

160,000 ns

140,000 ns

120,000 ns

100,000 ns

80,000 ns

60,000 ns

40,000 ns

20,000 ns

0

ipg\_stop

ipg\_stop\_ack

ipp\_do\_lintx

ipg\_ind\_linrx

Figure 399.

LINFlexD Stop mode behavior when transmitter is sending data bits

<!-- image -->

## 48.4.2.3 Test modes

## 48.4.2.3.1 Loop Back mode

You can use this mode for self-test functions.

Enter this mode by writing 1 to LINCR1[LBKM].

In this mode, LINFlexD:

- Receives the identifier and data that LINFlexD itself transmits.
- Writes the identifier and data to Buffer Identifier Register (BIDR) and data buffers, respectively.
- Checks bit errors.
- Ignores the LINRX signal.
- Feeds back its TX output to its RX input.

You can disconnect the TX pin from the LINTX pin using a setting in SIUL2.

LINFlexD

Figure 400. LINFlexD in Loop Back mode

## 48.4.2.4 Master mode

Enter this mode by writing 1 to LINCR1[MME].

## 48.4.2.4.1 Header transmission

According to the LIN protocol, the master triggers any communication on the LIN bus by sending a header. The master task of a node transmits the header. The slave task of a node transmits the response.

To transmit the header:

1. Use Buffer Identifier Register (BIDR) to program:
- The identifier.
- The data field length.
- The message direction.
- The checksum enable.
2. Write 1 to LINCR2[HTRQ].

After header transmission starts, do not modify the BIDR fields until the current frame completes.

The master node receives the transmitted ID and copies it to BIDR.

## 48.4.2.4.2 Data transmission

Consider the scenario in which the master sends an identifier and the master node publishes the data corresponding to that identifier. In this scenario, the node's slave task must send the data in the response part of the frame. Therefore, you must provide the data to LINFlexD before LINFlexD requests the header transmission.

LINFlexD stores the to-be-transmitted data in the Buffer Data Register Least Significant (BDRL) and Buffer Data Register Most Significant (BDRM) registers which are used as message buffers during data transmission. Both Buffer Data Register Least Significant (BDRL) and Buffer Data Register Most Significant (BDRM) are 32-bit registers which are further grouped as eight Buffer Data Registers BDRn (n= 0,1,2,...,7) to hold data for transmission and reception, for details see Table 315. The number of to-be-transmitted bytes depends on BIDR[DFL]. You must use BIDR[CCS] to configure the checksum type (classic or enhanced) for each message.

Table 315. Register grouping

| Registers   | Grouping   |
|-------------|------------|
| BDRL[7:0]   | BDR0       |
| BDRL[15:8]  | BDR1       |

Table continues on the next page...

<!-- image -->

LINFlexD

Table 315. Register grouping (continued)

| Registers   | Grouping   |
|-------------|------------|
| BDRL[23:16] | BDR2       |
| BDRL[31:24] | BDR3       |
| BDRM[7:0]   | BDR4       |
| BDRM[15:8]  | BDR5       |
| BDRM[23:16] | BDR6       |
| BDRM[31:24] | BDR7       |

If LINFlexD successfully sends the response, LINFlexD sets the Data Transmission Completed flag (LINSR[DTF]). If an error occurs, LINFlexD:

- Does not set the Data Transmission Completed flag.
- Sets the corresponding error flag in LIN Error Status Register (LINESR) (see Errors for details).

BIDR[DIR] determines the direction of the message buffer. The same node also receives the transmitted data and copies the data to the buffer.

## 48.4.2.4.3 Data reception

To receive data from a slave node, the master sends a header with the corresponding identifier. LINFlexD then:

- Receives data from the slave.
- Stores the data in the message buffer.
- Stores the status of the message in LIN Error Status Register (LINESR).

If LINFlexD successfully receives the response, LINFlexD sets the LINSR[DRF] flag.

If an error occurs, LINFlexD:

- Does not set the LINSR[DRF] flag.
- Sets the corresponding error flag in LIN Error Status Register (LINESR) (see Errors for details).

## 48.4.2.4.4 Data discard

If you want to discard the data after header transmission, write 1 to LINCR2[DDRQ].

## 48.4.2.5 Slave mode

LINFlexD enters this mode when you write 0 to LINCR1[MME].

## 48.4.2.5.1 Data transmission

After receiving a header, LINFlexD:

- Sets the LINSR[HRF] flag.
- Generates an RX interrupt.

You must then:

1. Read the received ID in Buffer Identifier Register (BIDR).
2. Fill Buffer Identifier Register (BIDR), Buffer Data Register Least Significant (BDRL), and Buffer Data Register Most Significant (BDRM).
3. Write the necessary values to the CCS and DIR fields in BIDR.

4. Write the data field length to BIDR[DFL].
5. Write 1 to LINCR2[DTRQ] to trigger data transmission.

You must clear the LINSR[HRF] flag only after you write 1 to LINCR2[DTRQ]. For LINCR2[DTRQ] to be effective, the LINSR[HRF] flag must be set. This is to ensure that DTRQ is not set randomly, but only after a header reception.

You cannot write 1 to BIDR[DIR] and LINCR2[DTRQ] after LINSR[RXBUSY] is 1.

The same node also receives the transmitted data and copies it to the buffer.

## 48.4.2.5.2 Data reception

When LINFlexD is the subscriber of the data of the received identifier, and LINFlexD receives a header, LINFlexD:

- Writes 1 to LINSR[HRF].
- Generates an RX interrupt.

You must read the received ID from Buffer Identifier Register (BIDR) and specify the data field length before the reception of the stop bit of the first data byte. When the checksum is received, an RX interrupt is generated for you to read the received data from BIDR and LINFlexD sets the LINSR[RMB] flag. You must then release the data buffer by clearing the LINSR[RMB] flag.

If your software filters the identifier, you can discard the data by writing 1 to LINCR2[DDRQ] while LINSR[HRF] = 1.

For software filtering, you must choose the checksum type (BIDR[CCS]) before receiving data. Otherwise, the checksum calculation uses the previous value of BIDR[CCS].

## 48.4.2.6 Errors

## 48.4.2.6.1 Header error

A header error is an error during the header reception. The error types are:

- Sync delimiter error (SDEF)
- Sync field error (SFEF)
- Identifier parity error (IDPEF)

## 48.4.2.6.2 SDEF

The delimiter must be 1 for at least one bit time; otherwise it is considered short and consequently the receiver discards synchronization on the current header. Therefore LINFlexD discards the frame. LINFlexD also generates an interrupt if LINIER[HEIE] = 1.

## 48.4.2.6.3 IDPEF

The Identifier field has two parity bits. LINFlexD checks these bits against the hardware-calculated parity over the other six identifier bits according to this equation:

P0 = ID0 XOR ID1 XOR ID2 XOR ID4

P1 = NOT (ID1 XOR ID3 XOR ID4 XOR ID5)

Equation 14. Parity

LINFlexD checks this parity after transferring the ID to Buffer Identifier Register (BIDR). If LINCR2[IOPE] = 1 and parity mismatch occurs, the receiver state machine immediately exits the Identifier state.

LINFlexD

## 48.4.2.7 Bit error

LinFlexD flags this error in Transmission mode when the value read back from the bus is different from the value transmitted. Bit error checking on each bit is guaranteed if the transceiver delay is less than one bit time minus 6 LIN\_CPU cycles. LINFlexD does not check for bit errors.

1-bit time at 20 Kbit/s = 50 s

6 LIN\_CLK cycles at 80 MHz = 75 ns

Thus, (1-bit time) - (6 LIN\_CLK cycles) = 49.925 s

If LINCR2[IOBE] = 1, LINFlexD stops transmitting the frame after the corrupted bit. If LINCR2[IOBE] = 0, LINFlexD continues to transmit despite the bit error. LINFlexD generates an interrupt if LINIER[BEIE] = 1.

If the master does not detect the break delimiter within one bit time after delimiter transmission (for example, because of transceiver delay or bus error), LINFlexD generates a train of bit-error interrupts. In this case, LINFlexD may not replace the identifier in Buffer Identifier Register (BIDR). Similarly, if the transmitter node does not detect the start of a falling edge of data within one bit time after transmission of the start bit, LINFlexD generates a train of bit-error interrupts. In this case:

- Data replacements in the BIDR are not guaranteed.
- Checksum replacements in LIN Checksum Field Register (LINCFR) are not guaranteed.

## 48.4.2.8 Framing error

LINFlexD flags this error when it samples a dominant state on the stop bit of the current received character (Sync field, Identifier field, data field, or checksum field). LINFlexD discards the current frame and returns to the Idle state. LINFlexD generates an interrupt if LINIER[FEIE] = 1.

LINFlexD also takes the byte that caused the framing error and shifts it to the buffer, but does not set the LINSR[DRF] flag.

## 48.4.2.9 Checksum error

LINFlexD flags this error when the hardware-computed checksum does not match the received checksum.

LINFlexD discards the received frame and returns to the Idle state. LINFlexD generates an interrupt if LINIER[CEIE] = 1.

## 48.4.2.10 Overrun error

After the message buffer is full (LINSR[RMB] = 1), the next valid message reception leads to an overrun and the message is lost. LINFlexD signals the overrun condition by setting the LINESR[BOF] flag. The buffer lock function control (LINCR1[RBLM]) determines which message is lost.

If LINCR1[RBLM] = 0, the most-recent message overwrites the old message in the buffer. If LINCR1[RBLM] = 1, the most recent message is discarded and the oldest message is available to you. In the case of master, during overrun condition, the internal state machine moves to Idle state and any transition from 1 to 0 is considered as a wakeup state until the end of current transfer. In this scenario, you must process only one WUF interrupt and ignore the rest. In the case of slave, if the buffer is not released (LINCR1[RBLM] is not reset) before reception of next identifier and if LINCR1[RBLM] = 1, the ID and the data are discarded.

LINFlexD

## 48.4.2.11 Timeout error

<!-- image -->

## 48.4.2.11.1 Response timeout mechanism

## 48.4.2.11.1.1 Master mode

OC2 is loaded with 1.4((DFL+2)(10 bit times))+LINTCSR[CNT] at the end of the stop bit of the identifier field. This equation is defined according to the reset values of LINTOCR[RTO] and LINCR1[CFD], and it changes with any change in the values of these fields. Here, 1.4 corresponds to (LINTOCR[RTO])10 and 2 corresponds to (2-LINCR1[CFD]).

This loading occurs at the end of the identifier field (and not at the beginning of the data field). Moreover, the correct value, which depends on DFL, is loaded immediately. No further OC2 update is required.

In case of no response at all within this time-in other words, start of data is not received-a timeout occurs when the counter reaches the OC2 value (no change is compared to the earlier implementation).

In case of an incomplete response, a timeout also occurs when the counter reaches the OC2 value (no change compared to earlier implementation).

## 48.4.2.11.1.2 Slave mode

- Because you must update the DFL value after the identifier field has been received, the implementation is the following:
- At the end of the ID, OC2 is loaded with 36 (maximum possible response space) + LINTCSR[CNT].
- At the end of the first\_data\_byte it is reloaded again according to DFL.
- Before reloading, LINFlexD checks the count\_val. If count value is higher than the value to be reloaded, timeout occurs immediately and no reloading occurs.

## 48.4.2.11.2 Header timeout mechanism

## 48.4.2.11.2.1 Master mode

Because LINFlexD generates the header, there are only two cases:

- No error occurs on the bus and timing is correct (nominal header length).
- An error (typically a bit error) occurs on the bus and LINFlexD flags it in LIN Error Status Register (LINESR).

Therefore header timeout has no meaning in Master mode, so it is disabled.

## 48.4.2.11.2.2 Slave mode

- header\_nominal = 13+2+10+10 = 35 Tbit
- header\_max = 1.4header\_nominal = 49 Tbit
- Taking into account a possible 14% clock deviation, LINFlexD sees header\_max as 491.14 = 56 Tbit.
- If the counter starts after 11 Tbit (break duration), the required header timeout value is 56-11 = 45 Tbit.

Counter restarts after break duration and OC1 gets loaded with the value of LINTOCR[HTO].

Because response space is not included in the response, the frame timeout is no longer needed and is removed completely. Indeed, header timeout and response timeout cover all cases.

You can use the timeout counter to detect other timeouts. In this case, LINTCSR[MODE] = 0 and the software can update the output compare value in LIN Time-Out Control Register (LINTOCR).

## 48.4.2.11.2.3 Stuck at zero timeout error

If the dominant pulse lasts for at least 100 bits, LINFlexD sets the LINESR[SZF] flag. If the same dominant pulse lasts longer, the subsequent SZF setting is 87 (instead of 100) bit times apart.

## 48.4.2.12 Noise

During reception, each bit is sampled 16 times and the value of the bit is obtained by taking the majority value of the eighth, ninth, and tenth samples. If any one of these three samples has a value different from the other two, this error is flagged.

When UARTCR[OSR] = 8d, the majority of second, third, and fourth samples are taken into account to determine noise.

When UARTCR[OSR] &lt; 8d, noise checking is disabled.

This error is flagged when there is noise detected in the start bit (see LIN Error Status Register (LINESR)).

## 48.4.2.13 Start detection and break delimiter detection in receiver

The receiver has a 10-bit-shift register sample register that shifts signal data to the next least significant bit on each incoming sample. Therefore, a start is detected as soon as it is qualified with 1110 in the sample register and verified with at least two out of three predefined verification samples being zero. Similarly for delimiter detection, qualification samples are 0001 and at least two of the three verification samples are one. The Noise flag is set if the start is verified with only two valid samples.

Table 316. Start detection and delimiter detection in receiver

| 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   | Sample_reg   |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|--------------|
| -   | -   | -   | -   | -   | -   | -   | -   | -   | RT1 | counter = 0  |
| -   | -   | -   | -   | -   | -   | -   | -   | RT1 | RT2 | counter = 1  |
| -   | -   | -   | -   | -   | -   | -   | RT1 | RT2 | RT3 | counter = 2  |
| -   | -   | -   | -   | -   | -   | RT1 | RT2 | RT3 | RT4 | counter = 3  |
| -   | -   | -   | -   | -   | RT1 | RT2 | RT3 | RT4 | RT5 | counter = 4  |
| -   | -   | -   | -   | RT1 | RT2 | RT3 | RT4 | RT5 | RT6 | counter = 5  |
| -   | -   | -   | RT1 | RT2 | RT3 | RT4 | RT5 | RT6 | RT7 | counter = 6  |
| -   | -   | RT1 | RT2 | RT3 | RT4 | RT5 | RT6 | RT7 | RT8 | counter = 7  |

Table continues on the next page...

## Table 316. Start detection and delimiter detection in receiver (continued)

| 9   | 8   | 7   | 6    | 5    | 4    | 3    | 2    | 1    | 0    | Sample_reg       |
|-----|-----|-----|------|------|------|------|------|------|------|------------------|
| -   | RT1 | RT2 | RT3  | RT4  | RT5  | RT6  | RT7  | RT8  | RT9  | counter = 8      |
| RT1 | RT2 | RT3 | RT4  | RT5  | RT6  | RT7  | RT8  | RT9  | RT10 | counter = 9      |
| RT2 | RT3 | RT4 | RT5  | RT6  | RT7  | RT8  | RT9  | RT10 | RT11 | counter = 10     |
| RT3 | RT4 | RT5 | RT6  | RT7  | RT8  | RT9  | RT10 | RT11 | RT12 | counter = 11     |
| RT4 | RT5 | RT6 | RT7  | RT8  | RT9  | RT10 | RT11 | RT12 | RT13 | counter = 12     |
| RT5 | RT6 | RT7 | RT8  | RT9  | RT10 | RT11 | RT12 | RT13 | RT14 | counter = 13     |
| RT6 | RT7 | RT8 | RT9  | RT10 | RT11 | RT12 | RT13 | RT14 | RT15 | counter = 14     |
| RT7 | RT8 | RT9 | RT10 | RT11 | RT12 | RT13 | RT14 | RT15 | RT16 | counter = 15     |
| 1   | 1   | 1   | 0    | x    | 0    | x    | 0    | x    | 0    | start detect     |
| 1   | 1   | 1   | 0    | x    | 0    | x    | 0    | x    | 1    | start detect     |
| 1   | 1   | 1   | 0    | x    | 0    | x    | 1    | x    | 0    | start detect     |
| 1   | 1   | 1   | 0    | x    | 1    | x    | 0    | x    | 0    | start detect     |
| 0   | 0   | 0   | 1    | x    | 1    | x    | 1    | x    | 1    | delimiter detect |
| 0   | 0   | 0   | 1    | x    | 1    | x    | 1    | x    | 0    | delimiter detect |
| 0   | 0   | 0   | 1    | x    | 1    | x    | 0    | x    | 1    | delimiter detect |
| 0   | 0   | 0   | 1    | x    | 0    | x    | 1    | x    | 1    | delimiter detect |

## 48.4.2.13.1 Start detection mechanism

Here are the steps for detecting a start bit:

1. See Table 316 for the status of the sample register (shift register) when count = 6.
2. At this point, if RT1 (the first incoming sample) is 0 and the previous three samples already received are all 1s, then it might be a start bit.
3. To make sure it is indeed a start bit, the incoming data samples in the sample register (4), sample register (2) and sample register (0) which correspond to RT3, RT5, and RT7 is verified using the steps mentioned below.
4. If two out of these three samples are equal to 0, then start bit is said to be detected. These three samples-RT3, RT5, and RT7-are called verification samples that are checked at count = 6. The sample register bits-9, 8, 7, and 6-are called qualification samples that are checked at count = 6.
5. At count = 9, if majority value of RT8, RT9, and RT10 is not equal to 0 then Noise flag is set.

## 48.4.2.13.2 Break delimiter detection mechanism

Here are the steps for detecting a delimiter bit:

1. See Table 316 for the status of the sample register (shift register) when count = 6.
2. At this point, if RT1 (the first incoming sample) is 1 and the previous three samples already received are all 0s, then it might be a delimiter bit.
3. To make sure it is indeed a delimiter bit, the incoming data samples in the sample register (4), sample register (2) and sample register (0) that correspond to RT3, RT5, and RT7 is verified using the steps mentioned below.
4. If two out of these three samples are equal to 1, then delimiter bit is said to be detected.
5. These three samples RT3, RT5, and RT7 are called the verification samples that are checked at count = 6.
6. The sample register bits 9, 8, 7, and 6 are called qualification samples that are checked at count = 6.

Therefore, a start is detected as soon as it is qualified with 1110 in the sample register and verified with at least two out of three predefined verification samples being zero. Similarly for delimiter detection, qualification samples are 0001 and at least two out of the three verification samples are one. The Noise flag is set if the start is verified with only two valid samples.

<!-- image -->

The choice of the correct sample points depends on the external Rx signal quality. During the application development process, the error information indicated by the parity error can help you determine the best setting for an application-specific hardware signal.

Therefore, to sample at the correct point, you must write 2 to CSP, resulting in the following situation:

<!-- image -->

## 48.4.2.14 Baud rate generation

LIN Integer Baud Rate Register (LINIBRR) and LIN Fractional Baud Rate Register (LINFBRR) control the LIN baud rate. You can program these registers only during INITM.

Baud rate is calculated with the following equation for both receiver and transmitter.

When UARTCR[ROSE] = 1, Tx = Rx = LIN\_CLK  (OSR  LDIV).

When UARTCR[ROSE] = 0, Tx = Rx = LIN\_CLK  (16  LDIV), where LIN\_CLK is the frequency of the baud clock.

Equation 15. Baud rate

LDIV is an unsigned fixed-point number:

- LINIBRR[IBR] stores the mantissa.
- LINFBRR[FBR] stores the fraction.

When reduced oversampling is enabled, you must not use LIN Fractional Baud Rate Register (LINFBRR) and write 0 to it, and LDIV contains only the integer part of LINIBRR.

Table 317. Examples of baud rate calculations

|   UARTCR[ROSE] | Mode(s)      | LDIV    | LIN_CLK   | LINIBRR[IBR]   |   LINFBRR[FBR] | Baud rate                                            |
|----------------|--------------|---------|-----------|----------------|----------------|------------------------------------------------------|
|              0 | LIN and UART | 468.75d | 36 MHz    | 468d           |             12 | 36 MHz  (16  468.75) = 4.8 Kbit/s                  |
|              1 | UART         | 5d      | 80 MHz    | 5d             |              4 | LIN_CLK  (OSR  LDIV) = 80 MHz  (4  5) = 4 Mbit/s |

## 48.4.2.15 Wakeup management

Any node in a sleeping LIN cluster can request a wakeup. The node issues the wakeup request by forcing the bus to the dominant state for 250 s to 5 ms. Every slave node must detect the wakeup request (a dominant pulse longer than 150 s) and be ready to listen to bus commands within 100 ms, measured from the ending edge of the dominant pulse. The master also wakes after detecting a wakeup request, and when the slaves are ready, starts sending frame headers to find out the cause of the wakeup. If the master does not issue a frame header within 150 ms from the wakeup request, then the requesting node can try issuing a new wakeup request.

In LINFlexD, you can generate a wakeup request by:

- Writing the wakeup character (F0h for LIN 2.0) to BDR0.
- Writing 1 to LINCR2[WURQ].

After you write 1 to LINCR2[WURQ], LINFlexD transmits the character in BDR0.

In LINFlexD, wakeup can be detected in two ways.

LINFlexD

Table 318. Wakeup direction

|   LINCR1[AUTOWU] | Details                                                                                                                                                                                                                   |
|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                0 | After detecting a falling edge, LINFlexD:  Sets the LINSR[WUF] flag.  Generates an interrupt if LINIER[WUIE] = 1. You must then write 0 to LINCR1[SLEEP].                                                               |
|                1 | After detecting a falling edge in Sleep mode, LINFlexD:  Writes 0 to LINCR1[SLEEP].  Sets the LINSR[WUF] flag.  Generates an interrupt if LINIER[WUIE] = 1 LINFlexD is now in Normal mode and ready to receive frames. |

<!-- image -->

## 48.4.3 Timer

LINFlexD has an 8-bit counter that behaves differently in different modes as described in the following table.

Table 319. Timer behavior

| Mode                               | Details                                                                                                                                                                                                                                                                                                                                                                   |
|------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Output Compare (LINTCSR[MODE] = 1) |  Runs even in Sleep and Initialization modes  The counter value, when it matches the two software-configurable output compare fields (LINOCR[OC1] or LINOCR[OC2], generates output compare interrupt (LINESR[OCF]) if LINTCSR[TOCE] = 1.  After an interrupt occurs, LINFlexD generates subsequent interrupts only when the application has reset the stuck FSM state. |
| LIN                                |  You have no control over LINTCSR[TOCE] and LINFlexD uses output- compare registers to generate LIN timeout interrupts (header, frame, and response timeout).  If LIN moves to SM or INIT state, then this counter remains in Reset state. LIN mode has no meaning if UART is enabled, therefore the counter remains in Reset state.                                    |

## 48.4.4 UART mode

The main features in UART mode are:

- Full-duplex communication
- Frames of the following sizes:

- 8-bit
- 9-bit
- Even, odd, 0, and 1 parity
- User-programmable oversampling rate to obtain a baud rate of up to LIN\_CLK4 Mbit/s

## 48.4.4.1 8-bit data frames

The eighth bit can be a data or a parity bit. You can select even, odd, 0, or 1 parity with the UARTCR[PC1] and UARTCR[PC0] register fields. If the modulo-2 sum of the seven data bits is 1, the parity scheme will be even parity. An odd parity is cleared in this case.

<!-- image -->

## 48.4.4.2 9-bit frames

The ninth bit must be a parity bit. You can select even, odd, 0, or 1 parity with the UARTCR[PC1] and UARTCR[PC0] register fields. If the modulo-2 sum of the eight data bits is 1, the parity scheme will be even parity. An odd parity is cleared in this case. Parity 0 forces a zero logical value. Parity 1 forces a high logical value.

<!-- image -->

## 48.4.4.3 Buffer in UART mode

The 8-byte buffer includes two parts-receiver and transmitter-as shown in the following figure.

| Tx0   | BDR0   |
|-------|--------|
| Tx1   | BDR1   |
| Tx2   | BDR2   |
| Tx3   | BDR3   |
| Rx0   | BDR4   |
| Rx1   | BDR5   |
| Rx2   | BDR6   |
| Rx3   | BDR7   |

<!-- image -->

## 48.4.4.4 UART transmitter

To start transmission in UART mode, UART bit should be set and the transmitter enable bit should be set. Transmission starts when the BDR0 (least significant data byte) is programmed and continues until the number of bytes/halfwords transmitted is equal to the UARTCR[TDFL].

The transmit buffer is four bytes (when UARTCR[WL1] = 0) or two halfwords (when UARTCR[WL1] = 1). Therefore, the transmission that you trigger can have a maximum of four bytes (two halfwords). After the programmed number of bytes (halfwords) has been transmitted, the DTF flag is set in UARTSR. If UARTCR[TxEn] is reset in the middle of a transmission, then the current transmission completes and no further transmissions can start.

The buffer can be configured in FIFO mode (mandatory when the DMA Tx is enabled) by writing a 1 to UARTCR[TFBM].

## NOTE

If TFF bit is set and a write is performed to the FIFO, the data transmitted may be erroneous.

Table 320. BDRL access in UART mode

| IPS operation      | Register   | Mode (UARTCR[TFBM])   | Word length (UARTCR[WL])   | IPS operation result   |
|--------------------|------------|-----------------------|----------------------------|------------------------|
| Write Byte0        | BDRL       | FIFO                  | Byte                       | OK                     |
| Write Byte1-2-3    | BDRL       | FIFO                  | Byte                       | IPS transfer error     |
| Write Half-word0-1 | BDRL       | FIFO                  | Byte                       | IPS transfer error     |
| Write Word         | BDRL       | FIFO                  | Byte                       | IPS transfer error     |
| Write Byte0-1-2-3  | BDRL       | FIFO                  | Half-word                  | IPS transfer error     |
| Write Half-word0   | BDRL       | FIFO                  | Half-word                  | OK                     |
| Write Half-word1   | BDRL       | FIFO                  | Half-word                  | IPS transfer error     |
| Write Word         | BDRL       | FIFO                  | Half-word                  | IPS transfer error     |
| Read Byte0-1-2-3   | BDRL       | FIFO                  | Byte/Half-word             | IPS transfer error     |
| Read Half-word0-1  | BDRL       | FIFO                  | Byte/Half-word             | IPS transfer error     |
| Read Word          | BDRL       | FIFO                  | Byte/Half-word             | IPS transfer error     |
| Write Byte0-1-2-3  | BDRL       | BUFFER                | Byte/Half-word             | OK                     |
| Write Half-word0-1 | BDRL       | BUFFER                | Byte/Half-word             | OK                     |
| Write Word         | BDRL       | BUFFER                | Byte/Half-word             | OK                     |
| Read Byte0-1-2-3   | BDRL       | BUFFER                | Byte/Half-word             | OK                     |
| Read Half-word0-1  | BDRL       | BUFFER                | Byte/Half-word             | OK                     |
| Read Word          | BDRL       | BUFFER                | Byte/Half-word             | OK                     |

In UART FIFO mode (UARTCR[TFBM] = 1), any read operation causes an IPS transfer error.

LINFlexD

## 48.4.4.5 UART receiver

The reception of a data byte starts as soon as you:

- Exit INIT mode
- Write a 1 to UARTCR[RXEN]
- Detect the start bit

LINFlexD has a dedicated data buffer for received data. This buffer comprises 4 bytes if UARTCR[WL1]=0 or two half-words if UARTCR[WL1]=1. After the programmed number (RDFL bits) of bytes have been received, the DRF flag is set in UARTSR and the current reception finishes. You must write a 1 to UARTCR[RxEn] only to start the reception. The reception is automatically completed as soon as the programmed number (RDFL bits) of bytes have been received.

The buffer can be configured in FIFO mode (mandatory when the DMA Rx is enabled) by writing a 1 to UARTCR[RFBM].

Table 321. BDRM access in UART mode

| IPS operation      | Mode (UARTCR[RFBM])   | Word length (UARTCR:WL)   | IPS operation result   |
|--------------------|-----------------------|---------------------------|------------------------|
| Read Byte4         | FIFO                  | Byte                      | OK                     |
| Read Byte5-6-7     | FIFO                  | Byte                      | IPS transfer error     |
| Read Half-word2-3  | FIFO                  | Byte                      | IPS transfer error     |
| Read Word          | FIFO                  | Byte                      | IPS transfer error     |
| Read Byte4-5-6-7   | FIFO                  | Half-word                 | IPS transfer error     |
| Read Half-word2    | FIFO                  | Half-word                 | OK                     |
| Read Half-word3    | FIFO                  | Half-word                 | IPS transfer error     |
| Read Word          | FIFO                  | Half-word                 | IPS transfer error     |
| Write Byte4-5-6-7  | FIFO                  | Byte/Half-word            | IPS transfer error     |
| Write Half-word2-3 | FIFO                  | Byte/Half-word            | IPS transfer error     |
| Write Word         | FIFO                  | Byte/Half-word            | IPS transfer error     |
| Read Byte4-5-6-7   | BUFFER                | Byte/Half-word            | OK                     |
| Read Half-word2-3  | BUFFER                | Byte/Half-word            | OK                     |
| Read Word          | BUFFER                | Byte/Half-word            | OK                     |
| Write Byte4-5-6-7  | BUFFER                | Byte/Half-word            | IPS transfer error     |
| Write Half-word2-3 | BUFFER                | Byte/Half-word            | IPS transfer error     |
| Write Word         | BUFFER                | Byte/Half-word            | IPS transfer error     |

## NOTE

See the layout of the BDRL and BDRM registers to identify the mapping between byte x and data bits of these registers.

LINFlexD

Consider the following for UART receiver:

- If you do not know in advance how many bytes are to be received, RDFL must not be programmed in advance. The reset value of RDFL is 0. This ensures that the reception happens byte by byte. The state machine moves to the Idle state after each byte reception.
- If RDFL is programmed for a certain value but that number of bytes are not received, then reception hangs. In that case, software needs to take care of timeout by seeing the flag. Software has to set the sleep bit to move to Idle state.
- If a STOP request arrives in the middle of a reception, it is only acknowledged after all the programmed number of data bytes have received; it is not served immediately. If the programmed number of data bytes are not received, then software has to take care of timeout. When the state machine moves to Idle state, then only a stop request is served.
- If during the reception of any byte a parity error occurs, then the corresponding PEx bit in UARTSR is set. LINFlexD does not generate an interrupt in this case. If a framing error occurs in any byte (FE bit in UARTSR is set) then an interrupt is generated if FEIE bit in LINIER is set. As there is only one register bit for framing error, this interrupt is helpful in identifying which byte has framing error.
- If the last received frame has not been read from the buffer (in other words, you did not write a 1 to LINSR[RMB]), then upon reception of the next byte, an overrun error occurs (BOF bit in UARTSR is set) and one message is depending on RBLM bit of LINCR1. An interrupt is generated if the BOIE bit in LINIER is set.

## 48.4.5 DMA interface

## 48.4.5.1 Main features

The LINFlexD DMA offers a parametric and programmable solution with the following distinctive features:

Table 322. LINFlexD DMA features

| Node       | Mode   | Details                                                                                                                     |
|------------|--------|-----------------------------------------------------------------------------------------------------------------------------|
| LIN Master | TX     | Single DMA channel                                                                                                          |
| LIN Master | RX     | Single DMA channel                                                                                                          |
| LIN Slave  | TX     | 1 to DMA_TX_CH_NUM DMA channel See the chip-specific LINFlexD information for the value of DMA_TX_CH_NUM used in this chip. |
| LIN Slave  | RX     | 1 to DMA_RX_CH_NUM DMA channel See the chip-specific LINFlexD information for the value of DMA_RX_CH_NUM used in this chip. |
| UART       | TX     | Single DMA channel                                                                                                          |
| UART       | RX     | Single DMA channel plus timeout                                                                                             |

## 48.4.5.2 Definitions

The LINFlexD control register and their fields are described in Table 323.

LINFlexD

Table 323. LINFlexD DMA control fields description

| Field   | Mode                     | Value     | Level   | Description                                                    |
|---------|--------------------------|-----------|---------|----------------------------------------------------------------|
| DMA_TEN | LIN master Tx or UART Tx | DMATXE[0] | High    | Logical AND between the 2 DMA enable bits (LINFlexD and eDMA). |
| DMA_REN | LIN master Rx or UART Rx | DMARXE[0] | High    | Logical AND between the 2 DMA enable bits (LINFlexD and eDMA). |

Control/status fields of the transfer control descriptors referred to in this document are described in Table 324.

Table 324. TCD control fields description

| TCD Field    | Level   | Description                                                                                                          |
|--------------|---------|----------------------------------------------------------------------------------------------------------------------|
| CITER[14:0]  | -       | Current "major" iteration count                                                                                      |
| BITER[14:0]  | -       | Beginning "major" iteration count                                                                                    |
| NBYTES[31:0] | -       | Inner "minor" byte transfer count. Number of bytes to be transferred in each service request of the channel.         |
| SADDR[31:0]  | -       | Source address                                                                                                       |
| SOFF[15:0]   | -       | Source address signed offset applied to the current source address as each source read is completed.                 |
| SSIZE[2:0]   | -       | Source data transfer size 000 => 8-bit 001 => 16-bit 010 => 32-bit 011 => 64-bit                                     |
| SLAST[31:0]  | -       | Last source address adjustment                                                                                       |
| DADDR[31:0]  | -       | Destination address                                                                                                  |
| DOFF[15:0]   | -       | Destination address signed offset applied to the current destination address as each destination write is completed. |
| DSIZE[2:0]   | -       | Destination data transfer size 000 => 8-bit 001 => 16-bit 010 => 32-bit                                              |

Table continues on the next page...

Table 324. TCD control fields description (continued)

| TCD Field       | Level   | Description                                                                                                                                                  |
|-----------------|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                 |         | 011 => 64-bit                                                                                                                                                |
| DLAST_SGA[31:0] | -       | Last destination address adjustment or the memory address for the next TCD to be loaded into this channel (scatter/gather)                                   |
| INT_MAJ         | High    | Enable an interrupt when major iteration count completes                                                                                                     |
| START           | High    | The channel is explicitly started via a software initiated service request.                                                                                  |
| DONE            | High    | Channel done (the DMA has completed the outer major loop).                                                                                                   |
| D_REQ           | High    | Disable request. If this flag is set the DMA hardware automatically clears the corresponding DMAERQ bit when the current major iteration count reaches zero. |

## 48.4.5.3 Master node - TX mode

On a master node in TX mode, the DMA interface requires a single TX channel. Each TCD controls a single frame. The following figure shows the memory map associated with the TCD chain (RAM area and LINFlexD registers).

<!-- image -->

The TCD chain of the DMA Tx channel on a master node supports:

- Master to Slave: transmission of the entire frame (header + data)
- Slave to Master: transmission of the header; the Rx channel on the master node controls the data reception
- Slave to Slave: transmission of the header

The following table provides the settings for LINCR2 and BIDR for each class of LIN frame.

Table 325. Master node - Tx mode - Register setting

| LIN frame       | LINCR2            | BIDR                            |
|-----------------|-------------------|---------------------------------|
| Master to Slave | DDRQ = 1 DTRQ = 0 | DFL = payload size ID = address |

Table continues on the next page...

Table 325. Master node - Tx mode - Register setting (continued)

| LIN frame       | LINCR2                     | BIDR                                                        |
|-----------------|----------------------------|-------------------------------------------------------------|
|                 | HTRQ = 0                   | CCS = checksum DIR = 1 (TX)                                 |
| Slave to Master | DDRQ = 0 DTRQ = 0 HTRQ = 0 | DFL = payload size ID = address CCS = checksum DIR = 0 (RX) |
| Slave to Slave  | DDRQ = 1 DTRQ = 0 HTRQ = 0 | DFL = payload size ID = address CCS = checksum DIR = 0 (RX) |

The DMA Tx interface is shown in Figure 414. DMA TX moves to Idle state immediately at next clock edge if DMATXE[0] = 0. The TCD setting (word transfer) is given in Table 326. All other TCD fields = 0. TCD settings based on halfword or byte transfer are allowed.

Table 326. TCD setting - Master node - Tx mode

| TCD field       | Value               | Description                                                                                            |
|-----------------|---------------------|--------------------------------------------------------------------------------------------------------|
| CITER[14:0]     | 1                   | Single iteration for the "major" loop                                                                  |
| BITER[14:0]     | 1                   | Single iteration for the "major" loop                                                                  |
| NBYTES[31:0]    | [4 + 4] + 0/4/8 = N | Data buffer is stuffed with dummy bytes if the length is not word aligned. LINCR2 + BIDR + BDRL + BDRM |
| SADDR[31:0]     | -                   | RAM address                                                                                            |
| SOFF[15:0]      | 4                   | Word increment                                                                                         |
| SSIZE[2:0]      | 2                   | Word transfer                                                                                          |
| SLAST[31:0]     | -N                  |                                                                                                        |
| DADDR[31:0]     | -                   | LINCR2 address                                                                                         |
| DOFF[15:0]      | 4                   | Word increment                                                                                         |
| DSIZE[2:0]      | 2                   | Word transfer                                                                                          |
| DLAST_SGA[31:0] | -N                  | No scatter/gather processing                                                                           |
| INT_MAJ         | 0/1                 | Interrupt disabled/enabled                                                                             |

Table continues on the next page...

Table 326. TCD setting - Master node - Tx mode (continued)

| TCD field   |   Value | Description                       |
|-------------|---------|-----------------------------------|
| D_REQ       |       1 | Only on the last TCD of the chain |
| START       |       0 | No SW request                     |

<!-- image -->

## 48.4.5.4 Master node - RX mode

On a master node in RX mode, the DMA interface requires a single RX channel. Each TCD controls a single frame. The following figure shows the memory map associated with the TCD chain (RAM area and LINFlexD registers).

<!-- image -->

The TCD chain of the DMA Rx channel on a master node supports Slave to Master: reception of the data field of the header.

The BIDR is optionally copied into the RAM area, and this register (part of FIFO data) contains the ID of each message, which only allows the CPU to figure out which ID the LINFlexD DMA received if the single DMA channel setup is used.

The DMA Rx interface is shown in Figure 416. DMA RX moves to Idle state immediately at the next clock edge if DMARXE[0] are 0. The TCD setting (word transfer) is given in the next table. All other TCD fields are 0. TCD settings based on halfword or byte transfer are allowed.

Table 327. TCD setting - Master node - Rx mode

| TCD field       | Value      | Description                                                                                   |
|-----------------|------------|-----------------------------------------------------------------------------------------------|
| CITER[14:0]     | 1          | Single iteration for the major loop                                                           |
| BITER[14:0]     | 1          | Single iteration for the major loop                                                           |
| NBYTES[31:0]    | 4 +4/8 = N | Data buffer is stuffed with dummy bytes if the length is not word aligned. BIDR + BDRL + BDRM |
| SADDR[31:0]     | -          | BIDR address                                                                                  |
| SOFF[15:0]      | 4          | Word increment                                                                                |
| SSIZE[2:0]      | 2          | Word transfer                                                                                 |
| SLAST[31:0]     | -N         | -                                                                                             |
| DADDR[31:0]     | -          | RAM address                                                                                   |
| DOFF[15:0]      | 4          | Word increment                                                                                |
| DSIZE[2:0]      | 2          | Word transfer                                                                                 |
| DLAST_SGA[31:0] | -N         | No scatter/gather processing                                                                  |
| INT_MAJ         | 0/1        | Interrupt disabled/enabled                                                                    |
| D_REQ           | 1          | Only on the last TCD of the chain                                                             |
| START           | 0          | No SW request                                                                                 |

LINFlexD

<!-- image -->

## 48.4.5.5 UART - TX mode

In UART TX mode, the DMA interface requires a DMA TX channel. A single TCD can control the transmission of an entire Tx buffer. The following figure shows the memory map associated with the TCD chain (RAM area and LINFlexD registers).

LINFlexD

<!-- image -->

The UART TX buffer must be configured in FIFO mode to:

- Allow the transfer of large data buffer by a single TCD
- Absorb the latency, following a DMA request (because of the DMA arbitration), to move data from the RAM to the FIFO
- Use low-priority DMA channels

The Tx FIFO size is:

- 4 bytes in 8-bit data format

FIFO-not-full (TX) status signals trigger a DMA request.

The concept FSM to control the DMA Tx interface is given in Figure 418. DMA Tx FSM will move to Idle state if DMATXE[0] = 0.The TCD setting (typical case) is given in Table 328. All other TCD fields = 0. The minor loop transfers a single byte/halfword as soon as a free entry is available in the Tx FIFO.

Table 328. TCD setting - UART - Tx mode

| TCD field    | Value       | Value        | Description                              |
|--------------|-------------|--------------|------------------------------------------|
| TCD field    | 8 bits data | 16 bits data | Description                              |
| CITER[14:0]  | M           | M            | Multiple iterations for the "major" loop |
| BITER[14:0]  | M           | M            | Multiple iterations for the "major" loop |
| NBYTES[31:0] | 1           | 2            | Minor loop transfer = 1 or 2 bytes       |
| SADDR[31:0]  | -           | -            | RAM address                              |
| SOFF[15:0]   | 1           | 2            | Byte/Half-word increment                 |
| SSIZE[2:0]   | 0           | 1            | Byte/Half-word transfer                  |
| SLAST[31:0]  | -M          | -M  2       | -                                        |
| DADDR[31:0]  | -           | -            | BDRL address                             |

Table continues on the next page...

Table 328. TCD setting - UART - Tx mode (continued)

| TCD field       | Value       | Value        | Description                        |
|-----------------|-------------|--------------|------------------------------------|
| TCD field       | 8 bits data | 16 bits data | Description                        |
| DOFF[15:0]      | 0           | 0            | No increment (FIFO)                |
| DSIZE[2:0]      | 0           | 1            | Byte/Half-word transfer            |
| DLAST_SGA[31:0] | 0           | 0            | No scatter/gather processing       |
| INT_MAJ         | 0/1         | 0/1          | Interrupt disabled/enabled         |
| D_REQ           | 1           | 1            | Only on the last TCD of the chain. |
| START           | 0           | 0            | No SW request                      |

<!-- image -->

## 48.4.5.6 UART - RX mode

In UART RX mode, the DMA interface requires a DMA RX channel. A single TCD can control the reception of an entire Rx buffer. The following figure shows the memory map associated with the TCD chain (RAM area and LINFlexD registers).

LINFlexD

<!-- image -->

The UART RX buffer must be configured in FIFO mode to:

- Allow the transfer of large data buffer by a single TCD
- Absorb the latency, following a DMA request (due to the DMA arbitration), to move data from the FIFO to the RAM
- Use low priority DMA channels

The Rx FIFO comprises 4 bytes in an 8-bit data format.

This is sufficient because just one byte allows a reaction time of about 3.8 s (at 2 Mbit/s) (~450 clock cycles at 120 MHz) before the transmission is affected. FIFO triggers a DMA request. Empty (Rx) status signals do not trigger a DMA request.

 The DMA Rx interface is shown in Figure 420. DMA Rx moves to Idle state if DMARXE[0] = 0.The TCD setting (typical case) is shown in the next table. All other TCD fields equal 0. The minor loop transfers a single byte/halfword as soon an entry is available in the Rx FIFO. A new software reset bit is required that allows the LINFlexD FSMs to be reset in case this timeout state is reached or in any other case. You can rewrite the timeout counter at any time to extend the timeout period.

Table 329. TCD setting - UART - Rx mode

| TCD field    | Value       | Value        | Description                              |
|--------------|-------------|--------------|------------------------------------------|
| TCD field    | 8 bits data | 16 bits data | Description                              |
| CITER[14:0]  | M           | M            | Multiple iterations for the "major" loop |
| BITER[14:0]  | M           | M            | Multiple iterations for the "major" loop |
| NBYTES[31:0] | 1           | 2            | Minor loop transfer = 1 or 2 bytes       |
| SADDR[31:0]  | -           | -            | BDRM address                             |
| SOFF[15:0]   | 0           | 0            | No increment (FIFO)                      |
| SSIZE[2:0]   | 0           | 1            | Byte/Half-word transfer                  |
| SLAST[31:0]  | 0           | 0            |                                          |

Table continues on the next page...

Table 329. TCD setting - UART - Rx mode (continued)

| TCD field       | Value       | Value        | Description                        |
|-----------------|-------------|--------------|------------------------------------|
| TCD field       | 8 bits data | 16 bits data | Description                        |
| DADDR[31:0]     | -           | -            | RAM address                        |
| DOFF[15:0]      | 1           | 2            | Byte/Half-word increment           |
| DSIZE[2:0]      | 0           | 1            | Byte/Half-word transfer            |
| DLAST_SGA[31:0] | -M          | -M  2       | No scatter/gather processing       |
| INT_MAJ         | 0/1         | 0/1          | Interrupt disabled/enabled         |
| D_REQ           | 1           | 1            | Only on the last TCD of the chain. |
| START           | 0           | 0            | No SW request                      |

<!-- image -->

## 48.4.5.7 Use cases and limitations

In LIN master mode, both the DMA channels (TX and RX) must be enabled in case DMA is required.

In UART mode the DMA capability can be used only if the UART Tx/Rx buffers are configured as FIFOs.

DMA and CPU operating modes are mutually exclusive for the data/frame transfer on a UART or LIN node. After a DMA transfer finishes, the CPU can manage subsequent accesses.

Error management must always be executed via the CPU enabling the related error interrupt sources. DMA does not support for error management. Error management means checking status bits, handling IRQs, and potentially canceling DMA transfers.

The DMA programming model must be coherent with the TCD setting defined in this document.

## 48.5 LINFlexD register descriptions

The following points should be considered for LINFlexD registers:

- Reset values are with-slave/without-slave (master only) format
- If not specified, then the bit can be configured for both master only and master/slave format; in other words, for both values of (generic) slave = 0 and (generic) slave = 1.

Table 330. Register offsets based on master slave configuration and number of filters available

| Register                                                                         | Master only mode                                          | Master Slave mode                                         | Master Slave mode                                         | Master Slave mode                                         | Master Slave mode                                         |
|----------------------------------------------------------------------------------|-----------------------------------------------------------|-----------------------------------------------------------|-----------------------------------------------------------|-----------------------------------------------------------|-----------------------------------------------------------|
|                                                                                  |                                                           | Number of filters = 0                                     | Number of filters = 4                                     | Number of filters = 8                                     | Number of filters = 16                                    |
| LIN Control register 1 (LINCR1) - Buffer Data Register Most Significant(BDRM)    | 0x00-0x3C                                                 | 0x00-0x3C                                                 | 0x00-0x3C                                                 | 0x00-0x3C                                                 | 0x00-0x3C                                                 |
| Identifier Filter Enable Register(IFER) - Identifier Filter Mode register (IFMR) | Reserved/ 0x40-0x48 Transfer error generated              | Reserved/ 0x40-0x48 Transfer error generated              | 0x40-0x48                                                 | 0x40-0x48                                                 | 0x40-0x48                                                 |
| Identifier Filter Control registers(IFCR0-3)                                     | Not available                                             | Not available                                             | 0x4C-0x58                                                 | 0x4C-0x58                                                 | 0x4C-0x58                                                 |
| Identifier Filter Control registers(IFCR4-7)                                     | Not available                                             | Not available                                             | Not available                                             | 0x5C-0x68                                                 | 0x5C-0x68                                                 |
| Identifier Filter Control registers (IFCR8-15)                                   | Not available                                             | Not available                                             | Not available                                             | Not available                                             | 0x6C-0x88                                                 |
| Global Control register (GCR) - DMA Rx Enable register (DMARXE)                  | 0x4C-0x5C                                                 | 0x4C-0x5C                                                 | 0x5C-0x6C                                                 | 0x6C-0x7C                                                 | 0x8C-0x9C                                                 |
| Transfer errors for outside memory map register locations                        | Transfer errors for outside memory map register locations | Transfer errors for outside memory map register locations | Transfer errors for outside memory map register locations | Transfer errors for outside memory map register locations | Transfer errors for outside memory map register locations |
|                                                                                  | Transfer error generated after 0x60                       | Transfer error generated after 0x60                       | Transfer error generated after 0x70                       | Transfer error generated after 0x80                       | Transfer error generated after 0xA0                       |

## 48.5.1 LINFlexD memory map

LINFlexD\_0 base address: 401C\_8000h

LINFlexD\_1 base address: 401C\_C000h

LINFlexD\_2 base address: 402B\_C000h

| Offset   | Register                                       |   Width (In bits) | Access   | Reset value   |
|----------|------------------------------------------------|-------------------|----------|---------------|
| 0h       | LIN Control Register 1 (LINCR1)                |                32 | RW       | 0000_0082h    |
| 4h       | LIN Interrupt Enable Register (LINIER)         |                32 | RW       | 0000_0000h    |
| 8h       | LIN Status Register (LINSR)                    |                32 | RW       | 0000_0040h    |
| Ch       | LIN Error Status Register (LINESR)             |                32 | RW       | 0000_0000h    |
| 10h      | UART Mode Control Register (UARTCR)            |                32 | RW       | 0000_0000h    |
| 14h      | UART Mode Status Register (UARTSR)             |                32 | RW       | 0000_0000h    |
| 18h      | LIN Time-Out Control Status Register (LINTCSR) |                32 | RW       | 0000_0200h    |
| 1Ch      | LIN Output Compare Register (LINOCR)           |                32 | RW       | 0000_FFFFh    |
| 20h      | LIN Time-Out Control Register (LINTOCR)        |                32 | RW       | 0000_0E2Ch    |
| 24h      | LIN Fractional Baud Rate Register (LINFBRR)    |                32 | RW       | 0000_0000h    |
| 28h      | LIN Integer Baud Rate Register (LINIBRR)       |                32 | RW       | 0000_0000h    |
| 2Ch      | LIN Checksum Field Register (LINCFR)           |                32 | RW       | 0000_0000h    |
| 30h      | LIN Control Register 2 (LINCR2)                |                32 | RW       | 0000_6000h    |
| 34h      | Buffer Identifier Register (BIDR)              |                32 | RW       | 0000_0000h    |
| 38h      | Buffer Data Register Least Significant (BDRL)  |                32 | RW       | 0000_0000h    |
| 3Ch      | Buffer Data Register Most Significant (BDRM)   |                32 | RW       | 0000_0000h    |
| 4Ch      | Global Control Register (GCR)                  |                32 | RW       | 0000_0000h    |
| 50h      | UART Preset Timeout Register (UARTPTO)         |                32 | RW       | 0000_0FFFh    |
| 54h      | UART Current Timeout Register (UARTCTO)        |                32 | R        | 0000_0000h    |
| 58h      | DMA Tx Enable Register (DMATXE)                |                32 | RW       | 0000_0000h    |
| 5Ch      | DMA Rx Enable Register (DMARXE)                |                32 | RW       | 0000_0000h    |

## 48.5.2 LIN Control Register 1 (LINCR1)

## Offset

| Register   | Offset   |
|------------|----------|
| LINCR1     | 0h       |

## Function

Provides control bits used to configure features of the LINFlexD.

When accessing the LINCR1 register, each reserved bit must be written to its original reset value.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28      | 27   | 26   | 25   | 24   | 23   | 22        | 21   | 20   | 19   | 18   | 17     | 16   |
|--------|------|------|------|---------|------|------|------|------|------|-----------|------|------|------|------|--------|------|
| R      | 0    | 0    | 0    | 0       | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0    | 0    | 0      | NLSE |
| W      |      |      |      |         |      |      |      |      |      |           |      |      |      |      |        | NLSE |
| Reset  | 0    | 0    | 0    | 0       | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0    | 0    | 0      | 0    |
| Bits   | 15   | 14   | 13   | 12      | 11   | 10   | 9    | 8    | 7    | 6         | 5    | 4    | 3    | 2    | 1      | 0    |
| R W    | CCD  | CFD  | 0    | AUTO WU | MBL  | MBL  | MBL  | MBL  | 1    | Reserv ed | LBKM | MME  | SSBL | RBLM | SLEE P | INIT |
| Reset  | 0    | 0    | 0    | 0       | 0    | 0    | 0    | 0    | 1    | 0         | 0    | 0    | 0    | 0    | 1      | 0    |

## Fields

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|-----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-17 -   | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 16 NLSE   | LIN State Capture Enable on Bit Error Enables capture of LIN state, LINSR[LINS] whenever bit error flag occur, that is, LINESR[BEF] set to 1. If this bit is set to 1, internal LIN state is not captured when LINCR2[IOBE]=1 and the state transition to IDLE occurs; and LINSR[LINS] shows error state only. 0b - LIN state, LINSR[LINS] shows the current LIN state and does not capture the LIN state if a bit error occurs. 1b - LIN state, LINSR[LINS] is captured whenever LINESR[BEF] occurs. |
| 15 CCD    | Checksum Calculation Disable You can read this field at any time and write to it only in Initialization mode. 0b - Hardware performs the checksum calculation. When this bit is reset, the LINCFR becomes read only. 1b - Checksum calculation disabled. When this field is set, the LINCFR is read/write. You can program this register to send a software calculated checksum/CRC (provided CFD is reset).                                                                                          |
| 14 CFD    | Checksum Field Disable You can read this field at any time and write to it only in Initialization mode. 0b - Checksum field is sent after the required number of data bytes are sent 1b - No checksum field is sent in the frame                                                                                                                                                                                                                                                                      |
| 13 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 12 AUTOWU | Auto Wakeup                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |

Table continues on the next page...

LINFlexD

## Table continued from the previous page...

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|          | You can read this field at any time and write to it only in Initialization mode. This bit is utilized in UART mode also. 0b - Sleep bit is cleared by software only 1b - Sleep bit gets cleared by hardware whenever WUF bit of LINSR is set                                                                                                                                                                                                                                                                                                                                 |
| 11-8 MBL | Master Break Length Chooses the length of the Sync break that the master generates. You can read this field at any time and write to it only in Initialization mode. 0000b - 10-bit break length 0001b - 11-bit break length 0010b - 12-bit break length 0011b - 13-bit break length 0100b - 14-bit break length 0101b - 15-bit break length 0110b - 16-bit break length 0111b - 17-bit break length 1000b - 18-bit break length 1001b - 19-bit break length 1010b - 20-bit break length 1011b - 21-bit break length 1100b - 22-bit break length 1101b - 23-bit break length |
| 7 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 6 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 5 LBKM   | Loop Back mode See "Loop back mode" in Test modes. You can read this field at any time and write to it only in Initialization mode. This bit is utilized in UART mode also. 0b - Loop Back mode disabled 1b - Loop Back mode enabled                                                                                                                                                                                                                                                                                                                                         |
| 4        | Master Mode Enable                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                        |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| MME     | You can read this field at any time and write to it only in Initialization mode. 0b - Slave mode 1b - Master mode                                                                                                                                                                                                                                                                               |
| 3 SSBL  | Slave Mode Sync Break Length You can read this field at any time and write to it only in Initialization mode. 0b - 11-bit break length 1b - 10-bit break length                                                                                                                                                                                                                                 |
| 2 RBLM  | Receiver Buffer Locked mode You can read this field at any time and write to it only in Initialization mode. This bit is utilized in UART mode also. 0b - Receiver buffer not locked. Next incoming message overwrites the old one. 1b - Receiver buffer locked against overrun. After the buffer is full, the next incoming message will be discarded if buffer is not released (UARTSR[RMB]). |
| 1 SLEEP | Sleep Mode Request Write a 1 to this field to request LINFlexD to enter Sleep mode. This bit is cleared by software or hardware (if AUTOWU bit in LINCR1 and WUF bit in LINSR are set) to exit sleep mode. This bit is utilized in UART mode also.                                                                                                                                              |
| 0 INIT  | Initialization Mode Request Write a 1 to this field to request LINFlexD to enter Initialization mode. On clearing this bit (and if LINCR1[SLEEP]=0), LINFlexD enters Normal mode. This bit is utilized in UART mode also.                                                                                                                                                                       |

## 48.5.3 LIN Interrupt Enable Register (LINIER)

## Offset

| Register   | Offset   |
|------------|----------|
| LINIER     | 4h       |

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20        | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|-----------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |           |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4         | 3    | 2    | 1    | 0    |
| R W    | SZIE | OCIE | BEIE | CEIE | HEIE | 0    | 0    | FEIE | BOIE | LSIE | WUIE | Reserv ed | TOIE | DRIE | DTIE | HRIE |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                                                                                                                                              |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-16 - | Reserved                                                                                                                                                                                                                                              |
| 15 SZIE | Stuck at Zero Interrupt Enable An interrupt is generated if this bit is set and the Stuck at Zero Flag (SZF) in LINESR or UARTSR is set. 0b - No interrupt 1b - Interrupt enabled                                                                     |
| 14 OCIE | Output Compare Interrupt Enable 0b - No interrupt 1b - Interrupt generated when OCF bit in LINESR or UARTSR is set                                                                                                                                    |
| 13 BEIE | Bit Error Interrupt Enable 0b - No interrupt 1b - Interrupt generated when BEF bit in LINESR is set                                                                                                                                                   |
| 12 CEIE | Checksum Error Interrupt Enable An interrupt is generated if this bit is set and the Checksum Error Flag (CEF) is set in LINESR. 0b - No interrupt 1b - Interrupt enabled                                                                             |
| 11 HEIE | Header Error Interrupt Enable Aninterrupt is generated whenthis bit is set and either of the following flags are set: SFEF, SDEF, or IDPEF. If generic slave = 0, then this bit will always read a 0 and cannot be programmed. NOTE 0b - No interrupt |

Table continues on the next page...

LINFlexD

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                    |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 10-9 -  | Reserved                                                                                                                                                                                                                                                                                                    |
| 8 FEIE  | Frame Error Interrupt Enable 0b - No interrupt 1b - Interrupt generated if Frame Error Flag (FEF) bit is set in LINESR or UARTSR                                                                                                                                                                            |
| 7 BOIE  | Buffer Overrun Error Interrupt Enable An interrupt is generated if this bit is set and the Buffer Overrun Flag (BOF) is set in LINESR or UARTSR. 0b - No interrupt 1b - Interrupt enabled                                                                                                                   |
| 6 LSIE  | LIN State Interrupt Enable Interrupt is generated only when entering the above fields. You can use this interrupt for debugging purposes. The interrupt has no status flag. 0b - No interrupt 1b - Interrupt generated when entering the following states: Sync Del, Sync Field, Identifier field, Checksum |
| 5 WUIE  | Wakeup Interrupt Enable If WUIE=1 and the WUF in LINSR or UARTSR is set then an interrupt is generated. 0b - No interrupt 1b - Interrupt enabled                                                                                                                                                            |
| 4 -     | Reserved                                                                                                                                                                                                                                                                                                    |
| 3 TOIE  | Timeout Interrupt Enable An interrupt is generated if this bit is set and UARTSR[TO]=1 (in UART mode). 0b - No interrupt 1b - Interrupt enabled                                                                                                                                                             |
| 2 DRIE  | Data Reception Complete Interrupt Enable An interrupt is generated when this bit is set and Data Received flag (DRF) in LINSR or UARTSR is set. 0b - No interrupt 1b - Interrupt enabled                                                                                                                    |
| 1       | Data Transmitted Interrupt enable                                                                                                                                                                                                                                                                           |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                       |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| DTIE    | An interrupt is generated when this bit is set and Data Transmitted flag (DTF) in LINSR or UARTSR is set. 0b - No interrupt 1b - Interrupt enabled                                                                                                             |
| 0 HRIE  | Header Received Interrupt An interrupt is generated when this bit is set and the Header Received flag (HRF) in LINSR is set. If generic slave = 0, then this bit will always read a 0, and cannot be programmed. NOTE 0b - No interrupt 1b - Interrupt enabled |

## 48.5.4 LIN Status Register (LINSR)

## Offset

| Register   | Offset   |
|------------|----------|
| LINSR      | 8h       |

## Function

Indicates the LINFlexD state

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24     | 23      | 22   | 21   | 20   | 19    | 18    | 17    | 16    |
|--------|------|------|------|------|------|------|------|--------|---------|------|------|------|-------|-------|-------|-------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0      | 0       | 0    | 0    | 0    | 0 RDC | 0 RDC | 0 RDC | 0 RDC |
| W      |      |      |      |      |      |      |      |        |         |      |      |      |       |       |       |       |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0      | 0       | 0    | 0    | 0    | 0     | 0     | 0     | 0     |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8      | 7       | 6    | 5    | 4    | 3     | 2     | 1     | 0     |
| R      | LINS | LINS | LINS | LINS | 0    | 0    | RMB  | DRBN E | RXBU SY | RDI  | WUF  | 0    | 0     | DRF   | DTF   | HRF   |
| W      | 1    | 1    | 1    | 1    |      |      | W1C  | W1C    |         |      | W1C  |      |       | W1C   | W1C   | W1C   |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0      | 0       | 1    | 0    | 0    | 0     | 0     | 0     | 0     |

## Fields

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-20 -    | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 19 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 18-16 RDC  | Receive Data Byte Count Contains the number of entries (bytes) in the Receive data buffer in LIN mode. You can use this field for debug purposes. 000b - 1 byte 001b - 2 bytes 010b - 3 bytes 011b - 4 bytes 100b - 5 bytes 101b - 6 bytes 110b - 7 bytes 111b - 8 bytes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 15-12 LINS | LIN State In UARTmode, Idle, Init, Sleep, and Data Transmission/Reception states are flagged by the LIN status bits. The value of this field does not change by any write operation to it. Writing Fh to this field clears the Rx interrupt, only when set because of the LIN state event. NOTE 0000b - Sleep mode: LINFlexD is in Sleep mode, to save power consumption. 0001b - Init mode: LINFlexD is in Initialization mode. 0010b - Idle mode: This mode is entered when: SLEEP bit and INIT bit are reset by software; Wakeup pulse has been received on RX pin (AUTOWU set); Previous frame transmission/ reception has been completed/aborted 0011b - Sync break: In Slave mode, if a falling edge is detected followed by a dominant state, it indicates that the sync break reception is ongoing. In Master mode, this indicates that the sync break transmission is ongoing. In slave mode, upon any error LIN state could be either Idle or Rec_Break, depending on last bit detected on LIN_RX. If the last bit detected is dominant then Rec_Break, otherwise Idle. 0100b - Sync Del: In Slave mode, valid sync break has been detected (10 bit or 11 bit). Waiting for a rising edge. In Master mode, Sync break transmission has been completed, sync delimiter transmission is ongoing. 0101b - Sync Field: In Slave mode, a valid sync Del has been detected (recessive state for at least one bit time). Receiving sync field. In Master mode, sync field transmission ongoing. |

Table continues on the next page...

## Table continued from the previous page...

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|          | 0110b - Identifier Field: In Slave mode, a valid sync field has been received. Receiving ID field. In Master mode, identifier transmission is ongoing. 0111b - Header Reception/Transmission: In Slave mode, a valid header has been received and Identifier field is available in the BIDR. In Master mode, header transmitted. 1000b - Data Reception/Data Transmission: In Receiver mode, reception ongoing. In Transmitter mode, response transmission ongoing. 1001b - Checksum: Data transmission/reception completed, checksum transmission/reception ongoing. |
| 11-10 -  | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 9 RMB    | Release Message Buffer 0b - Buffer data is free and is reset by hardware when it in Initialization mode. 1b - Buffer data ready to be read by software. This bit must be cleared by software after reading the data received in the buffer.                                                                                                                                                                                                                                                                                                                           |
| 8 DRBNE  | Data Reception Buffer Not Empty LINFlexD writes a 1 to this field as soon as the first byte of response has been received and stored in BDRL (when there is at least one data byte in reception buffer). Software must clear it after reading all the buffers. LINFlexD writes a 0 to this field in Initialization mode. This flag could be checked by software in case of a response timeout event.                                                                                                                                                                  |
| 7 RXBUSY | Receiver Busy In Slave mode after header reception, if DIR bit is reset and reception starts, then this bit is set. In this case, you cannot write a 1 to LINCR2[DTRQ]. 0b - Receiver idle 1b - Reception ongoing                                                                                                                                                                                                                                                                                                                                                     |
| 6 RDI    | Receiver Data Input Reflects the current status of the Rx pin After reset is released, RDI reflects the actual value of Rx pin. NOTE                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 5 WUF    | Wakeup flag This bit is set by hardware when a falling edge is detected on the Rx pin.  When slave is in Sleep mode  When master is in Sleep mode or Idle mode LINFlexD writes a 0 to this field in Initialization mode.                                                                                                                                                                                                                                                                                                                                            |
| 4-3      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| -       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 2 DRF   | Data Reception Completed Flag This bit is set by hardware and indicates that data reception completed. This flag must be cleared by software. LINFlexD writes a 0 to this field in Initialization mode. In case framing error or checksum error occurs then this flag is not set. NOTE                                                                                                                                                                                                                                  |
| 1 DTF   | Data Transmission Completed Flag This bit is set by hardware and indicates that data transmission completed. This flag must be cleared by software. LINFlexD writes a 0 to this field in Initialization mode. For LIN mode, in case a bit error occurs (and IOBE is reset) then this flag is not set. NOTE                                                                                                                                                                                                              |
| 0 HRF   | Header Received flag This bit is set when the header reception is completed. It must be cleared by software. This bit is set only when:  All filters are inactive and Bypass filter (BF) bit is set  No match in any filter and Bypass filter (BF) bit is set  TX filter match At end of frame or frame aborted, if HRF is still set, it gets reset by hardware. This bit is also reset by hardware in Initialization mode. If generic slave = 0, then this bit will always read a 0, and cannot be programmed. NOTE |

## 48.5.5 LIN Error Status Register (LINESR)

## Offset

| Register   | Offset   |
|------------|----------|
| LINESR     | Ch       |

## Function

See Errors for a detailed description of all errors.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25    | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|-------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |       |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9     | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | SZF  | OCF  | BEF  | CEF  | SFEF | SDEF | IDPEF | FEF  | BOF  | 0    | 0    | 0    | 0    | 0    | 0    | NF   |
| W      | W1C  | W1C  | W1C  | W1C  | W1C  | W1C  | W1C   | W1C  | W1C  |      |      |      |      |      |      | W1C  |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-16 - | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 15 SZF  | Stuck At Zero Flag This bit is set when there is a stuck-at-zero timeout error. It must be reset by software.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 14 OCF  | Output Compare Flag This bit must be cleared by software. If this bit is set, MODE bit in LINTCSR is cleared, and the IOT bit of LINTCSR is set, then LINFlexD moves to Idle state. If LINTCSR[MODE]=0, then LINflexD writes a 0 to OCF in Initialization mode. If LINTCSR[MODE]=1, then OCF maintains its value regardless of the LIN state. 0b - No output compare event occurred 1b - In master mode, LINESR[OCF] flag is set when counter LINTCSR[CNT] has matched the content of LINOCR[OC2]. In slave mode, LINESR[OCF] is set when the content of the counter LINTCSR[CNT] has matched the content of LINOCR[OC1] or LINOCR[OC2]. |
| 13 BEF  | Bit Error Flag LINFlexD writes a 1 to this field when a bit error occurs. It should be cleared by software. LINFlexD writes a 0 to this field in Initialization mode.                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 12 CEF  | Checksum Error Flag LINFlexD writes a 1 to this field if the received checksum does not match the hardware-calculated checksum. It must be cleared by software. This error will never occur if CCD or CFD bit of LINCR1 is set. LINFlexD writes a 0 to this field in Initialization mode.                                                                                                                                                                                                                                                                                                                                                |
| 11 SFEF | Sync Field Error Flag LINFlexD writes a 1 to this field when the received Sync Field is inconsistent. It must be cleared by software. LINFlexD writes a 0 to this field in Initialization mode.                                                                                                                                                                                                                                                                                                                                                                                                                                          |

Table continues on the next page...

LINFlexD

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                         |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | If generic slave = 0, then this bit will always read a 0, and cannot be programmed.                                                                                                                                                                                                                                                                                                              |
| 10 SDEF | Sync Delimiter Error Flag TLINFlexD writes a 1 to this field when the delimiter is too short (in other words, less than one bit time). It should be cleared by software. LINFlexD writes a 0 to this field in Initialization mode. If generic slave = 0, then this bit will always read a 0, and cannot be programmed. NOTE                                                                      |
| 9 IDPEF | ID Parity Error Flag TLINFlexD writes a 1 to this field when an error in the ID parity occurs. It should be cleared by software. Header Error Interrupt is triggered for SFEF or SDEF or IDPEF flag is set and HEIE is set. NOTE If generic slave = 0, then this bit will always read a 0, and cannot be programmed. For generic slave = 1,this bit is reset by hardware in Initialization mode. |
| 8 FEF   | Framing Error Flag LINFlexD writes a 1 to this field when a framing error (invalid stop bit) occurs. It should be cleared by software. LINFlexD writes a 0 to this field in Initialization mode.                                                                                                                                                                                                 |
| 7 BOF   | Buffer Overrun Flag This bit is set by hardware when there is a new byte received and RMB bit is not cleared. It can be cleared by software. LINFlexD writes a 0 to this field in Initialization mode.                                                                                                                                                                                           |
| 6-1 -   | Reserved                                                                                                                                                                                                                                                                                                                                                                                         |
| 0 NF    | Noise Flag This bit is set by hardware whennoise is detected in the received character. It should becleared by software. LINFlexD writes a 0 to this field in Initialization mode.                                                                                                                                                                                                               |

## 48.5.6 UART Mode Control Register (UARTCR)

## Offset

| Register   | Offset   |
|------------|----------|
| UARTCR     | 10h      |

## Function

## Diagram

<!-- image -->

| Bits   | 31       | 30       | 29       | 28       | 27       | 26       | 25   | 24   | 23   | 22   | 21   | 20   | 19          | 18   | 17   | 16        |
|--------|----------|----------|----------|----------|----------|----------|------|------|------|------|------|------|-------------|------|------|-----------|
| R W    | MIS      |          | CSP      |          |          | OSR      |      |      | ROSE |      | NEF  |      | DTU_P CE... | SBUR |      | Reserv ed |
| Reset  | 0        | 0        | 0        | 0        | 0        | 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0           | 0    | 0    | 0         |
| Bits   | 15       | 14       | 13       | 12       | 11       | 10       | 9    | 8    | 7    | 6    | 5    | 4    | 3           | 2    | 1    | 0         |
| R W    | TDFL_TFC | TDFL_TFC | TDFL_TFC | RDFL_RFC | RDFL_RFC | RDFL_RFC | RFBM | TFBM | WL1  | PC1  | RxEn | TxEn | PC0         | PCE  | WL0  | UART      |
| Reset  | 0        | 0        | 0        | 0        | 0        | 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0           | 0    | 0    | 0         |

## Fields

| Field     | Function                                                                                                                                                                                                                         |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 MIS    | Monitor Idle State Controls what UARTCTO monitors. Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - UARTCTO monitors the number of bits to be received.                      |
| 30-28 CSP | Configurable Sample Point Decides the sample point during reduced oversampling. CSP can take the following range of values for a given oversampling rate:                                                                        |
| 30-28 CSP | OSR CSP                                                                                                                                                                                                                          |
| 30-28 CSP | 4 2,3                                                                                                                                                                                                                            |
| 30-28 CSP | 5 2, 3, 4                                                                                                                                                                                                                        |
| 30-28 CSP | 6 3, 4, 5                                                                                                                                                                                                                        |
| 30-28 CSP | 8 NA                                                                                                                                                                                                                             |
| 30-28 CSP | Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                                                                                                  |
| 27-24 OSR | Over Sampling Rate Configures the number of samples taken for a bit when reduced oversampling is enabled. In most cases, OSR can be 4, 5, 6 or 8. When idle state monitoring is enabled (MIS=1), OSR can be only 4 or 8. 4 or 8. |

Table continues on the next page...

## NOTE

When accessing the UARTCR register, reserved bits must always be written to zero.

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 23 ROSE      | Reduced Over Sampling Enable Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Each bit is over sampled sixteen times.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 22-20 NEF    | Number of expected frames Configures the number of expected frames in UART reception mode. If the DTU bit is set, then the UART timeout counter will be reset after the configured number of frames have been received. Register bit can be read in any mode, written only when UART bit is set. Register bit is a read/write field.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 19 DTU_PCETX | Disable Timeout in UART mode This bit can be programmed in Initialization mode only when the UART bit is set. There is an internal counter that gives the number of frames received. In Buffer mode: This timer gets reset whenever the number of bytes received (rec_byte_cnt) is equal to RDFL. At this point, the DRF bit is set. Also, the num_of_frames (number of frames received) and rec_byte_cnt are reset. Whennum_of_framesequals NEF,Disable Timeout is generated. But this clears num_of_frames also. Thus the timer restarts. The value of counter is 0 when it restarts. In FIFO mode: When num_of_frames equals NEF, Disable Timeout is generated which clears num_of_frames and causes the timer to restart. The value of counter is 0 when it restarts. Notes:  Disable Timeout causes only the Timer to restart which enables Timeout again.  Timer reset means it resets and starts counting again and the Timeout is enabled. 0b - Timeout has to be handled by software |
| 18-17 SBUR   | Stop Bits In UART Reception Mode When the UART is used for transmission and reception, you need to set the same number of stop bits in GCR and SBUR. When the UART is used only as receiver, it is enough to set SBUR bits only. Register bit can be read in any mode, written only in Initialization mode when UART bit is set. 00b - 1 stop bit 01b - 2 stop bits 10b - 3 stop bits                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |

Table continues on the next page...

## Table continued from the previous page...

| Field          | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|----------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 16 -           | Reserved This reserved field is writable but do not write any value to it other than its reset                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 15-13 TDFL_TFC | value. Transmitter Data Field Length/TX FIFO Counter TDFL defines the number of bytes to be transmitted in UART buffer mode (TFBM = 0). Bit 15 is reserved and not implemented. When the UARTdata length is configured as halfword (WL = 10 or WL=11), only the configurations TDFL = x01 or TDFL = x11 are allowed.                                                                                                                                                                                                                                       |
| 12-10 RDFL_RFC | 100 : 4 bytes Others : reserved TDFL_TFC can be programmed and is significant only when the UART bit is set. When you have connected a debugger, TDFL_TFC decrements if you read TxFIFO through the debugger. If the data path functions normally, LINFlexD clears the RFC/TFC counters internally. Reception Data Field Length/RX FIFO Counter RDFL defines the number of bytes to be received in UART buffer mode (RFBM = 0). Bit 19 is reserved and not implemented. When the UART data length is configured as halfword (WL = 10 or WL = 11), only the |
|                | configurations RDFL = x01 or RDFL = x11 are allowed. x00 : 1 byte x01 : 2 bytes x10 : 3 bytes x11 : 4 bytes RFC contains the number of entries (bytes) of the Rx FIFO in UART FIFO mode (RFBM = 1). RFCx is available for debug purposes. 000 : Empty 001 : 1 byte                                                                                                                                                                                                                                                                                         |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                | Function                                                                                                                                                                                                                                                                                                                                                                                | Function                                                                                                                                                                                                                                                                                                                                                                                |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | 011 : 3 bytes 100 : 4 bytes Others - Reserved RDFL_RFC can be programmed and is significant only when the UART bit is set. In buffer mode, RDFL_RFC must be programmed to be greater than or equal to NEF (number of expected frames). In FIFO mode, there is no such constraint. NOTE When you have connected a debugger, RDFL_RFC decrements if you read RxFIFO through the debugger. | 011 : 3 bytes 100 : 4 bytes Others - Reserved RDFL_RFC can be programmed and is significant only when the UART bit is set. In buffer mode, RDFL_RFC must be programmed to be greater than or equal to NEF (number of expected frames). In FIFO mode, there is no such constraint. NOTE When you have connected a debugger, RDFL_RFC decrements if you read RxFIFO through the debugger. | 011 : 3 bytes 100 : 4 bytes Others - Reserved RDFL_RFC can be programmed and is significant only when the UART bit is set. In buffer mode, RDFL_RFC must be programmed to be greater than or equal to NEF (number of expected frames). In FIFO mode, there is no such constraint. NOTE When you have connected a debugger, RDFL_RFC decrements if you read RxFIFO through the debugger. |
| 9 RFBM  | Rx FIFO/Buffer Mode Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Rx Buffer mode enabled 1b - Rx FIFO mode enabled (mandatory in DMA Rx mode)                                                                                                                                                                                    | Rx FIFO/Buffer Mode Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Rx Buffer mode enabled 1b - Rx FIFO mode enabled (mandatory in DMA Rx mode)                                                                                                                                                                                    | Rx FIFO/Buffer Mode Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Rx Buffer mode enabled 1b - Rx FIFO mode enabled (mandatory in DMA Rx mode)                                                                                                                                                                                    |
| 8 TFBM  | Tx FIFO/Buffer Mode Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Tx Buffer mode enabled 1b - Tx FIFO mode enabled (mandatory in DMA Tx mode)                                                                                                                                                                                    | Tx FIFO/Buffer Mode Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Tx Buffer mode enabled 1b - Tx FIFO mode enabled (mandatory in DMA Tx mode)                                                                                                                                                                                    | Tx FIFO/Buffer Mode Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Tx Buffer mode enabled 1b - Tx FIFO mode enabled (mandatory in DMA Tx mode)                                                                                                                                                                                    |
| 7 WL1   | Word Length In UART Mode Works with WL0 to configure word length as shown in the following table. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                                                                                                                                                       | Word Length In UART Mode Works with WL0 to configure word length as shown in the following table. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                                                                                                                                                       | Word Length In UART Mode Works with WL0 to configure word length as shown in the following table. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                                                                                                                                                       |
| 7 WL1   | WL1                                                                                                                                                                                                                                                                                                                                                                                     | WL0                                                                                                                                                                                                                                                                                                                                                                                     | Description                                                                                                                                                                                                                                                                                                                                                                             |
| 7 WL1   | 0                                                                                                                                                                                                                                                                                                                                                                                       | 0                                                                                                                                                                                                                                                                                                                                                                                       | 7 bits data + parity                                                                                                                                                                                                                                                                                                                                                                    |
| 7 WL1   | 0                                                                                                                                                                                                                                                                                                                                                                                       | 1                                                                                                                                                                                                                                                                                                                                                                                       | 8 bits data when PCE = 0 or 8 bits data + parity when PCE = 1                                                                                                                                                                                                                                                                                                                           |
| 7 WL1   | 1                                                                                                                                                                                                                                                                                                                                                                                       | 0                                                                                                                                                                                                                                                                                                                                                                                       | 15 bits data + parity                                                                                                                                                                                                                                                                                                                                                                   |
| 7 WL1   | 1                                                                                                                                                                                                                                                                                                                                                                                       | 1                                                                                                                                                                                                                                                                                                                                                                                       | 16 bits data when PCE = 0 or 16 bits data + parity when PCE = 1                                                                                                                                                                                                                                                                                                                         |
| 6 PC1   | Parity Control Works with PC0 to configure parity as shown in the following table. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                                                                                                                                                                      | Parity Control Works with PC0 to configure parity as shown in the following table. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                                                                                                                                                                      | Parity Control Works with PC0 to configure parity as shown in the following table. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                                                                                                                                                                      |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                 | Function                                                                                                                                                                                                 | Function                                                                                                                                                                                                 |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | PC1                                                                                                                                                                                                      | PC0                                                                                                                                                                                                      | Description                                                                                                                                                                                              |
|         | 0                                                                                                                                                                                                        | 0                                                                                                                                                                                                        | Parity sent is Even                                                                                                                                                                                      |
|         | 0                                                                                                                                                                                                        | 1                                                                                                                                                                                                        | Parity sent is Odd                                                                                                                                                                                       |
|         | 1                                                                                                                                                                                                        | 0                                                                                                                                                                                                        | A logical 0 is always transmitted/ checked as parity bit                                                                                                                                                 |
|         | 1                                                                                                                                                                                                        | 1                                                                                                                                                                                                        | A logical 1 is always transmitted/ checked as parity bit                                                                                                                                                 |
| 5 RxEn  | Receiver Enable This bit can be programmed only when the UART bit is set. 0b - Receiver disabled                                                                                                         | Receiver Enable This bit can be programmed only when the UART bit is set. 0b - Receiver disabled                                                                                                         | Receiver Enable This bit can be programmed only when the UART bit is set. 0b - Receiver disabled                                                                                                         |
| 4 TxEn  | Transmitter Enable This bit can be programmed only when UART bit is set. 0b - Transmitter disabled 1b - Transmitter enabled, transmission starts only when this bit is set and BDRL[DATA0] is programmed | Transmitter Enable This bit can be programmed only when UART bit is set. 0b - Transmitter disabled 1b - Transmitter enabled, transmission starts only when this bit is set and BDRL[DATA0] is programmed | Transmitter Enable This bit can be programmed only when UART bit is set. 0b - Transmitter disabled 1b - Transmitter enabled, transmission starts only when this bit is set and BDRL[DATA0] is programmed |
| 3 PC0   | Parity Control Works with PC1 to configure parity. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                       | Parity Control Works with PC1 to configure parity. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                       | Parity Control Works with PC1 to configure parity. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                                       |
| 2 PCE   | Parity Control Enable Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Parity transmit/check disabled 1b - Parity transmit/check enabled             | Parity Control Enable Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Parity transmit/check disabled 1b - Parity transmit/check enabled             | Parity Control Enable Register bit can be read in any mode, written only in initialization mode when UART bit is set. 0b - Parity transmit/check disabled 1b - Parity transmit/check enabled             |
| 1 WL0   | Word Length in UART mode Works with WL1 to configure word length. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                        | Word Length in UART mode Works with WL1 to configure word length. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                        | Word Length in UART mode Works with WL1 to configure word length. Register bit can be read in any mode, written only in initialization mode when UART bit is set.                                        |
| 0 UART  | UART Mode Register bit can be read in any mode, written only in initialization mode. 0b - LIN mode 1b - UART mode                                                                                        | UART Mode Register bit can be read in any mode, written only in initialization mode. 0b - LIN mode 1b - UART mode                                                                                        | UART Mode Register bit can be read in any mode, written only in initialization mode. 0b - LIN mode 1b - UART mode                                                                                        |

## 48.5.7 UART Mode Status Register (UARTSR)

## Offset

| Register   | Offset   |
|------------|----------|
| UARTSR     | 14h      |

<!-- image -->

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                              |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-16 - | Reserved                                                                                                                                                                                                                                                                                              |
| 15 SZF  | Stuck At Zero Flag LINFlexD writes a 1 to this field when LINFlexD detects 100 dominant bits. It must be cleared by software. An interrupt is generated if the SZIE bit in LINIER is set. This bit will reflect the same value as in LINESR, when not in Initialization mode and the UART bit is set. |
| 14 OCF  | Output Compare Flag An interrupt will be generated if the OCIE bit in LINIER is set. This bit will reflect the same value as in LINESR, when not in Initialization mode and the UART bit is set. For Baud rate above 1 Mbit/s, this flag is not usable. NOTE 0b - No output compare event occurred    |

Table continues on the next page...

## Table continued from the previous page...

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 13-10 PE | Parity Error Flag Indicates whether a parity error occurred in the corresponding byte. No interrupt is generated if this error occurs. This bit will reflect the same value as in LINESR, when not in initialization mode and UART bit set. Parity is checked only after complete frame is received. Following are the conditions when WL bits = 01 or 11 (either PE0 or PE2 is only set).  When PE0 is set, it indicates Parity error in either the first or second received byte.  When PE2 is set, it indicates Parity error in either the third or fourth received byte. 0000b - No parity error                                                                                                                                       |
| 9 RMB    | Release Message Buffer This bit must be cleared by software. This bit reflects the same value as in LINSR, when not in Initialization mode and the UART bit is set. 0b - Buffer data is free 1b - Buffer data ready for software to read                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 8 FEF    | Framing Error Flag LINFlexD writes a 1 to this field when a framing error (invalid stop bit) occurs. It must be cleared by software. It generates an interrupt if the FEIE bit of LINIER is set. This bit will reflect the same value as in LINESR, when not in Initialization mode and the UART bit is set. 0b - No framing error 1b - Framing error occurs                                                                                                                                                                                                                                                                                                                                                                                 |
| 7 BOF    | FIFO/Buffer overrun flag This bit is set by hardware when there is a new byte received and the RMBbit is not cleared in UART buffer mode. In UART FIFO mode this bit is set when there is a new byte and the Rx FIFO is full. In UART FIFO mode, once Rx FIFO is full, the new received message will be discarded irrespective of the new value of the RBLM bit. In UART Rx Buffer mode, if RBLM is set then the new message received will be discarded; if RBLM is reset then the new message will overwrite the buffer. It can be cleared by software writing a 1. An interrupt is generated if the BOIE bit of LINIER is set. This bit will reflect the same value as in LINESR, when not in Initialization mode and the UART bit is set. |
| 6 RDI    | Receiver Data Input signal This bit reflects the current status of the RX pin when UART bit is set.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 5 WUF    | Wakeup flag                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |

Table continues on the next page...

## Table continued from the previous page...

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|          | This bit is set by hardware when a falling edge is detected on the RXpin in sleep mode. It should be cleared by software. An interrupt will be generated if the WUIE bit in LINIER is set. This bit will reflect the same value as in LINSR when not in Initialization mode and the UART bit is set.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 4 RFNE   | Receive FIFO Not Empty RFNE bit is set by hardware in UART FIFO mode (RFBM = 1), when there is at least one data byte present in the receive FIFO. RFNE is a read-only bit for debugging purposes. This flag can be used by software in case of a timeout event.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 3 TO     | Timeout This bit is set by hardware when a UARTtimeout occurs -inother words, the valueofUARTCTObecomes equal to the preset value of the timeout (UARTPTOregister setting). TOshould be cleared by software. The SRbit should be used to reset the receiver fsm to Idle state in case of UARTTIMEOUTfor UARTreception, depending on the application, in both buffer and FIFO mode. An interrupt will be generated when LINIER.TOIE bit is set on the Error interrupt line in UART mode.                                                                                                                                                                                                                                                                                                                                                                  |
| 2 DRFRFE | Data Reception Completed Flag /Rx FIFO Empty Flag DRF is set by hardware in UART buffer mode (RFBM = 0) and indicates that the number of bytes programmed in RDFL have been received. DRF should be cleared by software. An interrupt will be generated if the DRIE bit in LINIER is set. DRFbitis set whentheconfigured numberofvalid stop bits are received for the last frame (number of frames is configurable by RDFL bits). DRFis set irrespective of framing error in case framing error is in the last STOPbit configured, parity error or overrun error. This bit will reflect the same value as in LINSR when not in Initialization mode and the UART bit is set. RFE is set by hardware in UART FIFO mode (RFBM = 1) when the RX FIFO is empty. RFE is a read-only bit for debugging purposes. It is internally used by the DMA RX interface. |
| 1 DTFTFF | Data Transmission Completed Flag/ TX FIFO Full Flag DTFis set by hardware in UARTbuffer mode(TFBM=0)andindicates that data transmission is completed. DTF should be cleared by software. An interrupt will be generated if the DTIE bit in LINIER is set. This bit will reflect the same value as in LINSR when not in Initialization mode and the UART bit is set. TFF is set by hardware in UART FIFO mode (TFBM = 1) when TX FIFO is full. TFF is a read-only bit for debugging purposes. It is internally used by the DMA TX interface.                                                                                                                                                                                                                                                                                                              |
| 0 NF     | Noise flag This bit is set by hardware whennoise is detected in the received character. It should becleared by software. This bit will reflect the same value as in LINESR when not in Initialization mode and the UART bit is set. During reduced oversampling (ROSE bit = 1), it is enabled only when OSR = 8.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |

## 48.5.8 LIN Time-Out Control Status Register (LINTCSR)

## Offset

| Register   | Offset   |
|------------|----------|
| LINTCSR    | 18h      |

## Function

This register contains control and status bits for timeout feature.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | 0    | MODE | IOT  |      | CNT  | CNT  | CNT  | CNT  | CNT  | CNT  | CNT  | CNT  |
| W      |      |      |      |      |      |      |      | TOCE |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                                                                                                                                                                        |
|---------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-11 - | Reserved                                                                                                                                                                                                                                                                        |
| 10 MODE | Time-out counter mode This bit can be configured only during initialization. Register bit can be read in any mode, written only in initialization mode. 0b - LIN mode 1b - Output compare mode                                                                                  |
| 9 IOT   | Idle on timeout Register bit can be read in any mode, written only in initialization mode. This feature is applicable only when MODE bit in LINTCSR is cleared. 0b - LIN state machine does not reset to Idle on timeout 1b - LIN state machine resets to Idle on timeout event |
| 8 TOCE  | Time-out counter enable                                                                                                                                                                                                                                                         |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                     |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | TOCE is always configurable by software in Initialization mode. If LIN state is other than INIT and if timer is configured in LIN mode, then hardware takes control of TOCE. 0b - Time-out counter disable. OCF flag is not set on an output compare event. 1b - Time-out counter enable. OCF flag is set if an output compare event occurs. |
| 7-0 CNT | Counter Value These bits reflect the value of a counter used for timeout. For proper functionality of this counter, LINIBRR should be >= 5. NOTE                                                                                                                                                                                             |

## 48.5.9 LIN Output Compare Register (LINOCR)

## Offset

| Register   | Offset   |
|------------|----------|
| LINOCR     | 1Ch      |

## Function

This register contains the value to be compared to the LINTCSR:CNT value. This register is writable by software only in Output Compare Mode.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R W    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |

## Fields

| Field   | Function   |
|---------|------------|
| 31-16   | Reserved   |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function               |
|---------|------------------------|
| 15-8    | Output compare value 2 |
| OC2     |                        |
| 7-0     | Output compare value 1 |
| OC1     |                        |

## 48.5.10 LIN Time-Out Control Register (LINTOCR)

## Offset

| Register   | Offset   |
|------------|----------|
| LINTOCR    | 20h      |

<!-- image -->

## Fields

| Field    | Function                                                                                                                                                                           |
|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-12 -  | Reserved                                                                                                                                                                           |
| 11-8 RTO | Response timeout value This is the response timeout duration (in bit time) for 1 byte. The reset value is 0Eh = 14, corresponding to T Response_Maximum = 1.4 x T Response_Nominal |
| 7 -      | Reserved                                                                                                                                                                           |
| 6-0      | Header timeout value                                                                                                                                                               |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                             |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTO     | This register contains the header timeout duration (in bit time). This register can be written only for Slave mode. For slave, these bits should be programmed without considering 11 bits of break. |

## 48.5.11 LIN Fractional Baud Rate Register (LINFBRR)

## Offset

| Register   | Offset   |
|------------|----------|
| LINFBRR    | 24h      |

## Function

This register consists of bits that decide the fractional part of the LIN Baud Rate. It can be programmed only in Initialization mode.

NOTE

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| W      |      |      |      |      |      |      |      |      |      |      |      |      | FBR  | FBR  | FBR  | FBR  |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

<!-- image -->

## Fields

| Field   | Function              |
|---------|-----------------------|
| 31-4    | Reserved              |
| 3-0     | Fractional Baud rates |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FBR     | Register bit can be read in any mode, written only in initialization mode. 0000b - Fraction(LDIV) = 0 0001b - Fraction(LDIV) = 1/16 0010b - Fraction(LDIV) = 2/16 0011b - Fraction(LDIV) = 3/16 0100b - Fraction(LDIV) = 4/16 0101b - Fraction(LDIV) = 5/16 0110b - Fraction(LDIV) = 6/16 0111b - Fraction(LDIV) = 7/16 1000b - Fraction(LDIV) = 8/16 1001b - Fraction(LDIV) = 9/16 1010b - Fraction(LDIV) = 10/16 1011b - Fraction(LDIV) = 11/16 1100b - Fraction(LDIV) = 12/16 1101b - Fraction(LDIV) = 13/16 1110b - Fraction(LDIV) = 14/16 1111b - Fraction(LDIV) = 15/16 |

## 48.5.12 LIN Integer Baud Rate Register (LINIBRR)

## Offset

| Register   | Offset   |
|------------|----------|
| LINIBRR    | 28h      |

## Function

This register consists of control bits that decide the baud rate along with the LINFBRR. It can be programmed only in Initialization mode.

## NOTE

When LASE bit is set, this register should be read only after AUTOSYNC\_COMP bit in LINSR register is set to obtain the correct value.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |      |      |      |      |
| W      |      |      |      |      |      |      |      |      |      |      |      |      | IBR  | IBR  | IBR  | IBR  |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R W    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field    | Function                                                                                                                                                                                                                                                                                                                   |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-20 -  | Reserved                                                                                                                                                                                                                                                                                                                   |
| 19-0 IBR | Integer Baud rates These bits along with the fractional baud rate bits decide the LIN baud rate. IBR = 0h: LIN clock disabled IBR = 1h: Mantissa (LDIV) = 1 ... IBR = FFFFEh: Mantissa (LDIV) = 1048574 IBR = FFFFFh: Mantissa (LDIV) = 1048575 Register bit can be read in any mode, written only in initialization mode. |

## 48.5.13 LIN Checksum Field Register (LINCFR)

## Offset

| Register   | Offset   |
|------------|----------|
| LINCFR     | 2Ch      |

## Function

## NOTE

There is a delay between 4 to 6 clock cycles of LIN\_XBAR\_CLK for the internal checksum's value (which is clocked with LIN\_CLK/16 * LDIV) to reflect on LINCFR.

This register consists of checksum bits.

LINFlexD

## NOTE

Due to synchronization structures between the two input clocks to LINFlexD, the write to this register is delayed between 2 to 3 clock cycles and read is delayed between 4 to 6 clock cycles of LIN\_XBAR\_CLK .

|   CFD |   CCD | LINCHKSUM read/write   | Checksum sent       |
|-------|-------|------------------------|---------------------|
|     1 |     1 | read/write             | None                |
|     1 |     0 | read-only              | None                |
|     0 |     1 | read/write             | Programmed checksum |
|     0 |     0 | read-only              | Calculated checksum |

## Diagram

<!-- image -->

## Fields

| Field   | Function                                                                                                                                           |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-8    | Reserved                                                                                                                                           |
| 7-0     | Checksum bits                                                                                                                                      |
| CF      | When the CCD bit is reset these bits are read-only and are calculated by hardware. When the CCD bit is set, these bits can be written by software. |

## 48.5.14 LIN Control Register 2 (LINCR2)

## Offset

| Register   | Offset   |
|------------|----------|
| LINCR2     | 30h      |

## Function

This register includes control status bits related to buffer operations.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R W    | TBDE | IOBE | IOPE | WURQ | DDRQ | DTRQ | ABRQ | HTRQ | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Reset  | 0    | 1    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                                                                                                                                               |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-16 - | Reserved When accessing the LINCR2 register, each reserved bit should be written to its original reset value.                                                                                                                                          |
| 15 TBDE | Two Bit delimiter bit This bit can be set in Initialization mode only. Register bit can be read in any mode, written only in initialization mode. 0b - Delimiter length in break field is 1 bit 1b - Delimiter length in break field is 2 bits         |
| 14 IOBE | Idle on Bit Error This bit can be set in Initialization mode only. Register bit can be read in any mode, written only in initialization mode. 0b - Bit Error does not reset LIN state machine 1b - Bit Error resets LIN state machine                  |
| 13 IOPE | Idle on Identifier Parity Error This bit can be set in Initialization mode only. Register bit can be read in any mode, written only in initialization mode. If generic slave = 0, then this bit will always read a '0', and cannot be programmed. NOTE |

Table continues on the next page...

## NOTE

- When accessing the LINCR2 register, each reserved bit should be written to its original reset value.
- In Normal mode, write 1 to only those fields that you must configure and write 0 to all the other non-reserved fields. Because only the module clears these fields, writing 0 does not change their current values.

## LINFlexD

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | 0b - Parity Error does not reset LIN state machine 1b - Parity Error resets LIN state machine                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 12 WURQ | Wakeup Generate Request Setting this bit will generate a wakeup pulse. It is reset by hardware when the wakeup character has been transmitted. The character sent during wakeup is copied from BDRL (DATA0). Note that this bit cannot be set in Sleep mode -software has to exit Sleep mode before setting this bit. Bit Error is not checked when transmitting the wakeup request. Register bit can be read/set by software                                                                                                    |
| 11 DDRQ | Data Discard request Set by software to stop data reception if the frame does not concern the node. This bit is reset by hardware once LINFlexD ignores the response and moves to Idle state. For LIN slave this bit can be set only when HRF bit is set and Identifier is software-filtered. Register bit can be read/set by software                                                                                                                                                                                           |
| 10 DTRQ | Data Transmission Request Set by software in slave mode to request the transmission of the LIN Data field stored in the Buffer data register. This bit can be set only when the HRF bit is set (to ensure that data transmission is requested only after a header reception). Cleared by hardware when the request has been completed, or on abort request or error condition. In Master mode, this bit is set by hardware when the DIR bit is set and header transmission is complete. Register bit can be read/set by software |
| 9 ABRQ  | Abort Request Set by software to abort the current transmission. Cleared by hardware when the transmission has been aborted. LINFlexD aborts the transmission at the end of the current bit. This bit can abort a wakeup request also and can be used in UART mode also. Register bit can be read/set by software                                                                                                                                                                                                                |
| 8 HTRQ  | Header Transmission Request Set by software to request the transmission of the LIN Header. Cleared by hardware when the request has been completed or on abort request. This bit has no effect in UART mode. In master mode, if bothHTRQandABRQaresetatthesametimethenABRQhasnoeffect. Similarly, in slave mode after header reception, if DTRQ and ABRQ are simultaneously set then ABRQ has no effect. NOTE                                                                                                                    |
| 7-0     | Reserved When accessing the LINCR2 register, each reserved bit should be written to its original reset value.                                                                                                                                                                                                                                                                                                                                                                                                                    |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function   |
|---------|------------|
| -       |            |

## 48.5.15 Buffer Identifier Register (BIDR)

## Offset

| Register   | Offset   |
|------------|----------|
| BIDR       | 34h      |

## Function

This register contains the bits which provide information about the identifier of the transaction and other related information.

NOTE

<!-- image -->

## Fields

| Field   | Function                                                |
|---------|---------------------------------------------------------|
| 31-16   | Reserved                                                |
| -       |                                                         |
| 15-13   | Reserved                                                |
| -       |                                                         |
| 12-10   | Data Field Length                                       |
| DFL     | Number of data bytes in the response part of the frame. |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                    |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | DFL = Number of data bytes - 1                                                                                                                                                                                                                                                                                              |
| 9 DIR   | Direction This bit controls the direction of the data field. 0b - LINFlexD receives the data and copy them in the BDR registers 1b - LINFlexD transmits the data from the BDR registers                                                                                                                                     |
| 8 CCS   | Classic Checksum This bit controls the type of checksum applied on the current message. 0b - Enhanced Checksum covering Identifier and Data fields. This is compatible with LIN specification rev. 2.0 and higher. 1b - Classic Checksum covering Data filed only. This is compatible with LIN specification 1.3 and lower. |
| 7-6 -   | Reserved                                                                                                                                                                                                                                                                                                                    |
| 5-0 ID  | Identifier Identifier part of the identifier field without the identifier parity. This field can be written only in Master mode (MME = '1').                                                                                                                                                                                |

## 48.5.16 Buffer Data Register Least Significant (BDRL)

## Offset

| Register   | Offset   |
|------------|----------|
| BDRL       | 38h      |

## Function

This register is a part of an 8-byte data buffer. See Table 320 for register access in UART mode.

## Diagram

<!-- image -->

| Bits   | 31    | 30    | 29    | 28    | 27    | 26    | 25    | 24    | 23    | 22    | 21    | 20    | 19    | 18    | 17    | 16    |
|--------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| R W    | DATA3 | DATA3 | DATA3 | DATA3 | DATA3 | DATA3 | DATA3 | DATA3 | DATA2 | DATA2 | DATA2 | DATA2 | DATA2 | DATA2 | DATA2 | DATA2 |
| Reset  | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |
| Bits   | 15    | 14    | 13    | 12    | 11    | 10    | 9     | 8     | 7     | 6     | 5     | 4     | 3     | 2     | 1     | 0     |
| R W    | DATA1 | DATA1 | DATA1 | DATA1 | DATA1 | DATA1 | DATA1 | DATA1 | DATA0 | DATA0 | DATA0 | DATA0 | DATA0 | DATA0 | DATA0 | DATA0 |
| Reset  | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |

## Fields

| Field   | Function                                                                 |
|---------|--------------------------------------------------------------------------|
| 31-24   | Data Byte 3                                                              |
| DATA3   | Data byte 3 of the data field.                                           |
| 23-16   | Data Byte 2                                                              |
| DATA2   | Data byte 2 of the data field. Data Byte 1 Data byte 1of the data field. |
| 15-8    |                                                                          |
| DATA1   |                                                                          |
| 7-0     | Data Byte 0                                                              |
| DATA0   | Data byte 0 of the data field.                                           |

## 48.5.17 Buffer Data Register Most Significant (BDRM)

## Offset

| Register   | Offset   |
|------------|----------|
| BDRM       | 3Ch      |

## Function

This register is a part of an 8-byte data buffer. See Table 321 for register access in UART mode.

LINFlexD

## Diagram

<!-- image -->

| Bits   | 31    | 30    | 29    | 28    | 27    | 26    | 25    | 24    | 23    | 22    | 21    | 20    | 19    | 18    | 17    | 16    |
|--------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| R W    | DATA7 | DATA7 | DATA7 | DATA7 | DATA7 | DATA7 | DATA7 | DATA7 | DATA6 | DATA6 | DATA6 | DATA6 | DATA6 | DATA6 | DATA6 | DATA6 |
| Reset  | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |
| Bits   | 15    | 14    | 13    | 12    | 11    | 10    | 9     | 8     | 7     | 6     | 5     | 4     | 3     | 2     | 1     | 0     |
| R W    | DATA5 | DATA5 | DATA5 | DATA5 | DATA5 | DATA5 | DATA5 | DATA5 |       |       |       | DATA4 |       |       |       |       |
| Reset  | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |

## Fields

| Field   | Function                                   |
|---------|--------------------------------------------|
| 31-24   | Data Byte 7                                |
| DATA7   | Data byte 7 of the data field.             |
| 23-16   | Data Byte 6                                |
| DATA6   | Data byte 6 of the data field. Data Byte 5 |
| 15-8    |                                            |
| DATA5   | Data byte 5 of the data field.             |
| 7-0     | Data Byte 4                                |
| DATA4   | Data byte 4 of the data field.             |

## 48.5.18 Global Control Register (GCR)

## Offset

| Register   | Offset   |
|------------|----------|
| GCR        | 4Ch      |

## Function

This register is read-only in Normal mode and can be programmed only in Initialization mode. This is a global control register in other words, the register configuration will be applied in LIN mode as well as in UART mode.

The address offset depends on the no\_of\_filters. See chip configuration details for the number of filters used in this device.

## Table 331. Register fields reset by SR

| Register   | Comment                                              |
|------------|------------------------------------------------------|
| LINSR      | All fields except RXBUSY and AUTOSYNC_COMP are reset |

Table continues on the next page...

LINFlexD

Table 331. Register fields reset by SR (continued)

| LINESR   | All fields are reset                  |
|----------|---------------------------------------|
| LINTCSR  | Only CNT[0:7] is reset                |
| UARTSR   | All fields except RFE & TFF are reset |
| UARTCR   | Only TFC & RFC are reset              |
| UARTCTO  | All fields are reset                  |

## Diagram

<!-- image -->

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-6 -  | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 5 TDFBM | Transmit data first bit MSB This bit controls the first bit of transmit data (payload only) as MSB/LSB in both UART and LIN modes. Register bit can be read in any mode, written only in initialization mode. 0b - The first bit of transmitted data is LSB -in other words, the first bit transmitted is mapped on LSB bit (BDR (0), BDR (8), BDR (16), BDR (24)) 1b - The first bit of transmitted data is MSB -in other words, the first bit transmitted is mapped on MSB bit (BDR (7), BDR (15), BDR (23), BDR (31)) |
| 4 RDFBM | Received data first bit MSB This bit controls the first bit of received data (payload only) as MSB/LSB both in UART and LIN modes. Register bit can be read in any mode, written only in initialization mode. 0b - The first bit of received data is LSB -in other words, the first bit received is mapped on LSB bit (BDR (0), BDR (8), BDR (16), BDR (24))                                                                                                                                                             |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|---------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | 1b - The first bit of received data is MSB -in other words, the first bit received is mapped on MSB bit (BDR (7), BDR (15), BDR (23), BDR (31))                                                                                                                                                                                                                                                                                                               |
| 3 TDLIS | Transmit data level inversion selection This bit controls the data inversion of transmitted data (payload only) in both UART and LIN modes. Register bit can be read in any mode, written only in initialization mode. 0b - Transmitted data is not inverted 1b - Transmitted data is inverted                                                                                                                                                                |
| 2 RDLIS | Received data level inversion selection This bit controls the data inversion of received data (payload only) in both UART and LIN modes. Register bit can be read in any mode, written only in initialization mode. 0b - Received data is not inverted 1b - Received data is inverted                                                                                                                                                                         |
| 1 STOP  | 1/2 stop bit configuration This bit controls the number of stop bit transmitted data in both UART and LIN modes. The stop bit is configured for all the fields (Delimiter, Sync, ID, Checksum, Payload). Register bit can be read in any mode, written only in initialization mode. 0b - 1 stop bit 1b - 2 stop bits                                                                                                                                          |
| 0 SR    | Soft reset SR executes a soft reset of the LINFlexD controller (FSMs, FIFO pointers, counters, timers, status and error registers) without modifying the configuration registers when a 1 write operation is performed. This bit should be cleared by software to perform further operations (this bit is not cleared by hardware). Register bit can be written only be software in initialization mode. Table 331 describes the register fields reset by SR. |

## 48.5.19 UART Preset Timeout Register (UARTPTO)

## Offset

| Register   | Offset   |
|------------|----------|
| UARTPTO    | 50h      |

## Function

This register contains the preset value of the timeout register in UART mode and is programmed according to the number of bits to be received or to monitor the idle state of the reception line. This register can be written by software any time.

The address offset depends on no\_of\_filters. See chip configuration details for the number of filters used in the device.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    |      |      |      |      |      |      |      |      |      |      |      |      |
| W      |      |      |      |      | PTO  | PTO  | PTO  | PTO  | PTO  | PTO  | PTO  | PTO  | PTO  | PTO  | PTO  | PTO  |
| Reset  | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |

## Fields

| Field   | Function                                                                                                                                                       |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-12   | Reserved                                                                                                                                                       |
| 11-0    | Preset Timeout                                                                                                                                                 |
| PTO     | PTO defines the preset value of timeout counter. A zero-value is forbidden, otherwise the UARTSR[TO] status bit is immediately set. Also see register UARTCTO. |

## 48.5.20 UART Current Timeout Register (UARTCTO)

## Offset

| Register   | Offset   |
|------------|----------|
| UARTCTO    | 54h      |

## Function

This register contains the current timeout value in UART mode, and is used in conjunction with the UARTPTO register (see UART Preset Timeout Register (UARTPTO) to monitor the number of bits received by UART or to monitor the idle state of the reception line. UART timeout works in both CPU and DMA modes.

The timeout counter:

- Starts at zero and counts upward
- Is clocked with LIN\_CLK / (16 * LDIV) synchronized to LIN\_XBAR\_CLK (when ROSE = 0)
- Is clocked with LIN\_CLK / (OSR * IBRR) synchronized to LIN\_XBAR\_CLK (when ROSE = 1)
- Is automatically enabled when UARTCR[RXEN] = 1

## NOTE

Due to this synchronization there is a delay between 4 to 6 clock cycles of LIN\_XBAR\_CLK for the internal counter's value (which is clocked with LIN\_CLK/16 * LDIV when ROSE = 0 or LIN\_CLK/OSR * IBRR when ROSE = 1) to reflect on UARTCTO.

LINFlexD

## It is reset when:

- Number of frames received is equal to NEF bits
- UARTCTO becomes equal to UARTPTO
- Whenever UARTPTO is written
- When DRF is set and DTU bit = 1

The address offset depends on no\_of\_filters. See chip configuration details for the number of filters used in the device.

<!-- image -->

| NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    | NOTE    |
|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|
| Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram | Diagram |
| Bits    | 31      | 30      | 29      | 28      | 27      | 26      | 25      | 24      | 23      | 22      | 21 20   | 19      | 18      | 17      | 16      |
| R       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |
| W       |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |
| Reset   | 0       | 0       | 0 0     | 0       | 0       |         | 0       | 0 0     | 0       | 0       | 0       | 0       | 0       | 0       | 0       |
| Bits    | 15      | 14      | 13 12   | 11      |         | 10      | 9       | 8 7     | 6       | 5       | 4       | 3       | 2       | 1       | 0       |
| R       | 0       | 0       | 0       | 0       | CTO     | CTO     | CTO     | CTO     | CTO     | CTO     | CTO     | CTO     | CTO     | CTO     | CTO     |
| W       |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |
| Reset   | 0       | 0       | 0 0     | 0       | 0       |         | 0       | 0 0     | 0       | 0       | 0       | 0       | 0       | 0       | 0       |

## Fields

| Field    | Function                                                                                                                                                                                                                                                                            |
|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-12 -  | Reserved                                                                                                                                                                                                                                                                            |
| 11-0 CTO | Current Timeout CTO defines the current value of the timeout counter. CTO is a read-only field. CTO is reset every time UARTPTOis re-initialized, or UARTCTO=UARTPTO,or by hard/soft reset. When the CTOvalue matches the preset value (UARTPTO), the status bit UARTSR[TO] is set. |

## 48.5.21 DMA Tx Enable Register (DMATXE)

## Offset

| Register   | Offset   |
|------------|----------|
| DMATXE     | 58h      |

## Function

This register enables the DMA TX interface. This register can be written and read by software anytime.

The address offset depends on no\_of\_filters. See chip configuration details for the number of filters used in the device.

## Diagram

<!-- image -->

| Bits   | 31       | 30       | 29       | 28       | 27       | 26       | 25       | 24       | 23       | 22       | 21       | 20       | 19       | 18       | 17       | 16       |
|--------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
| R      | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved |
| W      |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          |
| Reset  | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        |
| Bits   | 15       | 14       | 13       | 12       | 11       | 10       | 9        | 8        | 7        | 6        | 5        | 4        | 3        | 2        | 1        | 0        |
| R      | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | DTE0     |
| W      |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          | DTE0     |
| Reset  | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        |

## Fields

| Field    | Function                                                                                                                                                                                                                                                                                                                                                        |
|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-1 -   | Reserved                                                                                                                                                                                                                                                                                                                                                        |
| 0-0 DTEn | DMA Tx channel enable The number of DTE bits varies, and is equal to DMA_TX_CH_NUM. When DMATXE = 0x00000000, the DMA TX interface FSM is forced (soft reset) in Idle state. See chip configuration details for the value of DMA_TX_CH_NUM used in this device. NOTE The value of n is 0. NOTE 0b - nth DMA Tx channel disabled 1b - nth DMA Tx channel enabled |

## 48.5.22 DMA Rx Enable Register (DMARXE)

## Offset

| Register   | Offset   |
|------------|----------|
| DMARXE     | 5Ch      |

## Function

This register enables the DMA RX interface. This register can be written and read by software any time.

The address offset depends on no\_of\_filters. See device configuration chapter for the number of filters used in the device.

LINFlexD

## Diagram

<!-- image -->

| Bits   | 31       | 30       | 29       | 28       | 27       | 26       | 25       | 24       | 23       | 22       | 21       | 20       | 19       | 18       | 17       | 16       |
|--------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
| R      | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved |
| W      |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          |
| Reset  | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        |
| Bits   | 15       | 14       | 13       | 12       | 11       | 10       | 9        | 8        | 7        | 6        | 5        | 4        | 3        | 2        | 1        | 0        |
| R      | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | Reserved | DRE0     |
| W      |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          | DRE0     |
| Reset  | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        |

## Fields

| Field    | Function                                                                                                                                                                                                                                                                                                                                                        |
|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-1 -   | Reserved                                                                                                                                                                                                                                                                                                                                                        |
| 0-0 DREn | DMA Rx channel enable The number of DRE bits varies, and is equal to DMA_RX_CH_NUM. When DMARXE = 0x00000000, the DMA RX interface FSM is forced (soft reset) in Idle state. See chip configuration details for the value of DMA_RX_CH_NUM used in this device. NOTE The value of n is 0. NOTE 0b - nth DMA Rx channel disabled 1b - nth DMA Rx channel enabled |

## 48.6 Programming considerations

The next subsections describe the various configurations in which the LINFlexD module can be used.

LINFlexD writes a 1 to multiple fields (such as status fields). It also writes a 0 to multiple other fields (such as LINCR2[HTRQ] and LINCR2[ABRQ]). Software must check the status of the bits before initiating the next sequence to ensure that LINFlexD completed its work. This ensures that LINFlexD and software are working in sync.

## 48.6.1 Master node

LINFlexD acts as master when LINCR1[MME]=1.

LINFlexD

## 48.6.1.1 Transmitter

<!-- image -->

## 48.6.1.2 Receiver

<!-- image -->

## 48.6.1.3 Transmitter, bit error

<!-- image -->

## 48.6.1.4 Receiver, checksum error

<!-- image -->

## 48.6.2 Slave node

## 48.6.2.1 Transmitter (no identifier filters)

<!-- image -->

## 48.6.2.2 Receiver (no identifier filters)

<!-- image -->

## 48.6.2.3 No filters, transmitter, bit error

The following figure shows Slave node - no filters, transmitter, bit error configuration.

<!-- image -->

## 48.6.2.4 No filters, receiver, checksum error

The following figure shows Slave node - no filters, receiver, checksum error configuration.

<!-- image -->

## 48.6.3 Timeout

Master Node: Response (during reception only) and frame timeout are checked.

Slave Node: Header, Response (during reception only), and frame timeout are checked.

<!-- image -->

LINFlexD

LINFlexD

<!-- image -->

## 48.6.4 UART mode

<!-- image -->

## 48.6.5 Interrupts

This section describes interrupt handling and interrupt concentration. Interrupt listed in Table 332 are corresponding to status registers LINSR, LINESR, and UARTSR. Corresponding interrupt enables bit are present in LINIER register. Instead of having multiple interrupt output lines, these interrupts are concentrated into three output signals as shown in Figure 435.

Table 332. Interrupts

| Interrupt event   | Event flag   | Enable control bit   | Interrupt vector   |
|-------------------|--------------|----------------------|--------------------|
| Stuck at zero     | SZF          | SZIE                 | Error              |
| Output compare    | OCF          | OCIE                 | Error              |

Table continues on the next page...

Table 332. Interrupts (continued)

| Interrupt event         | Event flag                                               | Enable control bit   | Interrupt vector                                  |
|-------------------------|----------------------------------------------------------|----------------------|---------------------------------------------------|
| Bit error               | BEF                                                      | BEIE                 | Error                                             |
| Checksum error          | CEF                                                      | CEIE                 | Error                                             |
| Header error            | SFEF or SDEF or IDPEF                                    | HEIE                 | Error                                             |
| Frame error             | FEF                                                      | FEIE                 | Error                                             |
| Buffer overrun error    | BOF                                                      | BOIE                 | Error                                             |
| UART timeout error      | TO                                                       | TOIE                 | Error                                             |
| LIN state               | Sync Del, Sync Field, Identifier field or Checksum Field | LSIE                 | Rx                                                |
| Wakeup                  | WUF                                                      | WUIE                 | Rx                                                |
| Data reception complete | DRF                                                      | DRIE                 | Rx                                                |
| Data transmitted        | DTF                                                      | DTIE                 | Tx                                                |
| Header received         | HRF                                                      | HRIE                 | Rx                                                |
| Header received         | HRF                                                      | HRIE                 | Tx (if there is a filter match for Tx identifier) |

The following figure shows an interrupt flow diagram.

LINFlexD

LINFlexD

<!-- image -->

Rx interrupt due to LIN state event is cleared by writing LINSR[LINS] field with 0xF when LSIE is enabled. In loopback mode, Rx interrupt is set earlier than Tx interrupt.

## 48.6.6 LINFlexD clock tolerance

## 48.6.6.1 Faster receiver tolerance

In this case, the receiver has a higher baud rate than the transmitter, thus the stop bit sampling starts already in the last transmitted payload bit. To ensure the correct noise and framing error free reception bit, the samples RS8, RS9, and RS10 must be located in the transmitted stop bit as shown in the following figure.

LINFlexD

<!-- image -->

## 48.6.6.2 Slower receiver tolerance

In this case, the receiver has a slower baud rate than the transmitter. Therefore, the stop bit sampling is still running while transmission of the next start bit is already occurring. To ensure the correct noise and framing error free reception bit , the samples RS8, RS9, and RS10 must be located in the transmitted stop bit as shown in the following figure.

<!-- image -->

## Chapter 49 Serial Peripheral Interface (SPI)

## 49.1 Chip-specific SPI information

## 49.1.1 Module instance information

This chip contains six instances of SPI. The following table shows the configuration of each instance.

| Description                                       | SPI_0        | SPI_1        | SPI_2        | SPI_3        | SPI_4        | SPI_5        |
|---------------------------------------------------|--------------|--------------|--------------|--------------|--------------|--------------|
| Extended (32-bit) SPI mode support                | 1            | 1            | 1            | 1            | 1            | 1            |
| CSI and DSI mode support                          | 0            | 0            | 0            | 0            | 0            | 0            |
| TX FIFO                                           | 5            | 5            | 5            | 5            | 5            | 5            |
| RX FIFO                                           | 5            | 5            | 5            | 5            | 5            | 5            |
| CMD FIFO                                          | 5            | 5            | 5            | 5            | 5            | 5            |
| CTAR registers (transfer attribute configuration) | 6            | 6            | 6            | 6            | 6            | 6            |
| PCS signals                                       | 8            | 5            | 5            | 5            | 5            | 5            |
| Mode                                              | Master/Slave | Master/Slave | Master/Slave | Master/Slave | Master/Slave | Master/Slave |

## 49.2 Introduction

The SPI module provides a synchronous serial bus for communication between a chip and an external peripheral device.

## 49.2.1 Block diagram

The following figure represents the module's block diagram.

Serial Peripheral Interface (SPI)

<!-- image -->

## 49.2.2 Features

The module supports the following features:

- Full-duplex, three-wire synchronous transfers
- Master mode
- Slave mode
- Data streaming operation in the Slave mode with continuous slave selection
- Buffered transmit operation using transmit first in first out (TX FIFO) with a depth of 5 entries
- Support for 8- or 16-bit accesses to PUSHR\_SLAVE[TXDATA]
- Buffered receive operation using the Receive FIFO (RX FIFO) with a depth of 5 entries
- TX and RX FIFOs can be disabled individually for low-latency updates to SPI queues
- Visibility into TX and RX FIFOs for ease of debugging
- Programmable transfer attributes on a per-frame basis:
- 6 transfer attribute registers
- 6 extended transfer attribute registers
- Serial clock (SCK) with programmable polarity and phase
- Various programmable delays

- Programmable serial frame size: 4 to 32
- SPI frames longer than 32 bits can be supported using the continuous selection format.
- Continuously held chip-select capability
- Parity control
- 8 peripheral chip selects (PCSes), expandable to 2 ^ (8 - 1) with an external demultiplexer
- Deglitching support for up to 8 peripheral chip selects (PCSes) with external demultiplexer
- DMA support for adding entries to TX FIFO and removing entries from RX FIFO when:
- TX FIFO is not full (TFFF)
- RX FIFO is not empty (RFDF)
- Command (CMD) FIFO is not full (CMDFFF)
- Interrupt conditions:
- End of queue reached (EOQF)
- TFFF
- CMDFFF
- Transfer of current frame complete (TCF)
- Transfers due from current command frame complete (CMDTCF)
- Attempt to transmit with an empty transmit FIFO (TFUF)
- RFDF
- Frame received while RX FIFO is full (RFOF)
- SPI Parity Error (SPEF)
- Data present in TX FIFO while CMD FIFO is empty (TFIWF)
- Global interrupt request line
- Modified SPI transfer formats for communication with slower peripheral devices

## 49.2.3 Interface configurations

## 49.2.3.1 SPI configuration

The SPI configuration allows the module to send and receive serial data. This configuration allows the module to operate as a basic SPI block with internal FIFOs supporting the external queue operation. Transmitted data and received data are included in separate FIFOs. The host CPU or a DMA controller reads the received data from the RX FIFO and writes transmit data to the transmit FIFO.

For queued operations, the SPI queues can be included in system RAM, external to the module. A DMA controller or host CPU accomplishes data transfers between the queues and the module FIFOs. The following figure shows a system example with DMA, SPI, and external queues in system RAM.

Serial Peripheral Interface (SPI)

Serial Peripheral Interface (SPI)

<!-- image -->

## 49.3 Module signal descriptions

This table describes the signals on the boundary of the module that may connect off chip (in alphabetical order).

## Table 333. Module signal descriptions

| Signal      | Master mode                                            | Slave mode       | I/O   |
|-------------|--------------------------------------------------------|------------------|-------|
| PCS0/SS_b   | Peripheral Chip Select 0 (O)                           | Slave Select (I) | I/O   |
| PCS1        | Peripheral Chip Select 1                               | Unused           | O     |
| PCS2        | Peripheral Chip Select 2                               | Unused           | O     |
| PCS3        | Peripheral Chip Select 3                               | Unused           | O     |
| PCS4        | Peripheral Chip Select 4                               | Unused           | O     |
| PCS5/PCSS_b | Peripheral Chip Select 5/Peripheral Chip Select Strobe | Unused           | O     |
| PCS[6:7]    | Peripheral Chip Selects 6-7                            | Unused           | O     |
| SCK         | Serial Clock (O)                                       | Serial Clock (I) | I/O   |
| SIN         | Serial Data In                                         | Serial Data In   | I     |
| SOUT        | Serial Data Out                                        | Serial Data Out  | O     |

## 49.3.1 PCS0/SS\_b

Master mode: Peripheral Chip Select 0 (O)-Selects SPI slave to receive data transmitted from the module

Slave mode: Slave Select (I)-Selects the module to receive data transmitted from the SPI master

## NOTE

Do not tie the SPI slave select pin to ground. Otherwise, SPI cannot function properly.

## 49.3.2 PCS1

Master mode: Peripheral Chip Select 1 (O)-Selects SPI slave to receive data that the module transmits

Slave mode: Unused

## 49.3.3 PCS2

Master mode: Peripheral Chip Select 2 (O)-Selects SPI slave to receive data that the module transmits

Slave mode: Unused

## 49.3.4 PCS3

Master mode: Peripheral Chip Select 3 (O)-Selects SPI slave to receive data that the module transmits

Slave mode: Unused

## 49.3.5 PCS4

Master mode: Peripheral Chip Select 4 (O)-Selects SPI slave to receive data that the module transmits

Slave mode: Unused

## 49.3.6 PCS5/PCSS\_b

## Master mode:

- Peripheral Chip Select 5 (O)-Used only when the peripheral-chip-select strobe is disabled (MCR[PCSSE]). Selects SPI slave to receive data transmitted by the module.
- Peripheral Chip Select Strobe (O)-Used only when the peripheral-chip-select strobe is enabled (MCR[PCSSE]). Strobes an off-module peripheral-chip-select demultiplexer, which decodes the module's PCS signals other than PCS5, preventing glitches on the demultiplexer outputs.

Slave mode: Unused

## 49.3.7 PCS6-PCS7

Master mode: Peripheral Chip Selects 6-7 (O)-Selects an SPI slave to receive data transmitted by the module

Slave mode: Unused

## 49.3.8 SCK

Master mode: Serial Clock (O)-Supplies a clock signal from the module to SPI slaves

Slave mode: Serial Clock (I)-Supplies a clock signal to the module from the SPI master

## 49.3.9 SIN

Master mode: Serial Input (I)-Receives serial data

Slave mode: Serial Input (I)-Receives serial data

## 49.3.10 SOUT

Master mode: Serial Output (O)-Transmits serial data

Slave mode: Serial Output (O)-Transmits serial data

Serial Peripheral Interface (SPI)

## 49.4 Functional description

The module supports full-duplex, synchronous serial communications between chips and peripheral devices. The SPI configuration transfers data serially using a shift register and a selection of programmable transfer attributes.

The module includes the following configuration:

- SPI configuration in which the module operates as a basic SPI or a queued SPI

MCR[DCONF] determines the module configuration. SPI configuration is selected when the value of MCR[DCONF] is 0.

The CTARn registers hold clock and transfer attributes. The SPI configuration allows to select which CTAR to use, on a frame-by-frame basis, by setting a field in the SPI command. MCR[XSPI] further allows the usage of CTAREn registers. This allows you to send multiple data frames using a single command frame.

Typical master-to-slave connections are shown in the following figure. When a data transfer operation is performed, data is serially shifted to a predetermined number of bit positions. Because the modules are linked, data is exchanged between the master and the slave. The data that was included in the master shift register is now in the shift register of the slave, and vice versa. At the end of a transfer, if the value of SR[TCF] is 1, it indicates a completed frame transfer.

<!-- image -->

Generally, more than one slave device can be connected to the module master, and 8 PCS signals of the module masters can be used to select which of the slaves to communicate with.

The SPI configuration shares transfer protocol and timing properties that are described independently of the configuration in Transfer formats. The transfer rate and delay settings are described in Module baud rate and clock delay generation.

## 49.4.1 Modes of operation

The module supports the following modes of operation that can be divided into two categories:

- Module-specific modes:
- Master mode
- Slave mode
- Module Disable mode
- Chip-specific modes:
- Debug mode

The module enters module-specific modes when the host writes to a module register. The signals external to the module control the chip-specific modes. The chip may enter these modes in parallel to the module-specific modes.

## 49.4.1.1 Master mode

The Master mode allows the module to initiate and control serial communication. In this mode, the module controls the following signals, which the module configures as outputs:

- SCK

Serial Peripheral Interface (SPI)

- SOUT
- PCS[x]

## 49.4.1.2 Slave mode

The Slave mode allows the module to communicate with SPI bus masters. In this mode, the module responds to externally controlled serial transfers. The module configures the SCK signal and the PCS[0]/SS\_b signals as inputs, which are driven by the SPI bus master.

## 49.4.1.3 Module Disable mode

The Module Disable mode can be used for chip-power management. In this mode, you can stop the clock to the non-memory mapped logic in the module.

## 49.4.1.4 Debug mode

The Debug mode is used for system development and debugging. MCR[FRZ] controls module behavior when the chip is in this mode.

- If you write a 1 to this field, the module stops all serial transfers .
- If you write a 0 to the field, this mode has no effect on the module.

## 49.4.2 Starting and stopping module transfers

The module has two operating states: Stopped and Running. Both the states are independent of their configuration. The default state of the module is Stopped. In this state, the module initiates no serial transfers in the Master mode and responds to no transfers in the Slave mode. The Stopped state is also a safe state for writing to the various configuration registers of the module, without causing undetermined results. In the Running state, serial transfers take place.

SR[TXRXS] indicates the state of the module. The value of this field is 1 if the module is in the Running state.

The module starts or transitions to the Running state when all of the following conditions are true:

- The value of SR[EOQF] = 0.
- The chip is not in the Debug mode or the value of MCR[FRZ] = 0.
- The value of MCR[HALT] = 0.

The module stops or transitions from the Running state to the Stopped state after the current frame, when any one of the following conditions exist:

- The value of SR[EOQF] = 1.
- The chip is in Debug mode and the value of MCR[FRZ] = 1.
- The value of MCR[HALT] = 1.

State transitions from running to stopped occur on the next frame boundary if a transfer is in progress, and occur immediately if no transfers are in progress.

## 49.4.3 SPI configuration

The SPI configuration transfers data serially using a shift register and a selection of programmable transfer attributes. The module is in SPI configuration when the value of MCR[DCONF] is 0. The SPI frames can be 32-bit long. The host CPU or a DMA controller transfers the external SPI data to the module RAM queues and to a TX FIFO buffer. The received data is stored in the entries of the RX FIFO buffer. The host CPU or the DMA controller transfers the received data from the RX FIFO to a memory external to the module. The operation of FIFO buffers is described in the following sections:

- TX FIFO buffering mechanism
- CMD FIFO buffering mechanism

Serial Peripheral Interface (SPI)

##  RX FIFO buffering mechanism

The interrupt and DMA request conditions are described in Interrupts/DMA requests.

The SPI configuration supports two module-specific modes-Master mode and Slave mode. In the Master mode, the module initiates and controls the transfer according to the fields of the executing SPI command. In the Slave mode, the module responds only to transfers initiated by a bus master external to it, and the SPI command field is reserved.

## 49.4.3.1 Master mode

In the SPI Master mode, the module initiates serial transfers by controlling the SCK and the PCS signals. The executing SPI command determines which CTARs will be used to set the transfer attributes and which PCS signals to assert. The command field also contains various bits that help with queue management and transfer protocol. See PUSH TX FIFO Register In Master Mode (PUSHR) for details on the SPI command fields. The data in the executing TX FIFO entry is loaded into the shift register and shifted out on the SOUT pin. In the SPI Master mode, each SPI frame to be transmitted has a command associated with it, allowing for transfer attribute control on a frame by frame basis. In the Extended SPI Master mode, multiple SPI frames can have a single command associated with them allowing efficient SPI frame transfers requiring common transfer attributes. In addition, the Extended SPI mode allows larger frame sizes of up to 32 bits.

## 49.4.3.2 Slave mode

In the SPI Slave mode, the module responds to transfers that an SPI bus master initiates. It does not initiate transfers. Certain transfer attributes such as clock polarity, clock phase, and frame size must be configured for successful communication with SPI master. The SPI Slave mode transfer attributes are configured in the CTAR0 and CTARE0 registers. The data shifts out with MSB first, and the module does not support shifting out of LSB.

## 49.4.3.3 FIFO disable operation

The FIFO disable mechanisms allow SPI transfers without using the TX FIFO, CMD FIFO, or RX FIFO. The module operates as a double-buffered, simplified SPI when the FIFOs are disabled. The transmit and receive sides of the FIFOs are disabled separately. Writing a 1 to MCR[DIS\_TXF] disables the TX FIFO and CMD FIFO, and writing a 1 to MCR[DIS\_RXF] disables the RX FIFO.

The FIFO disable mechanisms are transparent to you and to the host software. Transmit data and commands are written to the PUSHR and received data is read from the POPR.

When the TX FIFO and CMD FIFO are disabled:

- SR[TFFF], SR[TFUF], SR[CMDFFF], SREX[CMDCTR], and SR[TXCTR] behave as if there is a one-entry FIFO.
- The contents of TXFRs, SR[TXNXTPTR], and SREX[CMDNXTPTR] are undefined.

Similarly, when the RX FIFO is disabled, SR[RFDF], SR[RFOF], and SR[RXCTR] behave as if there is a one-entry FIFO, but the contents of the RXFR registers and SR[POPNXTPTR] are undefined.

## 49.4.3.4 TX FIFO buffering mechanism

The TX FIFO functions as a buffer of SPI data for transmission. It holds 5 words, each consisting of SPI data. The number of entries in the TX FIFO is chip-specific. SPI data is added to the TX FIFO by writing to the data field of PUSHR. TX FIFO entries can only be removed from the TX FIFO if they are shifted out or by flushing the TX FIFO.

SR[TXCTR] indicates the number of valid entries in the TX FIFO. The field updates every time an 8- or 16-bit write takes place on PUSHR[TXDATA] or SPI data is transferred into the Shift register from the TX FIFO.

SR[TXNXTPTR] indicates the TX FIFO entry that will be transmitted during the next transfer. The TXFRn registers are invalid in the Extended SPI mode because the TX FIFO and CMD FIFO can be used independently. The TXNXTPTR field increments every time SPI data is transferred from the TX FIFO to the Shift register. The maximum value of this field is equal to the maximum implemented TXFR number and it rolls over after reaching the maximum.

## 49.4.3.4.1 Filling the TX FIFO

Host software or other intelligent blocks can add (push) entries to the TX FIFO and CMD FIFO by writing to the PUSHR. When the TX FIFO is not full, the value of DR[TFFF] is set to 1, and the value is set to 0 when TX FIFO is full and the DMA controller

Serial Peripheral Interface (SPI)

Serial Peripheral Interface (SPI)

indicates that a write to PUSHR is complete. You can also write a 1 to clear the field, which can generate a DMA request or an interrupt request. See Transmit FIFO fill interrupt or DMA request for details.

The module ignores attempts to push data to a full TX FIFO, and the state of the TX FIFO does not change and no error condition occurs.

## 49.4.3.4.2 Draining the TX FIFO

The module removes (drains) the TX FIFO entries by shifting SPI data out through the Shift register. It transfers entries from the TX FIFO to the Shift register, and the entries are shifted out as long as there are valid entries in the TX FIFO. Every time an entry is transferred from the TX FIFO to the Shift register, the TX FIFO counter decrements by 1. When the value of MCR[XSPI] is 1, and if the frame size of SPI data to be transmitted is more than 16 bits, then it causes two data entries to be popped from TX FIFO simultaneously. These entries are transferred to the Shift register. The first of the two popped entries forms the 16 least significant bits of the SPI frame to be transmitted. Such an operation also causes the TX FIFO counter to decrement by 2. At the end of a transfer, the value of SR[TCF] is set to indicate the completion of a transfer. The TX FIFO is flushed by writing a 1 to MCR[CLR\_TXF].

If an external bus master initiates a transfer with a module slave while the slave's TX FIFO is empty, the value of SR[TFUF] is configured as 1. See Transmit FIFO underflow interrupt request for details.

## 49.4.3.5 CMD FIFO buffering mechanism

The CMD FIFO functions as a buffer of SPI command used for SPI data transmission. When Extended SPI Mode (MCR[XSPI]) is disabled, the TX FIFO and CMD FIFO must be filled together, i.e. write enables should be given for both the Data and Command fields while performing a PUSHR operation.When Extended SPI Mode (MCR[XSPI]) is enabled, the TX FIFO and CMD FIFO can be filled independently.

The CMD FIFO holds 5 words, each representing SPI command fields. The number of entries in the CMD FIFO is chip-specific. SPI command is added to the CMD FIFO by writing to the command field of PUSHR. CMD FIFO entries can only be removed from the CMD FIFO by being shifted out (to help transmit SPI data) or by flushing the CMD FIFO.

When Extended SPI Mode (MCR[XSPI]) is disabled, every CMD FIFO entry has a corresponding single TX FIFO entry attached to it because both these FIFO's are filled simultaneously.

When Extended SPI Mode (MCR[XSPI]) is enabled, every CMD FIFO entry can have multiple TX FIFO entries attached to it. Thus a single CMD FIFO entry can be used to transmit multiple TX FIFO entries. The CTARE[DTCP] field decides the number of SPI Data Frames having frame size as {FMSZE, FMSZ} to be transmitted using the current Command Entry. The CTAR/CTARE registers pointed by the CTAS field in the Command frame gives the FMSZ and FMSZE fields respectively. The time for which a command entry is in use is known as a Command Cycle. The Busy Flag SR[BSYF] is asserted for the duration of the Command Cycle except for the last SPI frame in the Command Cycle.

The CMD FIFO Counter field (CMDCTR) in the SPI Status Register extended(SREX) indicates the number of valid entries in the CMD FIFO. The CMDCTR field is updated every time a 8- or 16-bit write takes place on the lower half of SPI\_PUSHR or SPI data is transferred into the shift register from the TX FIFO.

The TXFRn Registers are invalid in the Extended SPI Mode, since the TX FIFO and CMD FIFO can be used independently. The CMDNXTPTR field indicates which CMD FIFO Entry will be used during the next command cycle. The CMDNXTPTR field is incremented every time the last SPI data in the command cycle is transferred from the TX FIFO to the shift register and it rolls over after reaching the maximum.

## 49.4.3.6 RX FIFO buffering mechanism

The RX FIFO functions as a buffer for data received on the SIN pin. The FIFO holds 5 received SPI data frames. The number of entries in the RX FIFO is chip-specific. SPI data is added to the RX FIFO at the completion of a transfer when the received data in the Shift register is transferred into the RX FIFO. SPI data is removed (popped) from the RX FIFO by reading the POPR. RX FIFO entries can only be removed from the RX FIFO by reading the POPR or by flushing the RX FIFO.

SR[RXCTR] indicates the number of valid entries in the RX FIFO. The field is updated every time the POPR is read or SPI data is copied from the Shift register to the RX FIFO.

SR[POPNXTPTR] points to the RX FIFO entry that is returned when the POPR is read. The field contains the positive offset from RXFR0 in a number of 32-bit registers. For example, POPNXTPTR = 2 means that the RXFR2 contains the received SPI data that is returned after the POPR is read. The POPNXTPTR field increments every time the POPR is read. The maximum value of the field is equal to the maximum implemented RXFR number and it rolls over after reaching the maximum.

## 49.4.3.6.1 Filling the RX FIFO

The RX FIFO is filled with the received SPI data from the Shift register. While the RX FIFO is not full, SPI frames from the Shift register are transferred to the RX FIFO. Every time a SPI frame is transferred to the RX FIFO, the RX FIFO counter is incremented by 1.

If  the RX FIFO and Shift register are full and a transfer is initiated, the value of SR[RFOF] equals 1, indicating an overflow condition. Depending on the state of MCR[ROOE], the data from the transfer that generated the overflow is either ignored or shifted to the Shift register. If the value of the ROOE field is 1, the incoming data is shifted in to the Shift register. If the value of ROOE is 0, the incoming data is ignored.

## 49.4.3.6.2 Draining the RX FIFO

Host CPU or a DMA can remove (pop) entries from the RX FIFO by reading the POPR. A read of the POPR decrements the RX FIFO counter by 1. Attempts to pop data from an empty RX FIFO are ignored and the RX FIFO counter remains unchanged. The data, read from the empty RX FIFO, is undetermined.

When the RX FIFO is not empty, the value of SR[RFDF] is 1. The value of the RFDF field turns 0 when the RX FIFO is empty and the DMA controller indicates that a read from POPR is complete or by writing a 1 to it.

## 49.4.4 Module baud rate and clock delay generation

The SCK frequency and the delay values for serial transfer are generated by dividing the system clock frequency by a prescaler and a scaler with the option for doubling the baud rate. The following figure shows conceptually how the SCK signal is generated.

<!-- image -->

## 49.4.4.1 Baud rate generator

The baud rate is the frequency of the SCK. The protocol clock is divided by a prescaler (PBR) and scaler (BR) to produce SCK with the possibility of halving the scaler division. The DBR, PBR, and BR fields in the CTARs select the frequency of SCK by the formula in the BR field description. The following table shows an example of how to compute the baud rate.

## Table 334. Baud rate computation example

| f P     | PBR   |   Prescaler | BR     |   Scaler |   DBR | Baud rate   |
|---------|-------|-------------|--------|----------|-------|-------------|
| 100 MHz | 0b00  |           2 | 0b0000 |        2 |     0 | 25 Mb/s     |
| 20 MHz  | 0b00  |           2 | 0b0000 |        2 |     1 | 10 Mb/s     |

## NOTE

The clock frequencies mentioned in the preceding table are provided as an example. See the Clocking chapter for the frequency used to drive this module in the chip.

## 49.4.4.2 PCS to SCK delay (tCSC)

The "PCS to SCK delay" is the duration from assertion of the PCS signal to the first SCK edge. See Figure 443 for an illustration of the PCS to SCK delay. The PCSSCK and CSSCK fields in the CTARx registers select the PCS to SCK delay by the formula in the CSSCK field description. The following table shows an example of how to compute the PCS to SCK delay.

## Table 335. PCS to SCK delay computation example

| f SYS   | PCSSCK   |   Prescaler | CSSCK   |   Scaler | PCS to SCK Delay   |
|---------|----------|-------------|---------|----------|--------------------|
| 100 MHz | 0b01     |           3 | 0b0100  |       32 | 0.96 s            |

## NOTE

The clock frequency mentioned in the preceding table is given as an example. See the Clocking chapter for the frequency used to drive this module in the chip.

## 49.4.4.3 After SCK delay (tASC)

The "After SCK Delay" is the duration between the last edge of SCK and the negation of PCS. See Figure 443 and Figure 444 for illustrations of this type of delay. The PASC and ASC fields in the CTARx registers select the "After SCK Delay" by the formula in the ASC field description. The following table shows an example of how to compute the "After SCK Delay".

## Table 336. After SCK Delay computation example

| f P     | PASC   |   Prescaler | ASC    |   Scaler | After SCK Delay   |
|---------|--------|-------------|--------|----------|-------------------|
| 100 MHz | 0b01   |           3 | 0b0100 |       32 | 0.96 s           |

## NOTE

The clock frequency mentioned in the preceding table is given as an example. See the Clocking chapter for the frequency used to drive this module in the chip.

## 49.4.4.4 Delay after transfer (t DT)

The "Delay after Transfer" is the minimum time between negation of the PCS signal for a frame and the assertion of the PCS signal for the next frame. See Figure 443 for an illustration of this type of delay. The PDT and DT fields in the CTARx registers select the "Delay after Transfer" by the formula in the DT field description. The following table shows an example of how to compute the "Delay after Transfer".

## Table 337. "Delay after Transfer" computation example

| f P     | PDT   |   Prescaler | DT     |   Scaler | Delay after Transfer   |
|---------|-------|-------------|--------|----------|------------------------|
| 100 MHz | 0b01  |           3 | 0b1110 |    32768 | 0.98 ms                |

## NOTE

The clock frequency mentioned in the preceding table is given as an example. See the Clocking chapter for the frequency used to drive this module in the chip.

When in Non-Continuous Clock mode, the tDT delay is configured according to the equation specified in the CTAR[DT] field description. When in Continuous Clock mode, the delay is fixed at 1 SCK period.

## 49.4.4.5 PCSS enable (PCSS\_b)

The PCSS\_b signal provides a delay to allow the PCS signals to settle after a transition occurs, thereby avoiding glitches. When the module is in the Master mode and the value of MCR[PCSSE] is 1, PCSS\_b provides a signal for an external demultiplexer to

Serial Peripheral Interface (SPI)

decode peripheral chip selects other than PCS5 into glitch-free PCS signals. The following figure shows the timing of the PCSS\_b signal relative to PCS signals.

<!-- image -->

CTAR[PCSSCK] selects the delay between the assertion of the PCS signals and the assertion of PCSS\_b based on the following formula:

<!-- formula-not-decoded -->

At the end of the transfer, CTAR[PASC] selects the delay between PCSS\_b negation and PCS negation based on the following formula:

<!-- formula-not-decoded -->

The following table shows an example of how to compute the t pcssck delay.

## Table 338. PCSS assert computation example

| f P     | PCSSCK   |   Prescaler | Delay before transfer   |
|---------|----------|-------------|-------------------------|
| 100 MHz | 0b11     |           7 | 70.0 ns                 |

The following table shows an example of how to compute the t pasc delay.

Table 339. PCSS negate computation example

| f P     | PASC   |   Prescaler | Delay after transfer   |
|---------|--------|-------------|------------------------|
| 100 MHz | 0b11   |           7 | 70.0 ns                |

The PCSS\_b signal is not supported when the Continuous SCK mode is enabled.

## NOTE

The clock frequency mentioned in the tables above is an example. See the Clocking chapter for details on the frequency used to drive this module in the chip.

## 49.4.5 Transfer formats

The SPI serial communication is controlled by the SCK signal and the PCS signals. The SCK signal provided by the master device synchronizes shifting and sampling of the data on the SIN and SOUT pins. The PCS signals serve as enable signals for the slave devices.

In Master mode, CTARn[CPOL] and CTARn[CPHA] select the polarity and phase of the serial clock, SCK.

- CPOL - Selects the idle state polarity of the SCK

- CPHA - Selects if the data on SOUT is valid before or on the first SCK edge

Even if the bus slave does not control the SCK signal, in Slave mode, the values of CPOL and CPHA must be identical to the master device settings to ensure proper transmission. In SPI Slave mode, only CTAR0 is used.

The module supports four different transfer formats:

- Classic SPI with CPHA = 0
- Classic SPI with CPHA = 1
- Modified Transfer Format with CPHA = 0
- Modified Transfer Format with CPHA = 1

A modified transfer format is supported to allow for high-speed communication with peripherals that require longer setup times. The module can sample the incoming data later than halfway through the cycle to give the peripheral more setup time. The MCR[MTFE] selects between the classic SPI format and modified transfer format.

In the interface configurations, the module provides the option of having the PCS signals asserted between frames. See Continuous selection format for details.

## 49.4.5.1 Classic SPI transfer format (CPHA = 0)

The transfer format shown in the following figure is used to communicate with peripheral SPI slave devices where the first data bit is available on the first clock edge. In this format, the master and slave sample their SIN pins on the odd-numbered SCK edges and change the data on their SOUT pins on the even-numbered SCK edges.

<!-- image -->

The master initiates the transfer by placing its first data bit on the SOUT pin and asserting the appropriate PCS signals to the slave device. The slave responds by placing its first data bit on its SOUT pin. After the t CSC delay elapses, the master outputs the first edge of SCK. The master and slave devices use this edge to sample the first input data bit on their serial data input signals. At the second edge of the SCK, the master and slave devices place their second data bit on their serial data output signals. For the rest of the frame, the master and the slave sample their SIN pins on the odd-numbered clock edges and change the data on their SOUT

pins for the even-numbered clock edges. After the last clock edge occurs, a delay of t ASC is inserted before the master negates the PCS signals. A delay of t DT is inserted before a new frame transfer can be initiated by the master.

## 49.4.5.2 Classic SPI transfer format (CPHA = 1)

This transfer format shown in the following figure is used to communicate with peripheral SPI slave devices that require the first SCK edge before the first data bit becomes available on the slave SOUT pin. In this format, the master and slave devices change the data on their SOUT pins on the odd-numbered SCK edges and sample the data on their SIN pins for the even-numbered SCK edges.

<!-- image -->

The master initiates the transfer by asserting the PCS signal to the slave. After the t CSC delay elapses, the master generates the first SCK edge and at the same time places valid data on the master SOUT pin. The slave responds to the first SCK edge by placing its first data bit on its slave SOUT pin.

At the second edge of the SCK, the master and slave sample their SIN pins. For the rest of the frame, the master and the slave change the data for their SOUT pins on the odd-numbered clock edges and sample their SIN pins on the even-numbered clock edges. After the last clock edge occurs, a delay of t ASC is inserted before the master negates the PCS signal. A delay of t DT is inserted before the master can initiate a new frame transfer.

## 49.4.5.3 Modified SPI transfer format (MTFE = 1, CPHA = 0)

In the modified transfer format, both the master and the slave sample later in the SCK period than in Classic SPI mode to allow the logic to tolerate more delays in device pads and board traces. These delays become a more significant fraction of the SCK period as the SCK period decreases with increasing baud rates.

The master and the slave place data on the SOUT pins at the assertion of the PCS signal. After the PCS to SCK delay elapses, the first SCK edge is generated. The slave samples the master SOUT signal on every odd-numbered SCK edge. The SPI in the Slave mode, when the value of MTFE is 1, also places new data on the slave SOUT on every odd-numbered clock edge. Regular external slave, configured with CPHA=0 format, drives its SOUT output at every even-numbered SCK clock edge.

The SPI master places its second data bit on the SOUT line, one protocol clock after the odd-numbered SCK edge, if the protocol clock frequency to SCK frequency ratio is higher than 3. If this ratio is below 4, the master changes SOUT at the even-numbered SCK edge. MCR[SMPL\_PT] selects the point where the master samples the SIN. The master sample point can be delayed by one or two protocol clock cycles. The value of SMPL\_PT must be 0 if the protocol to SCK frequency ratio is less than 4. However if this ratio is less than 4, the actual sample point is delayed by one protocol clock cycle automatically by the design.

The timing delays are as follows:

- Tcsc - PCS to SCK assertion delay
- Tacs - After SCK PCS negation delay
- Tsu\_ms - master SIN setup time
- Thd\_ms - master SIN hold time
- Tvd\_sl - slave data output valid time, time between slave data output SCK driving edge and when data becomes valid
- Tsu\_sl - data setup time on slave data input
- Thd\_sl - data hold time on slave data input
- Tsys - protocol clock period

The following timing diagrams illustrate the SPI operation with MCR[MTFE] = 1 and show the modified transfer format for CPHA = 0 and Fsys/Fsck = 4. Only the condition where CPOL = 0 is illustrated. Solid triangles show the data sampling clock edges, and here are the two possible slave behaviors:

- Signal, marked "SOUT of Ext Slave" presents regular SPI slave serial output.
- Signal, marked "SOUT of SPI Slave" presents SPI in the slave mode with MTFE = 1.

Other MTFE = 1, diagrams show SPI SIN input as being driven by a regular external SPI slave, configured according to SPI master CPHA programming.

## NOTE

In the following diagrams, f sys represents the protocol clock frequency from which the baud frequency f sck is derived.

<!-- image -->

<!-- image -->

## 49.4.5.4 Modified SPI transfer format (MTFE = 1, CPHA = 1)

The following figures show the modified transfer format for CPHA = 1. Only the condition where CPOL = 0 is shown. At the start of a transfer, the SPI asserts the PCS signal to the slave device. After the PCS to SCK delay elapses, the master and the slave put data on their SOUT pins at the first edge of SCK. The slave samples the master SOUT signal on the even-numbered edges of SCK. The master samples the slave SOUT signal on the odd-numbered SCK edges starting with the third SCK edge. The slave samples the last bit on the last edge of the SCK. The master samples the last slave SOUT bit on half SCK cycle after the last edge of SCK. No clock edge is visible on the master SCK pin during the sampling of the last bit. The PCS to SCK delay and the after SCK delay must be greater or equal to half of the SCK period.

Serial Peripheral Interface (SPI)

<!-- image -->

## 49.4.5.5 Continuous selection format

Some peripherals must be deselected between every transfer. Other peripherals must remain selected between several sequential serial transfers. The continuous selection format provides the flexibility to handle the following case. The format is enabled for the SPI configuration by setting the CONT bit in the SPI command.

When the value of CONT is 0, the module drives the asserted Chip Select signals to their idle states in between frames. The idle states of these signals are selected by the PCSISnn fields in the MCR. The following figure shows the timing diagram for two 4-bit transfers with CPHA = 1 and CONT = 1.

<!-- image -->

When CONT = 1, the PCS signal remains asserted for the duration of the two transfers. The "Delay between Transfers" (t DT) is not inserted between the transfers. The following figure shows the timing diagram for two 4-bit transfers with CPHA = 1 and CONT = 1.

<!-- image -->

When using the module with continuous selection, follow these rules:

- All transmit commands must have the same PCSn field programming.
- The CTARs, selected by transmit commands, must be programmed with the same transfer attributes. Only the FMSZ and LSBFE field can be programmed differently in these CTARs.

Serial Peripheral Interface (SPI)

- When transmitting multiple frames in this mode, the software must ensure that the last frame has PUSHR[CONT] deasserted in Master mode and the software must provide sufficient frames in the TX\_FIFO to be sent out in Slave mode and the master deasserts the PCSn at end of transmission of the last frame.
- PUSHR[CONT] must be deasserted before asserting MCR[HALT] in master mode. This ensures that the PCSn signals are deasserted. Asserting MCR[HALT] during continuous transfer causes the PCSn signals to be in unknown state and hence the slave device cannot transition from Running to Stopped state.

## NOTE

You must fill the TX FIFO with the number of entries that are concatenated together under one PCS assertion for both master and slave before the TX FIFO is empty.

When operating in Slave mode, ensure that when the last entry in the TX FIFO is completely transmitted, that is, the corresponding TCF flag is asserted and TXFIFO is empty, the slave is deselected for any further serial communication; otherwise, an underflow error occurs.

## 49.4.5.6 Fast continuous selection format

The fast continuous selection format has a functioning similar to the continuous selection format except that the inter command delays, t ASC and t CSC, can be masked out and are not inserted by the hardware.

## NOTE

The fast continuous selection format is available in the SPI configuration only when the Continuous SCK mode is disabled. Masking of delays is not allowed if the transfer is non-continuous.

The fast continuous selection format is enabled by writing a 1 to MCR[FCPCS]. When this field is asserted, the MASC and MCSC fields of the PUSHR perform the function of mask bits for the transmit frame. These fields individually mask the tASC and tCSC delays as programmed by the software. A normal continuous selection format includes these two delays for each frame, which is transmitted with the CONT field asserted. To avoid these delays and to speed up the transfer process, the software can mask these delays while programming the command in the PUSHR.

While masking the delays, the software must follow these masking rules, otherwise, correct operation is not guaranteed.

- The MASC field masks the 'After SCK' delay for the current frame.
- The MCSC field masks the 'PCS to SCK' delay for the next frame.
- The t ASC delay must not be masked when the current frame is the last frame in the continuous selection format.
- The "PCS to SCK" delay for the first frame in the continuous selection format cannot be masked.
- Masking of only t ASC is not allowed. If it is masked, then tCSC must be masked too.
- Masking of both t ASC and t CSC delays is allowed. In this case, the delay between two frames is equal to half the baud rate (baud rate is 1 SCK cycle duration) configured by the software.
- Masking of only t CSC is allowed. In this case, the delay between two frames is equal to the t ASC time and thus the software must ensure that the t ASC time is greater than the baud rate.
- The software must not mask these delays if the continuous selection format is not used and MCR[FCPCS] is asserted.
- Rules applicable to the continuous selection format are applicable here too.

The following figure shows the timing for a fast continuous selection format transfer. Here, seven frames are transferred with both t ASC and t CSC delays masked except for the last frame that terminated the transfer. The last frame has t ASC delay at its end.

Serial Peripheral Interface (SPI)

<!-- image -->

In case any chip select is to be changed, first the fast continuous selection format should be terminated and appropriate delays must be introduced.

## 49.4.6 Continuous SCK

The module provides the option of generating a Continuous SCK signal for slave peripherals that require a continuous clock.

Continuous SCK is enabled by writing a 1 to MCR[CONT\_SCKE]. Enabling this field generates the Continuous SCK only if MCR[HALT] is low. Continuous SCK is valid for all configurations.

Continuous SCK is only supported for CPHA = 1. Clearing CPHA is ignored if the value of the CONT\_SCKE field is 1. Continuous SCK is supported for Modified Transfer Format

Clock and transfer attributes for the Continuous SCK mode are set according to the following rules:

- When the module is in SPI configuration, CTAR0 is used initially. At the start of each SPI frame transfer, the CTAR specified by the CTAS for the frame is used.
- In all configurations, the currently selected CTAR remains in use until the start of a frame with a different CTAR specified, or the Continuous SCK mode is terminated.

It is recommended to keep the baud rate the same while using continuous SCK. Switching clock polarity between frames while using continuous SCK can cause errors in the transfer. The Continuous SCK operation is not guaranteed if the module is put into the Module Disable mode.

Enabling continuous SCK disables the PCS to SCK delay, and the Delay after Transfer (t DT) is fixed to one SCK cycle. The following figure is the timing diagram for the Continuous SCK format with continuous selection disabled.

## NOTE

In the Continuous SCK mode, for the SPI transfer, CTAR0 should always be used and the TX FIFO must be cleared through MCR[CLR\_TXF] before initiating a transfer.

Serial Peripheral Interface (SPI)

<!-- image -->

If the CONT bit in the TX FIFO entry is set, PCS remains asserted between the transfers. Under certain conditions, SCK can continue with PCS asserted, but with no data being shifted out of SOUT, which means when SOUT is pulled high. This can cause the slave to receive incorrect data. Those conditions include:

- Continuous SCK with CONT bit set, but no data in the TX FIFO
- Continuous SCK with CONT bit set and entering the Stopped state (see Starting and stopping module transfers)
- Continuous SCK with CONT bit set and entering the Module Disable mode

The following figure shows the timing diagram for the Continuous SCK format with continuous selection enabled.

<!-- image -->

## 49.4.7 Slave mode operation constraints

The slave mode logic shift register is buffered. This allows the data streaming operation when the module is permanently selected and data is shifted in with a constant rate.

The transmit data is transferred at the second SCK clock edge of each frame to the Shift register if the SS\_b signal is asserted, and at and any time when transmit data is ready and the SS\_b signal is negated.

Received data is transferred to the receive buffer at last SCK edge of each frame, defined by frame size programmed to the CTAR0/1 register. Then the data from the buffer is transferred to the RXFIFO or DDR.

If the SS\_b signal negates before that last SCK edge, the data from the Shift register is lost.

## 49.4.8 Parity generation and check

The module can generate and check parity in the serial frame. The parity bit replaces the last transmitted bit in the frame. The parity is calculated for all transmitted data bits in frame, not including the last data bit that would be transmitted. The parity generation and control are done on a frame basis. The registers field setting frame size defines the total number of bits in the frame, including the parity bit. Thus, to transmit or receive the same number of data bits with parity check, increase the frame size by one versus the same data size frame without the parity check.

Parity can be selected as odd or even. Parity errors in the received frame set parity error flags in the Status register. The parity error interrupt requests are generated, if enabled. The module can be programmed to stop frame transmission in case of a frame reception with parity error.

## 49.4.8.1 Parity for SPI frames

When the module is in the master mode the parity generation is controlled by PE and PP bits of the CMD FIFO entries (PUSHR). Setting the PE bit enables parity generation for transmitted SPI frames and parity check for received frames. The PP bit defines polarity of the parity bit.

When continuous PCS selection is used to transmit SPI data, two parity generation scenarios are available:

- Generate or check parity for the whole frame
- Generate or check parity for each sub-frame separately

To generate or check parity for the whole frame, set PE bit only in the last command or TX FIFO entry, forming this frame with the PUSHR.

To generate or check parity for each sub-frame, set PE bit in each command or TX FIFO entry, forming this frame.

If the parity error occurs for received SPI frame, SR[SPEF] is set. If the value of MCR[PES] is 1, the module stops SPI frames transmission. To resume SPI operation, clear SR[SPEF] or MCR[PES].

In Slave mode, the parity is controlled by CTAR0[PE] and CTAR0[PP], as in the case of master mode parity generation without continuous PCS selection.

## 49.4.9 Clocking

This table describes the clock signals on the boundary of the module:

## Table 340. SPI clocks

| Clock            | Description                                               |
|------------------|-----------------------------------------------------------|
| Serial Clock (O) | Supplies a clock signal from the module to SPI slaves     |
| Serial Clock (I) | Supplies a clock signal to the module from the SPI master |

## 49.4.10 Interrupts/DMA requests

The module has several conditions that can generate only interrupt requests and two conditions that can generate interrupt or DMA requests. The following table lists these conditions.

Table 341. Interrupt and DMA request conditions

| Condition          | Flag   | Interrupt   | DMA   |
|--------------------|--------|-------------|-------|
| End of Queue (EOQ) | EOQF   | Yes         | -     |
| TX FIFO Fill       | TFFF   | Yes         | Yes   |
| CMD FIFO Fill      | CMDFFF | Yes         | Yes   |

Table continues on the next page...

Serial Peripheral Interface (SPI)

Table 341. Interrupt and DMA request conditions (continued)

| Condition             | Flag   | Interrupt   | DMA   |
|-----------------------|--------|-------------|-------|
| TX FIFO Invalid Write | TFIWF  | Yes         | -     |
| Transfer Complete     | TCF    | Yes         | -     |
| CMD Transfer Complete | CMDTCF | Yes         | -     |
| TX FIFO Underflow     | TFUF   | Yes         | -     |
| RX FIFO Drain         | RFDF   | Yes         | Yes   |
| RX FIFO Overflow      | RFOF   | Yes         | -     |
| SPI Parity Error      | SPEF   | Yes         | -     |

Each condition has a corresponding field in the SR and a Request Enable field in the RSER. Certain fields, as shown in the above table, generate interrupt requests or DMA requests depending on the configuration of this register.

The module also provides a global interrupt request line, which is asserted when any of individual interrupt requests lines is asserted.

## 49.4.10.1 EOQ interrupt request

The EOQ interrupt request indicates that the end of a transmit queue is reached. The module generates the interrupt request when the value of RSER[EOQF\_RE] is 1 and the value of the EOQ field in the executing SPI command is 1.

If the value of MCR[XSPI] is 1 and the value of the EOQ field in the executing SPI command is 1, the module generates the EOQ interrupt request after the last bit of the last data frame in the command cycle is transmitted.

When the value of MCR[XSPI] is 0, the module generates the interrupt request after the last bit of the SPI frame, with the value of EOQ as 1, is transmitted.

## 49.4.10.2 Transmit FIFO fill interrupt or DMA request

The transmit FIFO fill request indicates that the TX FIFO is not full. This request is generated when the number of entries in the TX FIFO is less than the maximum number of possible entries, and the value of RSER[TFFF\_RE] is 1.

RSER[TFFF\_DIRS] selects whether a DMA request or an interrupt request is generated.

## NOTE

TFFF clears automatically when DMA is used to fill TX FIFO. You must configure the DMA to fill only one FIFO location per transfer.

To clear TFFF when not using DMA, follow these steps for every PUSH performed using CPU to fill TX FIFO:

1. Wait until the value of TFFF is 1.
2. Write data to PUSHR using CPU.
3. Clear TFFF by writing a 1 to its location. If TX FIFO is not full, the flag does not clear.

## 49.4.10.3 CMD FIFO fill interrupt or DMA request

The CMD FIFO fill request indicates that the CMD FIFO is not full. This request is generated when the number of entries in the CMD FIFO is less than the maximum number of possible entries, and the value of RSER[CMDFFF\_RE] is 1. RSER[CMDFFF\_DIRS] selects whether a DMA request or an interrupt request is generated.

Serial Peripheral Interface (SPI)

Serial Peripheral Interface (SPI)

The request is useful when the value of MCR[XSPI] is 1 because TX FIFO and CMD FIFO can be filled independently. If the value of MCR[XSPI] is 0, the TX FIFO fill interrupt or DMA request suffices to fill both the FIFOs, which must be filled simultaneously.

## NOTE

The CMDFFF flag clears automatically when DMA is used to fill CMD FIFO. Configure the DMA to fill only one FIFO location per transfer.

To clear CMDFFF when not using DMA, follow these steps for every PUSH performed using CPU to fill CMD FIFO:

1. Wait until the value of CMDFFF is 1.
2. Write data to PUSHR using CPU.
3. Clear CMDFFF by writing a 1 to its location. If CMD FIFO is not full, this flag does not clear.

## 49.4.10.4 Transmit FIFO invalid write interrupt request

The transmit FIFO invalid write request is valid only when the value of MCR[XSPI] is 1. This request indicates that data exists in the TX FIFO while the CMD FIFO is empty. Because no command fields are associated with the data present in TX FIFO, this data is considered invalid until a command entry is available. The transmit FIFO invalid write request is generated for this condition when the value of RSER[TFIWF\_RE] is 1.

## 49.4.10.5 Transfer complete interrupt request

The transfer complete request indicates the end of the transfer of a serial frame. This request is generated at the end of each frame transfer when the value of RSER[TCF\_RE] is 1.

## 49.4.10.6 Command transfer complete interrupt request

The command transfer complete request indicates the end of transfer of the last SPI frame in a command cycle. This request is generated when the value of RSER[CMDTCF\_RE] is 1.

## 49.4.10.7 Transmit FIFO underflow interrupt request

The transmit FIFO underflow request indicates that an underflow condition in the TX FIFO has occurred. The transmit underflow condition is detected only for the module operating in the Slave mode and according to the SPI configuration. The value of SR[TFUF] is 1 when the TX FIFO of the module is empty, and a transfer is initiated from an external SPI master. If the value of SR[TFUF] is 1 while the value of RSER[TFUF\_RE] is 1, an interrupt request is generated.

## 49.4.10.8 Receive FIFO drain interrupt or DMA request

The receive FIFO drain request indicates that the RX FIFO is not empty. This request is generated when the number of entries in the RX FIFO is not 0, and the value of RSER[RFDF\_RE] is 1.

RSER[RFDF\_DIRS] selects whether a DMA request or an interrupt request is generated. You must configure the DMA to drain only one FIFO location per transfer.

## 49.4.10.9 Receive FIFO overflow interrupt request

The receive FIFO overflow request indicates that an overflow condition in the RX FIFO has occurred. This request is generated when RX FIFO and the Shift register are full, and a transfer is initiated. The value of RSER[RFOF\_RE] must be equal to 1 for the interrupt request to be generated.

Depending on the state of MCR[ROOE], the data from the transfer that generated the overflow is either ignored or shifted to the Shift register. If the value of the ROOE field is 1, the incoming data is shifted in to the Shift register. If the value of the ROOE field is 0, the incoming data is ignored.

## 49.4.10.10 SPI frame parity error interrupt request

The SPI Frame Parity Error Flag indicates that a SPI frame with parity error had been received. The SPEF\_RE bit in the RSER must be set for the interrupt request to be generated.

## 49.4.11 Power saving features

This module supports the following power-saving strategies:

- Module Disable mode: clock gating of non-memory mapped logic

All power-saving features require a logic external to SPI.

## 49.4.11.1 Module Disable mode

This is a block-specific mode that the module can enter to save power. The host CPU can initiate the Module Disable mode by writing a 1 to MCR[MDIS]. The hardware can also initiate this mode.

When the value of the MDIS field is 1, the module negates the Clock Enable signal at the next frame boundary. After the Clock Enable signal is negated, it is said to have entered the Module Disable Mode. This also puts the module in the Stopped state. The value of SR[TXRXS] must be 0 to indicate the Stopped state. If implemented, the Clock Enable signal can stop the clock to the non-memory mapped logic. When Clock Enable is negated, the module is in a dormant state, but the memory mapped registers are still accessible. Certain read or write operations have a different effect when the module is in the Module Disable mode.

TX FIFO or CMD FIFO. Clearing either of the FIFOs has no effect in the Module Disable mode. Also, changes to MCR[DIS\_TXF] and MCR[DIS\_RXF] have no effect in the Module Disable mode. In this mode, all status bits and register flags in the module return the correct values when read, but writing to them has no effect. Also, writing to the TCR during the Module Disable mode has no effect. Interrupt and DMA request signals cannot be cleared in the Module Disable mode.

Reading the POPR does not change the state of the RX FIFO. Similarly, writing to the PUSHR does not change the state of the

## 49.5 Initialization/application information

This section describes how to initialize the module.

## 49.5.1 How to manage queues

Queues are not a part of this module, but the module includes features to support queue management.

Queues are primarily supported in SPI configuration, and here are the steps to manage them.

1. When the module executes the last command word from a queue, the EOQ bit in the command word indicates that it is the last entry in the queue.
2. At the end of the transfer, the value of SR[EOQF] is configured as 1.
3. If the value of SR[EOQF] is 1, the field disables serial transmission and reception of data, putting the module in the Stopped state. The value 0 is written to SR[TXRXS] indicating the Stopped state.
4. The DMA can continue to fill TX FIFO until it is full or step 5 occurs.
5. Disable DMA transfers by disabling the DMA enable request for the DMA channel assigned to TX FIFO, CMD FIFO, and RX FIFO. This is done by clearing the corresponding DMA enable request bits in the DMA controller.
6. Ensure that all the received data in RX FIFO has been transferred to the memory receive queue by reading SR[RXCNT] or by checking SR[RFDF] after each read operation of the POPR.
7. Modify the DMA descriptor of TX and RX channels for new queues.
8. Flush TX FIFO and CMD FIFO by writing a 1 to MCR[CLR\_TXF] and flushing RX FIFO by writing a 1 to MCR[CLR\_RXF].
9. Clear the transfer count either by setting the CTCNT bit in the command word of the first entry in the new queue or via the CPU writing directly to TCR[SPI\_TCNT].
10. Enable the DMA channel through the DMA enable request. DMA channels are assigned to modules TX FIFO, CMD FIFO, and RX FIFO. For each module, a separate DMA enable request bit is available.

Serial Peripheral Interface (SPI)

11. Enable serial transmission and serial reception of data by clearing the EOQF field.

## 49.5.2 Switching Master and Slave modes

When changing modes in the module, follow these steps to guarantee a proper operation.

1. Halt it by writing a 1 to MCR[HALT].
2. Clear the transmit and receive FIFOs by writing a 1 to MCR[CLR\_TXF] and MCR[CLR\_RXF].
3. Set the appropriate mode in MCR[MSTR] and enable it by writing a 0 to MCR[HALT].

## 49.5.3 Initializing module in Master/Slave modes

After the appropriate mode in MCR[MSTR] is configured, the module is enabled by writing a 0 to MCR[HALT]. The module's slave must be enabled before you enable its master. This ensures that the slave is ready to be communicated with, before the master initializes communication.

## 49.5.4 Baud rate settings

The following table shows the baud rate that is generated based on the combination of the baud rate prescaler, PBR, and the baud rate scaler, BR, in the CTARs. The values calculated assume a 100 MHz protocol frequency, and the value of the DBR field is 0..

## NOTE

The clock frequency provided in this chapter is an example. See the Clocking chapter for details on the frequency used to drive this module in the chip.

## Table 342. Baud rate values (bit/s)

|      | Baud rate divider prescaler values   | Baud rate divider prescaler values   | Baud rate divider prescaler values   | Baud rate divider prescaler values   |
|------|--------------------------------------|--------------------------------------|--------------------------------------|--------------------------------------|
|      | 2                                    | 3                                    | 5                                    | 7                                    |
| 2    | 25.0M                                | 16.7M                                | 10.0M                                | 7.14M                                |
| 4    | 12.5M                                | 8.33M                                | 5.00M                                | 3.57M                                |
| 6    | 8.33M                                | 5.56M                                | 3.33M                                | 2.38M                                |
| 8    | 6.25M                                | 4.17M                                | 2.50M                                | 1.79M                                |
| 16   | 3.12M                                | 2.08M                                | 1.25M                                | 893k                                 |
| 32   | 1.56M                                | 1.04M                                | 625k                                 | 446k                                 |
| 64   | 781k                                 | 521k                                 | 312k                                 | 223k                                 |
| 128  | 391k                                 | 260k                                 | 156k                                 | 112k                                 |
| 256  | 195k                                 | 130k                                 | 78.1k                                | 55.8k                                |
| 512  | 97.7k                                | 65.1k                                | 39.1k                                | 27.9k                                |
| 1024 | 48.8k                                | 32.6k                                | 19.5k                                | 14.0k                                |
| 2048 | 24.4k                                | 16.3k                                | 9.77k                                | 6.98k                                |

Table continues on the next page...

Serial Peripheral Interface (SPI)

Table 342. Baud rate values (bit/s) (continued)

|       | Baud rate divider prescaler values   | Baud rate divider prescaler values   | Baud rate divider prescaler values   | Baud rate divider prescaler values   |
|-------|--------------------------------------|--------------------------------------|--------------------------------------|--------------------------------------|
|       | 2                                    | 3                                    | 5                                    | 7                                    |
| 4096  | 12.2k                                | 8.14k                                | 4.88k                                | 3.49k                                |
| 8192  | 6.10k                                | 4.07k                                | 2.44k                                | 1.74k                                |
| 16384 | 3.05k                                | 2.04k                                | 1.22k                                | 872                                  |
| 32768 | 1.53k                                | 1.02k                                | 610                                  | 436                                  |

## 49.5.5 Delay settings

The following table shows the values for the Delay after Transfer (t DT) and CS to SCK Delay (TCSC) that can be generated based on the prescaler values and the scaler values set in the CTARs. The values calculated assume a 100 MHz protocol frequency.

## NOTE

The clock frequency mentioned in this section is only an example. See the clocking chapter for the frequency used to drive this module in the chip.

Table 343. Delay values

|      | Delay scaler values (CTAR[PDT])   | Delay scaler values (CTAR[PDT])   | Delay scaler values (CTAR[PDT])   | Delay scaler values (CTAR[PDT])   |
|------|-----------------------------------|-----------------------------------|-----------------------------------|-----------------------------------|
|      | 1                                 | 3                                 | 5                                 | 7                                 |
| 2    | 20.0 ns                           | 60.0 ns                           | 100.0 ns                          | 140.0 ns                          |
| 4    | 40.0 ns                           | 120.0 ns                          | 200.0 ns                          | 280.0 ns                          |
| 8    | 80.0 ns                           | 240.0 ns                          | 400.0 ns                          | 560.0 ns                          |
| 16   | 160.0 ns                          | 480.0 ns                          | 800.0 ns                          | 1.1 s                            |
| 32   | 320.0 ns                          | 960.0 ns                          | 1.6 s                            | 2.2 s                            |
| 64   | 640.0 ns                          | 1.9 s                            | 3.2 s                            | 4.5 s                            |
| 128  | 1.3 s                            | 3.8 s                            | 6.4 s                            | 9.0 s                            |
| 256  | 2.6 s                            | 7.7 s                            | 12.8 s                           | 17.9 s                           |
| 512  | 5.1 s                            | 15.4 s                           | 25.6 s                           | 35.8 s                           |
| 1024 | 10.2 s                           | 30.7 s                           | 51.2 s                           | 71.7 s                           |
| 2048 | 20.5 s                           | 61.4 s                           | 102.4 s                          | 143.4 s                          |
| 4096 | 41.0 s                           | 122.9 s                          | 204.8 s                          | 286.7 s                          |
| 8192 | 81.9 s                           | 245.8 s                          | 409.6 s                          | 573.4 s                          |

Table continues on the next page...

Table 343. Delay values (continued)

|       | Delay scaler values (CTAR[PDT])   | Delay scaler values (CTAR[PDT])   | Delay scaler values (CTAR[PDT])   | Delay scaler values (CTAR[PDT])   |
|-------|-----------------------------------|-----------------------------------|-----------------------------------|-----------------------------------|
|       | 1                                 | 3                                 | 5                                 | 7                                 |
| 16384 | 163.8 s                          | 491.5 s                          | 819.2 s                          | 1.1 ms                            |
| 32768 | 327.7 s                          | 983.0 s                          | 1.6 ms                            | 2.3 ms                            |
| 65536 | 655.4 s                          | 2.0 ms                            | 3.3 ms                            | 4.6 ms                            |

## 49.5.6 Calculation of FIFO pointer addresses

Complete visibility of the FIFO contents is available through the FIFO registers, and valid entries can be identified through a memory-mapped pointer and counter for each FIFO. The pointer to the first-in entry in each FIFO is memory mapped. For the TX FIFO, the first-in pointer is Transmit Next Pointer (TXNXTPTR), and for the CMD FIFO, the first-in pointer is the Command Next Pointer (CMDNXTPTR). For the RX FIFO, the first-in pointer is the Pop Next Pointer (POPNXTPTR). The following figure illustrates the concept of first-in and last-in FIFO entries along with the FIFO counter. The TX FIFO is chosen for illustration, but the concepts carry over. See TX FIFO buffering mechanism, CMD FIFO buffering mechanism, and RX FIFO buffering mechanism for details on the FIFO operation.

<!-- image -->

## 49.5.6.1 Address calculation for the first-in entry and last-in entry in the TX FIFO

Use the following equation to compute the memory address of the first-in entry in the TX FIFO:

- First-in EntryAddress = TXFIFOBase+[4xTXNXTPTR]

Use the following equation to compute the memory address of the last-in entry in the TX FIFO:

- Last-in EntryAddress = TXFIFOBase+4x[TXCTR+TXNXTPTR - 1]mod[TXFIFOdepth]

Here is an explanation of the different components of these equations:

- TX FIFO base: Base address of TX FIFO

Serial Peripheral Interface (SPI)

- TXCTR: TX FIFO Counter
- TXNXTPTR: Transmit Next Pointer
- TX FIFO Depth: Transmit FIFO depth, implementation specific

## 49.5.6.2 Address calculation for the first-in entry and last-in entry in the CMD FIFO

Use the following equation to compute the memory address of the first-in entry in the CMD FIFO:

- First-in EntryAddress = CMDFIFOBase+[4xCMDNXTPTR]

Use the following equation to compute the memory address of the last-in entry in the CMD FIFO:

- Last-in EntryAddress = CMDFIFOBase+4x[CMDCTR+CMDNXTPTR - 1]mod[CMDFIFOdepth]

Here is an explanation of the different components of these equations:

- CMD FIFO Base: Base address of CMD FIFO
- CMDCTR: CMD FIFO Counter
- CMDNXTPTR: Command Next Pointer
- CMD FIFO Depth: Command FIFO depth, implementation specific

## 49.5.6.3 Address calculation for the first-in entry and last-in entry in the RX FIFO

Use the following equation to compute the memory address of the first-in entry in the RX FIFO:

- First-in EntryAddress = RXFIFOBase+[4xPOPNXTPTR]

Use the following equation to compute the memory address of the last-in entry in the RX FIFO:

- Last-in EntryAddress = RXFIFOBase+4x[RXCTR+POPNXTPTR - 1]mod[RXFIFOdepth]

Here is an explanation of the different components of these equations:

- RX FIFO Base: Base address of RX FIFO
- RXCTR: TX FIFO Counter
- POPNXTPTR: Pop Next Pointer
- RX FIFO Depth: Receive FIFO depth, implementation specific

## 49.6 SPI register descriptions

Register accesses to memory addresses that are reserved or undefined result in a transfer error. Any write access to the POPR and RXFRn also results in a transfer error.

## NOTE

While the module is in the running state, do not write to:

- CTAREn

## 49.6.1 SPI memory map

SPI\_0 base address: 401D\_4000h

SPI\_1 base address: 401D\_8000h

SPI\_2 base address: 401D\_C000h

SPI\_3 base address: 402C\_8000h

SPI\_4 base address: 402C\_C000h

SPI\_5 base address: 402D\_0000h

Serial Peripheral Interface (SPI)

Serial Peripheral Interface (SPI)

| Offset      | Register                                                                |   Width (In bits) | Access   | Reset value   |
|-------------|-------------------------------------------------------------------------|-------------------|----------|---------------|
| 0h          | Module Configuration Register (MCR)                                     |                32 | RW       | 0000_4001h    |
| 8h          | Transfer Count Register (TCR)                                           |                32 | RW       | 0000_0000h    |
| Ch - 20h    | Clock and Transfer Attributes Register (in Master mode) (CTAR0 - CTAR5) |                32 | RW       | 7800_0000h    |
| Ch          | Clock and Transfer Attributes Register (in Slave mode) (CTAR0_SLAVE)    |                32 | RW       | 7800_0000h    |
| 2Ch         | Status Register (SR)                                                    |                32 | RW       | 0201_0000h    |
| 30h         | DMA/Interrupt Request Select and Enable Register (RSER)                 |                32 | RW       | 0000_0000h    |
| 34h         | PUSH TX FIFO Register In Master Mode (PUSHR)                            |                32 | RW       | 0000_0000h    |
| 34h         | PUSH TX FIFO Register In Slave Mode (PUSHR_SLAVE)                       |                32 | RW       | 0000_0000h    |
| 38h         | POP RX FIFO Register (POPR)                                             |                32 | R        | 0000_0000h    |
| 3Ch - 4Ch   | Transmit FIFO Registers (TXFR0 - TXFR4)                                 |                32 | R        | 0000_0000h    |
| 7Ch - 8Ch   | Receive FIFO Registers (RXFR0 - RXFR4)                                  |                32 | R        | 0000_0000h    |
| 11Ch - 130h | Clock and Transfer Attributes Register Extended (CTARE0 - CTARE5)       |                32 | RW       | 0000_0001h    |
| 13Ch        | Status Register Extended (SREX)                                         |                32 | R        | 0000_0000h    |

## 49.6.2 Module Configuration Register (MCR)

## Offset

| Register   | Offset   |
|------------|----------|
| MCR        | 0h       |

## Function

This register includes fields to configure various attributes associated with module operations. The HALT and MDIS fields of this register can be changed any time, but the effect takes place only on the next frame boundary. Also, only these two fields can be changed when the module is in the Running state.

## Diagram

<!-- image -->

| Bits   | 31        | 30          | 29       | 28       | 27       | 26       | 25     | 24      | 23    | 22    | 21    | 20    | 19    | 18     | 17    | 16    |
|--------|-----------|-------------|----------|----------|----------|----------|--------|---------|-------|-------|-------|-------|-------|--------|-------|-------|
| R W    | MSTR      | CONT _SC... | DCONF    | DCONF    | FRZ      | MTFE     | PCSS E | ROOE    | PCSIS | PCSIS | PCSIS | PCSIS | PCSIS | PCSIS  | PCSIS | PCSIS |
| Reset  | 0         | 0           | 0        | 0        | 0        | 0        | 0      | 0       | 0     | 0     | 0     | 0     | 0     | 0      | 0     | 0     |
| Bits   | 15        | 14          | 13       | 12       | 11       | 10       | 9      | 8       | 7     | 6     | 5     | 4     | 3     | 2      | 1     | 0     |
| R W    | Reserv ed | MDIS        | DIS_ TXF | DIS_ RXF | 0        | 0        |        |         | 0     | 0     | 0     | 0     | XSPI  | FCPC S | PES   | HALT  |
| R W    | Reserv ed | MDIS        | DIS_ TXF | DIS_ RXF | CLR_ TXF | CLR_ RXF |        | SMPL_PT |       |       |       |       | XSPI  | FCPC S | PES   | HALT  |
| Reset  | 0         | 1           | 0        | 0        | 0        | 0        | 0      | 0       | 0     | 0     | 0     | 0     | 0     | 0      | 0     | 1     |

## Fields

| Field        | Function                                                                                                                                                                                         |
|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 MSTR      | Master/Slave Mode Select Enables either Master mode (if supported) or Slave mode (if supported) operation 0b - Enables Slave mode 1b - Enables Master mode                                       |
| 30 CONT_SCKE | Continuous SCK Enable Enables the SCK to run continuously 0b - Continuous SCK disabled 1b - Continuous SCK enabled                                                                               |
| 29-28 DCONF  | SPI Configuration Selects among the different configurations of the module 00b - SPI 01b - Reserved 10b - Reserved 11b - Reserved                                                                |
| 27 FRZ       | Freeze Enables transfers to be stopped on the next frame boundary when the chip enters the Debug mode 0b - Do not halt serial transfers in Debug mode. 1b - Halt serial transfers in Debug mode. |
| 26 MTFE      | Modified Transfer Format Enable Enables a modified transfer format to be used                                                                                                                    |

Table continues on the next page...

Serial Peripheral Interface (SPI)

## Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | If the value of this field is 1, with continuous SCK enabled (MCR[CONT_SCKE] = 1) in Master mode, write 0 to CTAR[LSBFE]for correct operations while receiving unequal length frames. If PUSHR[CONT] is also set for back-to-back frame transfer, configure the frame size of the first frame as less than or equal to the frame size of the next frame. In this scenario, you must ensure that for all received frames, the bits are read equal to their respective frame sizes and any extra bits during the POP operation are masked. NOTE 0b - Modified SPI transfer format disabled. | If the value of this field is 1, with continuous SCK enabled (MCR[CONT_SCKE] = 1) in Master mode, write 0 to CTAR[LSBFE]for correct operations while receiving unequal length frames. If PUSHR[CONT] is also set for back-to-back frame transfer, configure the frame size of the first frame as less than or equal to the frame size of the next frame. In this scenario, you must ensure that for all received frames, the bits are read equal to their respective frame sizes and any extra bits during the POP operation are masked. NOTE 0b - Modified SPI transfer format disabled. | If the value of this field is 1, with continuous SCK enabled (MCR[CONT_SCKE] = 1) in Master mode, write 0 to CTAR[LSBFE]for correct operations while receiving unequal length frames. If PUSHR[CONT] is also set for back-to-back frame transfer, configure the frame size of the first frame as less than or equal to the frame size of the next frame. In this scenario, you must ensure that for all received frames, the bits are read equal to their respective frame sizes and any extra bits during the POP operation are masked. NOTE 0b - Modified SPI transfer format disabled. |
| 25 PCSSE    | Peripheral Chip Select Strobe Enable Enables the PCS5/PCSS_b to operate as a PCS strobe output signal This field is not supported in every instance. The following table includes only supported registers. NOTE                                                                                                                                                                                                                                                                                                                                                                          | Peripheral Chip Select Strobe Enable Enables the PCS5/PCSS_b to operate as a PCS strobe output signal This field is not supported in every instance. The following table includes only supported registers. NOTE                                                                                                                                                                                                                                                                                                                                                                          | Peripheral Chip Select Strobe Enable Enables the PCS5/PCSS_b to operate as a PCS strobe output signal This field is not supported in every instance. The following table includes only supported registers. NOTE                                                                                                                                                                                                                                                                                                                                                                          |
|             | Instance                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Field supported in                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Field not supported                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|             | SPI_0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | MCR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|             | SPI_1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | MCR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|             | SPI_2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | MCR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|             | SPI_3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | MCR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|             | SPI_4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | MCR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|             | SPI_5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | MCR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|             | 0b - PCS5/PCSS_b is used as the PCS[5] signal. 1b - PCS5/PCSS_b is used as an active-low PCSS signal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | 0b - PCS5/PCSS_b is used as the PCS[5] signal. 1b - PCS5/PCSS_b is used as an active-low PCSS signal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | 0b - PCS5/PCSS_b is used as the PCS[5] signal. 1b - PCS5/PCSS_b is used as an active-low PCSS signal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 24 ROOE     | Receive FIFO Overflow Overwrite Enable In case of RX FIFO overflow, configure the module to ignore the incoming serial data or overwrite existing data. If the RX FIFO is full and new data is received, the data from the transfer, generating the overflow, is ignored or shifted to the Shift register. 0b - Incoming data is ignored. 1b - Incoming data is shifted to the Shift register.                                                                                                                                                                                            | Receive FIFO Overflow Overwrite Enable In case of RX FIFO overflow, configure the module to ignore the incoming serial data or overwrite existing data. If the RX FIFO is full and new data is received, the data from the transfer, generating the overflow, is ignored or shifted to the Shift register. 0b - Incoming data is ignored. 1b - Incoming data is shifted to the Shift register.                                                                                                                                                                                            | Receive FIFO Overflow Overwrite Enable In case of RX FIFO overflow, configure the module to ignore the incoming serial data or overwrite existing data. If the RX FIFO is full and new data is received, the data from the transfer, generating the overflow, is ignored or shifted to the Shift register. 0b - Incoming data is ignored. 1b - Incoming data is shifted to the Shift register.                                                                                                                                                                                            |
| 23-16 PCSIS | Peripheral Chip Select x Inactive State                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Peripheral Chip Select x Inactive State                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Peripheral Chip Select x Inactive State                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | Determines the inactive state of PCS x when the module is in Master mode. This field has no effect when the module is in Slave mode. The Slave Select input to the module in Slave mode is always Active Low. The effect of this field only takes place when the module is enabled. Ensure that the field is configured correctly before enabling the SPI interface. NOTE This field is not supported in every instance. The following table includes only supported registers. NOTE | Determines the inactive state of PCS x when the module is in Master mode. This field has no effect when the module is in Slave mode. The Slave Select input to the module in Slave mode is always Active Low. The effect of this field only takes place when the module is enabled. Ensure that the field is configured correctly before enabling the SPI interface. NOTE This field is not supported in every instance. The following table includes only supported registers. NOTE | Determines the inactive state of PCS x when the module is in Master mode. This field has no effect when the module is in Slave mode. The Slave Select input to the module in Slave mode is always Active Low. The effect of this field only takes place when the module is enabled. Ensure that the field is configured correctly before enabling the SPI interface. NOTE This field is not supported in every instance. The following table includes only supported registers. NOTE |
|         | Instance                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Field supported in                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Field not supported in                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|         | SPI_0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | MCR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|         | SPI_1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | MCR[20-16]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | MCR[23-21]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|         | SPI_2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | MCR[20-16]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | MCR[23-21]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|         | SPI_3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | MCR[20-16]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | MCR[23-21]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|         | SPI_4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | MCR[20-16]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | MCR[23-21]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|         | SPI_5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | MCR[20-16]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | MCR[23-21]                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|         | The descriptions of the field settings vary by module instance. NOTE                                                                                                                                                                                                                                                                                                                                                                                                                 | The descriptions of the field settings vary by module instance. NOTE                                                                                                                                                                                                                                                                                                                                                                                                                 | The descriptions of the field settings vary by module instance. NOTE                                                                                                                                                                                                                                                                                                                                                                                                                 |
|         | Instance                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Field value and description                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Field value and description                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|         | SPI_0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | 0000_0000b - The inactive state of PCSx is low. 0000_0001b - The inactive state of PCS0 is high and for rest of PCSx, it is low.                                                                                                                                                                                                                                                                                                                                                     | 0000_0000b - The inactive state of PCSx is low. 0000_0001b - The inactive state of PCS0 is high and for rest of PCSx, it is low.                                                                                                                                                                                                                                                                                                                                                     |
|         | SPI_1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | 0_0000b - The inactive state of PCSx is low. 0_0001b - The inactive state of PCS0 is high and for rest of PCSx, it is low.                                                                                                                                                                                                                                                                                                                                                           | 0_0000b - The inactive state of PCSx is low. 0_0001b - The inactive state of PCS0 is high and for rest of PCSx, it is low.                                                                                                                                                                                                                                                                                                                                                           |
|         | SPI_2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | 0_0000b - The inactive state of PCSx is low. 0_0001b - The inactive state of PCS0 is high and for rest of PCSx, it is low.                                                                                                                                                                                                                                                                                                                                                           | 0_0000b - The inactive state of PCSx is low. 0_0001b - The inactive state of PCS0 is high and for rest of PCSx, it is low.                                                                                                                                                                                                                                                                                                                                                           |
|         | SPI_3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | 0_0000b - The inactive state of PCSx is low.                                                                                                                                                                                                                                                                                                                                                                                                                                         | 0_0000b - The inactive state of PCSx is low.                                                                                                                                                                                                                                                                                                                                                                                                                                         |

Table continues on the next page...

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | Instance                                                                                                                                                                                                                                                                                                                                                                                                                                    | Field value and description                                                                                                                                                                                                                                                                                                                                                                                                                 |
|            |                                                                                                                                                                                                                                                                                                                                                                                                                                             | 0_0001b - The inactive state of PCS0 is high and for rest of PCSx, it is low.                                                                                                                                                                                                                                                                                                                                                               |
|            | SPI_4                                                                                                                                                                                                                                                                                                                                                                                                                                       | 0_0000b - The inactive state of PCSx is low. 0_0001b - The inactive state of PCS0 is high and for rest of PCSx, it is low.                                                                                                                                                                                                                                                                                                                  |
|            | SPI_5                                                                                                                                                                                                                                                                                                                                                                                                                                       | 0_0000b - The inactive state of PCSx is low. 0_0001b - The inactive state of PCS0 is high and for rest of PCSx, it is low.                                                                                                                                                                                                                                                                                                                  |
| 15 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                    | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 14 MDIS    | Module Disable Allows the clock to be stopped to the non-memory mapped logic in the module, effectively putting it in a software-controlled, power-saving state. The reset value of this field is parametrized with a default reset value of 1. When the module is used in the Slave mode, it is recommended to retain 0 as the value of this field. 0b - Enables the module clocks 1b - Allows external logic to disable the module clocks | Module Disable Allows the clock to be stopped to the non-memory mapped logic in the module, effectively putting it in a software-controlled, power-saving state. The reset value of this field is parametrized with a default reset value of 1. When the module is used in the Slave mode, it is recommended to retain 0 as the value of this field. 0b - Enables the module clocks 1b - Allows external logic to disable the module clocks |
| 13 DIS_TXF | Disable Transmit FIFO When the TX FIFO is disabled, the transmit part of the module operates as a simplified, double-buffered SPI. This field can be written to only when the value of the MDIS field is 0. 0b - TX FIFO is enabled. 1b - TX FIFO is disabled.                                                                                                                                                                              | Disable Transmit FIFO When the TX FIFO is disabled, the transmit part of the module operates as a simplified, double-buffered SPI. This field can be written to only when the value of the MDIS field is 0. 0b - TX FIFO is enabled. 1b - TX FIFO is disabled.                                                                                                                                                                              |
| 12 DIS_RXF | Disable Receive FIFO When the RX FIFO is disabled, the receive part of the module operates as a simplified double-buffered SPI. This field can only be written when the value of the MDIS field is 0. 0b - RX FIFO is enabled. 1b - RX FIFO is disabled.                                                                                                                                                                                    | Disable Receive FIFO When the RX FIFO is disabled, the receive part of the module operates as a simplified double-buffered SPI. This field can only be written when the value of the MDIS field is 0. 0b - RX FIFO is enabled. 1b - RX FIFO is disabled.                                                                                                                                                                                    |
| 11 CLR_TXF | Clear TX FIFO Flushes the TX FIFO. Writing a 1 to CLR_TXF clears the TX FIFO counter. The value of this field is always read as 0. 0b - Do not clear the TX FIFO counter.                                                                                                                                                                                                                                                                   | Clear TX FIFO Flushes the TX FIFO. Writing a 1 to CLR_TXF clears the TX FIFO counter. The value of this field is always read as 0. 0b - Do not clear the TX FIFO counter.                                                                                                                                                                                                                                                                   |

Table continues on the next page...

## Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|-------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 10 CLR_RXF  | 1b - Clear the TX FIFO counter. Clear RX FIFO Flushes the RX FIFO. Writing a 1 to this field clears the RX counter. The value of this field is always read as 0. After every RX FIFO clear operation (MCR[CLR_RXF] = 0b1), followed by an RX FIFO overflow (SR[RFOF] = 0b1) scenario, you must immediately perform a single POPfrom the RX FIFO and discard the read data. The POP and discard operations must be completed before receiving a new incoming frame. NOTE                                                                                                                                             |
| 9-8 SMPL_PT | Sample Point Controls when the module master samples SIN in the modified transfer format. This field is valid only when the value of CTAR n [CPHA] is 0. 00b - Zero protocol clock cycles between SCK edge and SIN sample 01b - One protocol clock cycle between SCK edge and SIN sample 10b - Two protocol clock cycles between SCK edge and SIN sample 11b - Reserved                                                                                                                                                                                                                                             |
| 7-4 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 3 XSPI      | Extended SPI Mode Enables the usage of Command and Transfer Attribute Register Extended (CTARE) registers. These registers allow you to send up to 32-bit SPI frames. Command cycling is also enabled, which allows you to send multiple data frames using a single command frame. When MCR[DIS_TXF] is asserted, the Extended SPI mode cannot be used to transmit SPI frames that are more than 16 bits in size. 0b - Normal SPI mode. Frame size can be up to 16 bits, and command cycling is unavailable in this mode. 1b - Extended SPI mode. Up to 32-bit SPI frames, along with command cycling, are enabled. |
| 2 FCPCS     | Fast Continuous PCS Mode Enables the masking of 'After SCK (t ASC )' and 'PCS to SCK (t CSC )' delays when operating in the Continuous PCS mode. This masking is not available if Continuous SCK mode is enabled. The individual delay masks are selected via PUSHR[MASC] and PUSHR[MCSC]. The firmware should select appropriate masks when providing continuous frames via the PUSHR. 0b - Normal or slow continuous PCS mode. Masking of delays is disabled. 1b - Fast continuous PCS mode. Delays are masked via control fields in the PUSHR.                                                                   |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                 |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1       | Parity Error Stop                                                                                                                                        |
| PES     | Controls SPI operation when a parity error is detected in a received SPI frame 0b - SPI frame transmission continues. 1b - SPI frame transmission stops. |
| 0 HALT  | Halt Starts and stops frame transfers. See Start and Stop of Module transfers for details. 0b - Starts transfers. 1b - Stops transfers.                  |

## 49.6.3 Transfer Count Register (TCR)

## Offset

| Register   | Offset   |
|------------|----------|
| TCR        | 8h       |

## Function

This register contains a counter that indicates the number of SPI transfers made. The transfer counter is intended to assist in queue management. You must not write to the TCR when the module is in the running state.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24       | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|----------|------|------|------|------|------|------|------|------|
| R      |      |      |      |      |      |      |      | SPI_TCNT |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8        | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |          |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function             |
|---------|----------------------|
| 31-16   | SPI Transfer Counter |

Table continues on the next page...

Table continued from the previous page...

| Field    | Function                                                                                                                                                                                                                                                                                                                             |
|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SPI_TCNT | This field increments every time the last bit of an SPI frame is transmitted, and a value written to this field presets the counter to that value. The field is reset to 0 at the beginning of a frame if the value of PUSHR[CTCNT] is 1. If the counter is not overwritten or cleared, it eventually overflows at value 65535 to 0. |
| 15-0 -   | Reserved                                                                                                                                                                                                                                                                                                                             |

## 49.6.4 Clock and Transfer Attributes Register (in Master mode) (CTAR0 - CTAR5)

## Offset

| Register   | Offset   |
|------------|----------|
| CTAR0      | Ch       |
| CTAR1      | 10h      |
| CTAR2      | 14h      |
| CTAR3      | 18h      |
| CTAR4      | 1Ch      |
| CTAR5      | 20h      |

## Function

This set of registers is used to define different transfer attributes. You must not write to the CTARs when the module is in the Running state, except FMSZ and LSBFE in Continuous Selection Format.

In Master mode, the CTARs define combinations of transfer attributes such as frame size, clock phase and polarity, data bit ordering, baud rate, and various delays. In Slave mode, a subset of the fields in CTAR0 is used to configure the slave transfer attributes.

When the module is configured as an SPI master, the CTAS field in the command portion of the TX FIFO entry selects which of the CTARs is used. When the module is configured as an SPI bus slave, it uses the CTAR0 register.

## Diagram

<!-- image -->

| Bits   | 31    | 30    | 29    | 28    | 27   | 26   | 25   | 24    | 23     | 22     | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|-------|-------|-------|-------|------|------|------|-------|--------|--------|------|------|------|------|------|------|
| R W    | DBR   |       |       |       |      | CPOL | CPHA | LSBFE | PCSSCK | PCSSCK | PASC | PASC | PDT  | PDT  | PBR  | PBR  |
| Reset  | 0     | 1     | 1     | 1     | 1    | 0    | 0    | 0     | 0      | 0      | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15    | 14    | 13    | 12    | 11   | 10   | 9    | 8     | 7      | 6      | 5    | 4    | 3    | 2    | 1    | 0    |
| R W    | CSSCK | CSSCK | CSSCK | CSSCK | ASC  | ASC  | ASC  | ASC   | DT     | DT     | DT   | DT   | BR   | BR   | BR   | BR   |
| Reset  | 0     | 0     | 0     | 0     | 0    | 0    | 0    | 0     | 0      | 0      | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31         | Double Baud Rate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Double Baud Rate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Double Baud Rate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Double Baud Rate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| DBR        | Doubles the effective baud rate of the Serial Communications Clock (SCK). This field is used only in Master mode. It effectively halves the baud rate division ratio, supporting faster frequencies, and odd division ratios for SCK. If the value of this field is 1, the duty cycle of the SCK depends on the value in the baud rate prescaler and the CPHA field, as listed in the following table. See the description of the VR field in this register for details on how to compute the baud rate.                                                                                                                                      | Doubles the effective baud rate of the Serial Communications Clock (SCK). This field is used only in Master mode. It effectively halves the baud rate division ratio, supporting faster frequencies, and odd division ratios for SCK. If the value of this field is 1, the duty cycle of the SCK depends on the value in the baud rate prescaler and the CPHA field, as listed in the following table. See the description of the VR field in this register for details on how to compute the baud rate.                                                                                                                                      | Doubles the effective baud rate of the Serial Communications Clock (SCK). This field is used only in Master mode. It effectively halves the baud rate division ratio, supporting faster frequencies, and odd division ratios for SCK. If the value of this field is 1, the duty cycle of the SCK depends on the value in the baud rate prescaler and the CPHA field, as listed in the following table. See the description of the VR field in this register for details on how to compute the baud rate.                                                                                                                                      | Doubles the effective baud rate of the Serial Communications Clock (SCK). This field is used only in Master mode. It effectively halves the baud rate division ratio, supporting faster frequencies, and odd division ratios for SCK. If the value of this field is 1, the duty cycle of the SCK depends on the value in the baud rate prescaler and the CPHA field, as listed in the following table. See the description of the VR field in this register for details on how to compute the baud rate.                                                                                                                                      |
|            | Table 344. SPI SCK duty cycle                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Table 344. SPI SCK duty cycle                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Table 344. SPI SCK duty cycle                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Table 344. SPI SCK duty cycle                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|            | DBR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | CPHA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | PBR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | SCK duty cycle                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|            | 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Any                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Any                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | 50/50                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|            | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 00                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | 50/50                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|            | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 01                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | 33/66                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|            | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 10                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | 40/60                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|            | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 11                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | 43/57                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|            | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 00                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | 50/50                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|            | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 01                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | 66/33                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|            | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 10                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | 60/40                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|            | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 11                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | 57/43                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|            | 0b - The baud rate is computed normally with a 50/50 duty cycle.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 0b - The baud rate is computed normally with a 50/50 duty cycle.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 0b - The baud rate is computed normally with a 50/50 duty cycle.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 0b - The baud rate is computed normally with a 50/50 duty cycle.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 30-27 FMSZ | Frame Size The number of bits transferred per frame is equal to the FMSZ value plus 1. Regardless of the transmission mode, the minimum valid frame size value is 4.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Frame Size The number of bits transferred per frame is equal to the FMSZ value plus 1. Regardless of the transmission mode, the minimum valid frame size value is 4.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Frame Size The number of bits transferred per frame is equal to the FMSZ value plus 1. Regardless of the transmission mode, the minimum valid frame size value is 4.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Frame Size The number of bits transferred per frame is equal to the FMSZ value plus 1. Regardless of the transmission mode, the minimum valid frame size value is 4.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 26         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| CPOL       | Clock Polarity Selects the inactive state of the SCK. This field is used in both Master and Slave modes. For successful communication between serial devices, the devices must have identical clock polarities. When the continuous selection format is selected, switching between clock polarities without stopping the module can cause errors in the transfer because of the peripheral device interpreting the switch of clock polarity as a valid clock edge. In case of Continuous SCKmode,whenthemodulegoesinlow-power mode(disabled), the inactive state of SCK is not guaranteed. NOTE 0b - The inactive state value of SCK is low. | Clock Polarity Selects the inactive state of the SCK. This field is used in both Master and Slave modes. For successful communication between serial devices, the devices must have identical clock polarities. When the continuous selection format is selected, switching between clock polarities without stopping the module can cause errors in the transfer because of the peripheral device interpreting the switch of clock polarity as a valid clock edge. In case of Continuous SCKmode,whenthemodulegoesinlow-power mode(disabled), the inactive state of SCK is not guaranteed. NOTE 0b - The inactive state value of SCK is low. | Clock Polarity Selects the inactive state of the SCK. This field is used in both Master and Slave modes. For successful communication between serial devices, the devices must have identical clock polarities. When the continuous selection format is selected, switching between clock polarities without stopping the module can cause errors in the transfer because of the peripheral device interpreting the switch of clock polarity as a valid clock edge. In case of Continuous SCKmode,whenthemodulegoesinlow-power mode(disabled), the inactive state of SCK is not guaranteed. NOTE 0b - The inactive state value of SCK is low. | Clock Polarity Selects the inactive state of the SCK. This field is used in both Master and Slave modes. For successful communication between serial devices, the devices must have identical clock polarities. When the continuous selection format is selected, switching between clock polarities without stopping the module can cause errors in the transfer because of the peripheral device interpreting the switch of clock polarity as a valid clock edge. In case of Continuous SCKmode,whenthemodulegoesinlow-power mode(disabled), the inactive state of SCK is not guaranteed. NOTE 0b - The inactive state value of SCK is low. |
| 25 CPHA    | Clock Phase                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Clock Phase                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Clock Phase                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Clock Phase                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |

Table continues on the next page...

Serial Peripheral Interface (SPI)

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|              | Selects which edge of SCK causes data to change and which edge causes data to be captured. This field is used in both Master and Slave modes. For successful communication between serial devices, the devices must have identical clock phase settings. In Continuous SCK mode, the field value is ignored and the transfers are done considering 1 as the value of this field. 0b - Data is captured on the leading edge of SCK and changed on the following edge. 1b - Data is changed on the leading edge of SCK and captured on the following edge.                            |
| 24 LSBFE     | LSB First Specifies whether the LSB or MSB of the frame is transferred first. 0b - Data is transferred MSB first. 1b - Data is transferred LSB first.                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 23-22 PCSSCK | PCS to SCK Delay Prescaler Selects the prescaler value for the delay between assertion of PCS and the first edge of the SCK. See the CSSCK field description for information on how to compute the PCS to SCK delay. See PCS to SCK Delay (t CSC ) for details. 00b - PCS to SCK Prescaler value is 1. 01b - PCS to SCK Prescaler value is 3. 10b - PCS to SCK Prescaler value is 5. 11b - PCS to SCK Prescaler value is 7.                                                                                                                                                         |
| 21-20 PASC   | After SCK Delay Prescaler Selects the prescaler value for the delay between the last edge of SCK and the negation of PCS. See the ASC field description for information on how to compute the "After SCK Delay". See After SCK Delay (t ASC ) for details. 00b - Delay after Transfer Prescaler value is 1. 01b - Delay after Transfer Prescaler value is 3. 10b - Delay after Transfer Prescaler value is 5. 11b - Delay after Transfer Prescaler value is 7.                                                                                                                      |
| 19-18 PDT    | Delay after Transfer Prescaler Selects the prescaler value for the delay between the negation of the PCS signal at the end of a frame and the assertion of PCS at the beginning of the next frame. This field is only used in Master mode. See the DT field description for details on how to compute the "Delay after Transfer". See Delay after Transfer (t DT ) for details. 00b - Delay after Transfer Prescaler value is 1. 01b - Delay after Transfer Prescaler value is 3. 10b - Delay after Transfer Prescaler value is 5. 11b - Delay after Transfer Prescaler value is 7. |
| 17-16 PBR    | Baud Rate Prescaler                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

Table continues on the next page...

Serial Peripheral Interface (SPI)

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | Selects the prescaler value for the baud rate. This field is used only in Master mode. The baud rate is the frequency of the SCK. The protocol clock is divided by the prescaler value before the baud rate selection takes place. See the BR field description for details on how to compute the baud rate. 00b - Baud Rate Prescaler value is 2. 01b - Baud Rate Prescaler value is 3. 10b - Baud Rate Prescaler value is 5. 11b - Baud Rate Prescaler value is 7. | Selects the prescaler value for the baud rate. This field is used only in Master mode. The baud rate is the frequency of the SCK. The protocol clock is divided by the prescaler value before the baud rate selection takes place. See the BR field description for details on how to compute the baud rate. 00b - Baud Rate Prescaler value is 2. 01b - Baud Rate Prescaler value is 3. 10b - Baud Rate Prescaler value is 5. 11b - Baud Rate Prescaler value is 7. |
| 15-12 CSSCK | PCS to SCK Delay Scaler Selects the scaler value for the PCS to SCK delay. This field is used only in master mode. The PCS to SCK Delay is the delay between the assertion of PCS and the first edge of the SCK. The delay is a multiple of the protocol clock period, and it is computed according to the following equation: t CSC = (1/f P ) x PCSSCK x CSSCK. The following table lists the delay scaler values.                                                 | PCS to SCK Delay Scaler Selects the scaler value for the PCS to SCK delay. This field is used only in master mode. The PCS to SCK Delay is the delay between the assertion of PCS and the first edge of the SCK. The delay is a multiple of the protocol clock period, and it is computed according to the following equation: t CSC = (1/f P ) x PCSSCK x CSSCK. The following table lists the delay scaler values.                                                 |
|             | Field value                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Delay scaler value                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|             | 0000                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|             | 0001                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 4                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|             | 0010                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 8                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|             | 0011                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 16                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|             | 0100                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 32                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|             | 0101                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 64                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|             | 0110                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 128                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|             | 0111                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 256                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|             | 1000                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 512                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|             | 1001                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 1024                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|             | 1010                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 2048                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|             | 1011                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 4096                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|             | 1100                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 8192                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|             | 1101                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 16384                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|             | 1110                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 32768                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|             | 1111                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 65536                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|             | See PCS to SCK Delay (t CSC ) for details.                                                                                                                                                                                                                                                                                                                                                                                                                           | See PCS to SCK Delay (t CSC ) for details.                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 11-8 ASC    | After SCK Delay Scaler                                                                                                                                                                                                                                                                                                                                                                                                                                               | After SCK Delay Scaler                                                                                                                                                                                                                                                                                                                                                                                                                                               |

Table continues on the next page...

Serial Peripheral Interface (SPI)

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|---------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | Selects the scaler value for the "After SCK Delay". This field is used only in master mode. The "After SCK Delay" is the delay between the last edge of SCK and the negation of PCS. The delay is a multiple of the protocol clock period, and it is computed according to the following equation: t ASC = (1/f P ) x PASC x ASC See Delay Scaler Encoding table in CTARn[CSSCK] bit field description for scaler values. See After SCK Delay (t ASC ) for details.                                                                               | Selects the scaler value for the "After SCK Delay". This field is used only in master mode. The "After SCK Delay" is the delay between the last edge of SCK and the negation of PCS. The delay is a multiple of the protocol clock period, and it is computed according to the following equation: t ASC = (1/f P ) x PASC x ASC See Delay Scaler Encoding table in CTARn[CSSCK] bit field description for scaler values. See After SCK Delay (t ASC ) for details.                                                                               |
| 7-4 DT  | Delay After Transfer Scaler Selects the "Delay after Transfer" scaler. This field is used only in Master mode. The "Delay after Transfer" is the time between the negation of the PCS signal at the end of a frame and the assertion of PCS at the beginning of the next frame. In the continuous serial communications clock operation, the DT value is fixed to one SCK clock period. The "Delay after Transfer" is a multiple of the protocol clock period, and it is computed according to the following equation: t DT = (1/f P ) x PDT x DT | Delay After Transfer Scaler Selects the "Delay after Transfer" scaler. This field is used only in Master mode. The "Delay after Transfer" is the time between the negation of the PCS signal at the end of a frame and the assertion of PCS at the beginning of the next frame. In the continuous serial communications clock operation, the DT value is fixed to one SCK clock period. The "Delay after Transfer" is a multiple of the protocol clock period, and it is computed according to the following equation: t DT = (1/f P ) x PDT x DT |
| 3-0 BR  | Baud Rate Scaler Selects the scaler value for the baud rate. This field is used only in master mode. The prescaled protocol clock is divided by the baud rate scaler to generate the frequency of the SCK. The baud rate is computed according to the following equation: SCK baud rate = (f P /PBR) x [(1+DBR)/BR] The following table lists the baud rate scaler values.                                                                                                                                                                        | Baud Rate Scaler Selects the scaler value for the baud rate. This field is used only in master mode. The prescaled protocol clock is divided by the baud rate scaler to generate the frequency of the SCK. The baud rate is computed according to the following equation: SCK baud rate = (f P /PBR) x [(1+DBR)/BR] The following table lists the baud rate scaler values.                                                                                                                                                                        |
|         | Baud rate scaler CTARn[BR] 0000 0001 0010 0011 0100 0101 0110                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Baud rate scaler value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 16                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 32                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 64                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|         | 0111                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 128                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|         | 1000                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 256                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|         | 1001                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 512                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|         | 1010                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 1024                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|         | 1011                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 2048                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|         | 1100                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 4096                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

Table continues on the next page...

| Field   | Function                                | Function                                |
|---------|-----------------------------------------|-----------------------------------------|
|         | Table 346. Baud rate scaler (continued) | Table 346. Baud rate scaler (continued) |
|         | CTARn[BR]                               | Baud rate scaler value                  |
|         | 1101                                    | 8192                                    |
|         | 1110                                    | 16384                                   |
|         | 1111                                    | 32768                                   |

## 49.6.5 Clock and Transfer Attributes Register (in Slave mode) (CTAR0\_SLAVE)

## Offset

| Register    | Offset   |
|-------------|----------|
| CTAR0_SLAVE | Ch       |

## Function

When the module is configured as an SPI bus slave, the CTAR0 register is used.

## Diagram

<!-- image -->

| Bits    | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24       | 23   | 22        | 21   | 20       | 19       | 18       | 17       | 16   |
|---------|------|------|------|------|------|------|------|----------|------|-----------|------|----------|----------|----------|----------|------|
| R W     |      |      | FMSZ |      |      | CPOL | CPHA | PE       | PP   | Reserv ed |      | Reserved | Reserved | Reserved | Reserved |      |
| Reset   | 0    | 1    | 1 1  | 1    |      | 0    | 0    | 0        | 0    | 0         | 0    | 0        | 0        | 0        | 0        | 0    |
| Bits    | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8        | 7    | 6         | 5    | 4        | 3        | 2        | 1        | 0    |
| R       |      |      |      |      |      |      |      | Reserved |      |           |      |          |          |          |          |      |
| W Reset | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0        | 0    | 0         | 0    | 0        | 0        | 0        | 0        | 0    |

## Fields

| Field   | Function                                                                                                                                   |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------|
| 31-27   | Frame Size                                                                                                                                 |
| FMSZ    | The number of bits transferred per frame is equal to the value of this field plus 1. Note that the minimum valid value of frame size is 4. |
| 26      | Clock Polarity                                                                                                                             |
| CPOL    | Selects the inactive state of the SCK.                                                                                                     |

Table continues on the next page...

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | In case of Continuous SCKmode,whenthemodulegoesinlow-power mode(disabled), the inactive state of SCK is not guaranteed. NOTE 0b - The inactive state value of SCK is low. 1b - The inactive state value of SCK is high.                                                                                                                                                                                                                                                                                                                                               |
| 25 CPHA | Clock Phase Selects which edge of SCK causes data to change and which edge causes data to be captured. This field is used in both Master and Slave modes. For successful communication between serial devices, the devices must have identical clock phase settings. In Continuous SCK mode, the field value is ignored and the transfers are done considering 1 as the value for this field. 0b - Data is captured on the leading edge of SCK and changed on the following edge. 1b - Data is changed on the leading edge of SCK and captured on the following edge. |
| 24 PE   | Parity Enable Enables parity bit transmission and reception for the frame 0b - No parity bit included/checked. 1b - Parity bit is transmitted instead of last data bit in frame, parity checked for received frame.                                                                                                                                                                                                                                                                                                                                                   |
| 23 PP   | Parity Polarity Controls polarity of the parity bit transmitted and checked 0b - Even Parity: the number of 1 bits in the transmitted frame is even. SR[SPEF] = 1 if the number of 1 bits is odd in the received frame. 1b - Odd Parity: the number of 1 bits in the transmitted frame is odd. SR[SPEF] = 1 if the number of 1 bits is even in the received frame.                                                                                                                                                                                                    |
| 22 -    | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 21-0 -  | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

## 49.6.6 Status Register (SR)

## Offset

| Register   | Offset   |
|------------|----------|
| SR         | 2Ch      |

## Function

This register includes status and flag fields, which reflect the status of the module and indicate the occurrence of events that can generate interrupts or DMA requests. The software can clear the fields of this register by writing a 1, and writing a 0 does not effect the fields. The register may not be writeable in the Module Disable mode because of the use of power-saving mechanisms.

## Diagram

| Bits   | 31    | 30     | 29    | 28    | 27       | 26       | 25       | 24       | 23      | 22        | 21    | 20    | 19        | 18        | 17        | 16        |
|--------|-------|--------|-------|-------|----------|----------|----------|----------|---------|-----------|-------|-------|-----------|-----------|-----------|-----------|
| R      | TCF   | TXRX S | 0     | EOQF  | TFUF     | 0        | TFFF     | BSYF     | CMDT CF | Reserv ed | SPEF  | 0     | RFOF      | TFIWF     | RFDF      | CMDF FF   |
| W      | W1C   |        |       | W1C   | W1C      |          | W1C      |          | W1C     | W1C       | W1C   |       | W1C       | W1C       | W1C       | W1C       |
| Reset  | 0     | 0      | 0     | 0     | 0        | 0        | 1        | 0        | 0       | 0         | 0     | 0     | 0         | 0         | 0         | 1         |
| Bits   | 15    | 14     | 13    | 12    | 11       | 10       | 9        | 8        | 7       | 6         | 5     | 4     | 3         | 2         | 1         | 0         |
| R      | TXCTR | TXCTR  | TXCTR | TXCTR | TXNXTPTR | TXNXTPTR | TXNXTPTR | TXNXTPTR | RXCTR   | RXCTR     | RXCTR | RXCTR | POPNXTPTR | POPNXTPTR | POPNXTPTR | POPNXTPTR |
| W      |       |        |       |       |          |          |          |          |         |           |       |       |           |           |           |           |
| Reset  | 0     | 0      | 0     | 0     | 0        | 0        | 0        | 0        | 0       | 0         | 0     | 0     | 0         | 0         | 0         | 0         |

## Fields

| Field    | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 TCF   | Transfer Complete Flag Indicates that all bits in a frame are shifted out. This field remains set until it is cleared by writing a 1 to it. 0b - Transfer is incomplete. 1b - Transfer is complete.                                                                                                                                                                                                                                                                        |
| 30 TXRXS | TX and RX Status Reflects the run status of the module 0b - Transmit and receive operations are disabled when the module is in the Stopped state. 1b - Transmit and receive operations are enabled when the module is in the Running state.                                                                                                                                                                                                                                |
| 29 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 28 EOQF  | End of Queue Flag Indicates that the last entry in a queue had been transmitted when the module was in Master mode. This field is set when the TX FIFO entry has the EOQ field set in the command halfword and the end of the transfer is reached. The field remains set until cleared by writing a 1 to it. When this field is set, the TXRXS field is automatically cleared. 0b - EOQ is not set in the executing command. 1b - EOQ is set in the executing SPI command. |
| 27       | Transmit FIFO Underflow Flag                                                                                                                                                                                                                                                                                                                                                                                                                                               |

Table continues on the next page...

Serial Peripheral Interface (SPI)

## Table continued from the previous page...

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| TFUF      | Indicates an underflow condition in the TX FIFO. The transmit underflow condition is detected only for SPI blocks operating in Slave mode and SPI configuration. This field is set when the TX FIFO of the module operating in SPI Slave mode is empty and an external SPI master initiates a transfer. The field remains set until cleared by writing a 1 to it. 0b - No TX FIFO underflow occurred. 1b - TX FIFO underflow occurred.                                                                                                                                                                                                |
| 26 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 25 TFFF   | Transmit FIFO Fill Flag Indicates whether there is an available location to be filled in the FIFO. Either DMA or an interrupt can be used to add another entry to the FIFO. Note that this field is set if at least one location is free in the FIFO. The field can be cleared by writing a 1 to it or by acknowledgement from the DMAcontroller to the TX FIFO full request, when the TX FIFO is full. If FIFO is filled manually, and not by DMA, see Transmit FIFO fill interrupt or DMA request The reset value of this field is 0 when the module is disabled(MCR[MDIS]=1). NOTE 0b - TX FIFO is full. 1b - TX FIFO is not full. |
| 24 BSYF   | Busy Flag Indicates that the current command frame is being used for transmitting multiple data frames. This field is valid only when the value of MCR[XSPI] is 1, and is not set for the last data frame of a cyclic command transfer or when the value of CTARE[DTCP] is 1. See CMD FIFO buffering mechanism for details. 0b - No cyclic command transfer is in progress. 1b - Cyclic command transfer is in progress. Current data frame is not the last data frame for on-going cyclic command transfer.                                                                                                                          |
| 23 CMDTCF | Command Transfer Complete Flag Indicates that the last data frame for the current cyclic command has been transmitted. Therefore, this field is set only for the last data frame of a cyclic command transfer or when the value of CTARE[DTCP] is 1. The field remains set until it is cleared by writing a 1 to it. 0b - Data transfer by current command is incomplete. 1b - Data transfer by current command is complete.                                                                                                                                                                                                          |
| 22 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 21 SPEF   | SPI Parity Error Flag                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

Table continues on the next page...

## Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|-------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | Indicates that SPI frame with parity error had been received. The field remains set until it is cleared by writing a 1 to it. 0b - No parity error. 1b - Parity error has occurred.                                                                                                                                                                                                                                                                                                                                                     |
| 20 -        | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 19 RFOF     | Receive FIFO Overflow Flag Indicates an overflow condition in the RX FIFO. The field is set when the RX FIFO and Shift register are full and a transfer is initiated. The field remains set until it is cleared by writing a 1 to it. 0b - No RX FIFO overflow occurred. 1b - RX FIFO overflow has occurred.                                                                                                                                                                                                                            |
| 18 TFIWF    | Transmit FIFO Invalid Write Flag Indicates data write on TX FIFO when CMD FIFO is empty. Without a command, the data entries present in TX FIFO are invalid. This field remains set until it is cleared by writing a 1 to it. 0b - No invalid data is present in TX FIFO. 1b - Invalid data is present in TX FIFO because CMD FIFO is empty.                                                                                                                                                                                            |
| 17 RFDF     | Receive FIFO Drain Flag Indicates whether there is an available location to be drained from the FIFO. Either DMA or an interrupt can be used to read from the FIFO. Note that this field is set if at least one location can be read from the FIFO. The field can be cleared by writing a 1 to it or by acknowledgement from the DMA controller when the RX FIFO is empty. 0b - RX FIFO is empty. 1b - RX FIFO is not empty.                                                                                                            |
| 16 CMDFFF   | Command FIFO Fill Flag Indicates whether there is an available location to be filled in the FIFO. Either a DMA request or an interrupt indication can be used to add another entry to the FIFO. Note that this field is set if at least one location is free in the FIFO. The CMDFFF is cleared by writing a 1 to it or by acknowledgement from the DMA controller to the CMD FIFO full request. The reset value of this field is 0 when the module is disabled (MCR[MDIS] = 1). NOTE 0b - CMD FIFO is full. 1b - CMD FIFO is not full. |
| 15-12 TXCTR | TX FIFO Counter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |

Table continues on the next page...

Table continued from the previous page...

| Field         | Function                                                                                                                                                                                                                                                                                                                                                                                                  |
|---------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|               | Indicates the number of valid entries in the TX FIFO. This field increments every time the PUSHR is written and decrements every time SPI command is executed and the SPI data is transferred to the Shift register.                                                                                                                                                                                      |
| 11-8 TXNXTPTR | Transmit Next Pointer Indicates which TX FIFO entry is transmitted during the next transfer. This field updates every time SPI data is transferred from the TX FIFO to the Shift register. If TXFIFOis cleared by writing 1 to MCR[CLR_TXF], the value of the TXNXTPTRfield does not change immediately to 0. Only when the next transfer starts, the field reflects the latest value, TXNXTPTR = 1. NOTE |
| 7-4 RXCTR     | RX FIFO Counter Indicates the number of entries in the RX FIFO. This field decrements every time the POPR is read and increments every time data is transferred from the Shift register to the RX FIFO.                                                                                                                                                                                                   |
| 3-0 POPNXTPTR | Pop Next Pointer Contains a pointer to the RX FIFO entry to be returned when the POPR is read. This field is updated when the POPR is read.                                                                                                                                                                                                                                                               |

## 49.6.7 DMA/Interrupt Request Select and Enable Register (RSER)

## Offset

| Register   | Offset   |
|------------|----------|
| RSER       | 30h      |

## Function

This register controls DMA and interrupt requests. You must not write to the register when the module is in the Running state.

## Diagram

<!-- image -->

| Bits   | 31      | 30          | 29        | 28       | 27       | 26        | 25       | 24          | 23          | 22        | 21       | 20        | 19       | 18        | 17       | 16          |
|--------|---------|-------------|-----------|----------|----------|-----------|----------|-------------|-------------|-----------|----------|-----------|----------|-----------|----------|-------------|
| R W    | TCF_ RE | CMDF FF_... | Reserv ed | EOQF _RE | TFUF_ RE | Reserv ed | TFFF_ RE | TFFF_ DI... | CMDT CF_... | Reserv ed | SPEF_ RE | Reserv ed | RFOF _RE | TFIWF _RE | RFDF_ RE | RFDF_ DI... |
| Reset  | 0       | 0           | 0         | 0        | 0        | 0         | 0        | 0           | 0           | 0         | 0        | 0         | 0        | 0         | 0        | 0           |
| Bits   | 15      | 14          | 13        | 12       | 11       | 10        | 9        | 8           | 7           | 6         | 5        | 4         | 3        | 2         | 1        | 0           |
| R      | CMDF    | Reserv      | 0         | 0        | 0        | 0         | 0        | 0           | 0           | 0         | 0        | 0         | 0        | 0         | 0        | 0           |
| W      | FF_...  | ed          |           |          |          |           |          |             |             |           |          |           |          |           |          |             |
| Reset  | 0       | 0           | 0         | 0        | 0        | 0         | 0        | 0           | 0           | 0         | 0        | 0         | 0        | 0         | 0        | 0           |

## Fields

| Field        | Function                                                                                                                                                                                                                                                                                                                       |
|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 TCF_RE    | Transmission Complete Request Enable Enables SR[TCF] to generate an interrupt request. 0b - TCF interrupt requests are disabled. 1b - TCF interrupt requests are enabled.                                                                                                                                                      |
| 30 CMDFFF_RE | Command FIFO Fill Flag Request Enable Enables SR[CMDFFF] to generate a request. The CMDFFF_DIRS field of this register selects between generating an interrupt request or a DMA request. 0b - CMDFFF interrupts or DMA requests are disabled. 1b - CMDFFF interrupts or DMA requests are enabled.                              |
| 29 -         | Always write the reset value to this field.                                                                                                                                                                                                                                                                                    |
| 28 EOQF_RE   | Finished Request Enable Enables SR[EOQF] to generate an interrupt request 0b - EOQF interrupt requests are disabled. 1b - EOQF interrupt requests are enabled.                                                                                                                                                                 |
| 27 TFUF_RE   | Transmit FIFO Underflow Request Enable Enables SR[TFUF] to generate an interrupt request. 0b - TFUF interrupt requests are disabled. 1b - TFUF interrupt requests are enabled.                                                                                                                                                 |
| 26 -         | Always write the reset value to this field.                                                                                                                                                                                                                                                                                    |
| 25 TFFF_RE   | Transmit FIFO Fill Request Enable Enables SR[TFFF] to generate a request. The TFFF_DIRS field of this register selects between generating an interrupt request or a DMA request. 0b - TFFF interrupts or DMA requests are disabled. 1b - TFFF interrupts or DMA requests are enabled.                                          |
| 24 TFFF_DIRS | Transmit FIFO Fill DMA or Interrupt Request Select Selects between generating a DMA request or an interrupt request. When SR[TFFF] and RSER[TFFF_RE] are set, this field selects between generating an interrupt request or a DMA request. 0b - TFFF flag generates interrupt requests. 1b - TFFF flag generates DMA requests. |
| 23           | Command Transmission Complete Request Enable                                                                                                                                                                                                                                                                                   |

Table continues on the next page...

## Table continued from the previous page...

| Field          | Function                                                                                                                                                                                                                                                                                                                         |
|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| CMDTCF_RE      | Enables SR[CMDTCF] to generate an interrupt request 0b - CMDTCF interrupt requests are disabled. 1b - CMDTCF interrupt requests are enabled.                                                                                                                                                                                     |
| 22 -           | Always write the reset value to this field.                                                                                                                                                                                                                                                                                      |
| 21 SPEF_RE     | SPI Parity Error Request Enable Enables SR[SPEF] to generate an interrupt request 0b - SPEF interrupt requests are disabled. 1b - SPEF interrupt requests are enabled.                                                                                                                                                           |
| 20 -           | Always write the reset value to this field.                                                                                                                                                                                                                                                                                      |
| 19 RFOF_RE     | Receive FIFO Overflow Request Enable Enables SR[RFOF] to generate an interrupt request 0b - RFOF interrupt requests are disabled. 1b - RFOF interrupt requests are enabled.                                                                                                                                                      |
| 18 TFIWF_RE    | Transmit FIFO Invalid Write Request Enable Enables SR[TFIWF] to generate an interrupt request 0b - TFIWF interrupt requests are disabled. 1b - TFIWF interrupt requests are enabled.                                                                                                                                             |
| 17 RFDF_RE     | Receive FIFO Drain Request Enable Enables SR[RFDF] to generate a request. The RFDF_DIRS field of this register selects between generating an interrupt request or a DMA request. 0b - RFDF interrupt or DMA requests are disabled. 1b - RFDF interrupt or DMA requests are enabled.                                              |
| 16 RFDF_DIRS   | Receive FIFO Drain DMA or Interrupt Request Select Selects between generating a DMA request or an interrupt request. If SR[RFDF] is set, and the value of the RFDF_RE field in this register is 1, the RFDF_DIRS field selects between generating an interrupt request or a DMA request. 0b - Interrupt request 1b - DMA request |
| 15 CMDFFF_DIRS | Command FIFO Fill DMA or Interrupt Request Select                                                                                                                                                                                                                                                                                |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                            |
|---------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|         | Selects between generating a DMA request or an interrupt request. If SR[CMDFFF] is set, and the value of the CMDFFF_RE field in this register is 1, the CMDFFF_DIRS field selects between generating an interrupt request or a DMA request. 0b - CMDFFF flag generates interrupt requests. 1b - CMDFFF flag generates DMA requests. |
| 14 -    | Always write the reset value to this field.                                                                                                                                                                                                                                                                                         |
| 13-0 -  | Reserved                                                                                                                                                                                                                                                                                                                            |

## 49.6.8 PUSH TX FIFO Register In Master Mode (PUSHR)

## Offset

| Register   | Offset   |
|------------|----------|
| PUSHR      | 34h      |

## Function

Specifies data to be transferred to the TX FIFO and CMD FIFO. You must write 16 bits of data into the TXDATA field. An 8- or 16-bit write access to the TXDATA field transfers 16 bits of data bus to the TX FIFO. A write access to the command fields transfers the 16 bits of command information to the CMD FIFO. In Master mode, the register transfers 16 bits of data to the TX FIFO and 16 bits of command information to the CMD FIFO.

If Extended SPI Mode is disabled (MCR[XSPI]), the TX FIFO and CMD FIFO must be filled simultaneously. In other words, you must perform write accesses to both the data and command fields for every PUSHR operation. With Extended SPI Mode disabled and both the TX FIFO and CMD FIFO written to and read from simultaneously, they behave as a single 32-bit FIFO. When Extended SPI mode is enabled (MCR[XSPI]), the TX FIFO and CMD FIFO can be written to independently.

A read access of PUSHR returns the top-most TX FIFO and CMD FIFO entries concatenated.

When the module is disabled, writing to this register does not update the FIFO. Therefore, any reads performed while the module is disabled return the last PUSHR write performed while the module was still enabled.

## Diagram

<!-- image -->

| Bits    | 31   | 30   | 29   | 28   | 27   | 26     | 25       | 24       | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|---------|------|------|------|------|------|--------|----------|----------|------|------|------|------|------|------|------|------|
| R W     | CONT |      | CTAS |      | EOQ  | CTCN T | PE_ MASC | PP_ MCSC |      |      |      | PCS  |      |      |      |      |
| Reset   | 0    | 0    | 0    | 0    | 0    | 0      | 0        | 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits    | 15   | 14   | 13   | 12   | 11   | 10     | 9        | 8        | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R       |      |      |      |      |      |        |          | TXDATA   |      |      |      |      |      |      |      |      |
| W Reset | 0    | 0    | 0    | 0    | 0    | 0      | 0        | 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 CONT    | Continuous Peripheral Chip Select Enable Selects a continuous selection format. This field is used in SPI Master mode. The field enables the selected PCS signals to remain asserted between transfers. 0b - Return PCSn signals to their inactive state between transfers. 1b - Keep PCSn signals asserted between transfers.                                                                                                                   |
| 30-28 CTAS | Clock and Transfer Attributes Select Selects which CTAR to use in Master mode to specify the transfer attributes for the associated SPI frame. In SPI Slave mode, CTAR0is used. See the chip-specific section for details to determinehowmanyCTARs this chip has. You should not program a value in this field for a register that is not present. 000b - CTAR0 001b - CTAR1 010b - CTAR2 011b - CTAR3 100b - CTAR4 101b - CTAR5 110b - Reserved |
| 27 EOQ     | End of Queue The host software uses this field to signal to the module that the current SPI transfer is the last in a queue. At the end of the transfer, SR[EOQF] is set. 0b - SPI data is not the last data to transfer. 1b - SPI data is the last data to transfer.                                                                                                                                                                            |
| 26 CTCNT   | Clear Transfer Counter                                                                                                                                                                                                                                                                                                                                                                                                                           |

Table continues on the next page...

Serial Peripheral Interface (SPI)

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | Writes a 0 to TCR[TCNT], and the TCNT field is cleared before the module starts transmitting the current SPI frame. 0b - Do not clear the TCR[TCNT] field. 1b - Clear the TCR[TCNT] field.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Writes a 0 to TCR[TCNT], and the TCNT field is cleared before the module starts transmitting the current SPI frame. 0b - Do not clear the TCR[TCNT] field. 1b - Clear the TCR[TCNT] field.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Writes a 0 to TCR[TCNT], and the TCNT field is cleared before the module starts transmitting the current SPI frame. 0b - Do not clear the TCR[TCNT] field. 1b - Clear the TCR[TCNT] field.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 25 PE_MASC | Parity Enable or Mask TASC Delay in Current Frame PE - This bit enables parity bit transmission and parity reception check for the SPI frame. MASC - The current frame has the 'after SCK' delay masked if this bit is asserted. See Fast Continuous Selection Format for more details. This field is used as Mask T ASC in the Fast Continuous PCS mode when MCR[FCPCS] is set. NOTE 0b - PE - No parity bit is included/checked. MASC - T ASC delay is not masked and the current frame has the "After SCK delay". 1b - PE - Parity bit is transmitted instead of the last data bit in the frame; parity is checked for the received frame. MASC - T delay is masked in the current frame.                                                                                                  | Parity Enable or Mask TASC Delay in Current Frame PE - This bit enables parity bit transmission and parity reception check for the SPI frame. MASC - The current frame has the 'after SCK' delay masked if this bit is asserted. See Fast Continuous Selection Format for more details. This field is used as Mask T ASC in the Fast Continuous PCS mode when MCR[FCPCS] is set. NOTE 0b - PE - No parity bit is included/checked. MASC - T ASC delay is not masked and the current frame has the "After SCK delay". 1b - PE - Parity bit is transmitted instead of the last data bit in the frame; parity is checked for the received frame. MASC - T delay is masked in the current frame.                                                                                                  | Parity Enable or Mask TASC Delay in Current Frame PE - This bit enables parity bit transmission and parity reception check for the SPI frame. MASC - The current frame has the 'after SCK' delay masked if this bit is asserted. See Fast Continuous Selection Format for more details. This field is used as Mask T ASC in the Fast Continuous PCS mode when MCR[FCPCS] is set. NOTE 0b - PE - No parity bit is included/checked. MASC - T ASC delay is not masked and the current frame has the "After SCK delay". 1b - PE - Parity bit is transmitted instead of the last data bit in the frame; parity is checked for the received frame. MASC - T delay is masked in the current frame.                                                                                                  |
| 24 PP_MCSC | Parity Polarity or Mask TCSC Delay in Next Frame PP: It controls the polarity of the parity bit transmitted and checked. MCSC: The next frame has the 'PCS to SCK' delay masked if this bit is asserted. See Fast Continuous Selection Format for details. This field is used as Mask T CSC in the Fast Continuous PCS mode when MCR[FCPCS] is set. NOTE 0b - PP - Even Parity: the number of 1 bits in the transmitted frame is even. SR[SPEF] is set if the number of 1 bits is odd in the received frame. MCSC - T CSC delay is not masked and the next frame has the PCS to SCK delay. 1b - PP - Odd Parity: the number of 1 bits in the transmitted frame is odd. SR[SPEF] is set if the number of 1 bits is even in the received frame. MCSC - T ASC delay is masked in the next frame. | Parity Polarity or Mask TCSC Delay in Next Frame PP: It controls the polarity of the parity bit transmitted and checked. MCSC: The next frame has the 'PCS to SCK' delay masked if this bit is asserted. See Fast Continuous Selection Format for details. This field is used as Mask T CSC in the Fast Continuous PCS mode when MCR[FCPCS] is set. NOTE 0b - PP - Even Parity: the number of 1 bits in the transmitted frame is even. SR[SPEF] is set if the number of 1 bits is odd in the received frame. MCSC - T CSC delay is not masked and the next frame has the PCS to SCK delay. 1b - PP - Odd Parity: the number of 1 bits in the transmitted frame is odd. SR[SPEF] is set if the number of 1 bits is even in the received frame. MCSC - T ASC delay is masked in the next frame. | Parity Polarity or Mask TCSC Delay in Next Frame PP: It controls the polarity of the parity bit transmitted and checked. MCSC: The next frame has the 'PCS to SCK' delay masked if this bit is asserted. See Fast Continuous Selection Format for details. This field is used as Mask T CSC in the Fast Continuous PCS mode when MCR[FCPCS] is set. NOTE 0b - PP - Even Parity: the number of 1 bits in the transmitted frame is even. SR[SPEF] is set if the number of 1 bits is odd in the received frame. MCSC - T CSC delay is not masked and the next frame has the PCS to SCK delay. 1b - PP - Odd Parity: the number of 1 bits in the transmitted frame is odd. SR[SPEF] is set if the number of 1 bits is even in the received frame. MCSC - T ASC delay is masked in the next frame. |
| 23-16 PCS  | PCS Selects which PCS signals are to be asserted for the transfer. This field is not supported in every instance. The following table includes only supported registers. NOTE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | PCS Selects which PCS signals are to be asserted for the transfer. This field is not supported in every instance. The following table includes only supported registers. NOTE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | PCS Selects which PCS signals are to be asserted for the transfer. This field is not supported in every instance. The following table includes only supported registers. NOTE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|            | Instance                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Field supported in                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Field not supported in                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|            | SPI_0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | PUSHR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |

Table continued from the previous page...

| Field       | Function                                                                               | Function                                                                               | Function                                                                               |
|-------------|----------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|
|             | Instance                                                                               | Field supported in                                                                     | Field not supported in                                                                 |
|             | SPI_1                                                                                  | PUSHR[20-16]                                                                           | PUSHR[23-21]                                                                           |
|             | SPI_2                                                                                  | PUSHR[20-16]                                                                           | PUSHR[23-21]                                                                           |
|             | SPI_3                                                                                  | PUSHR[20-16]                                                                           | PUSHR[23-21]                                                                           |
|             | SPI_4                                                                                  | PUSHR[20-16]                                                                           | PUSHR[23-21]                                                                           |
|             | SPI_5                                                                                  | PUSHR[20-16]                                                                           | PUSHR[23-21]                                                                           |
|             | The descriptions of the field settings vary by module instance. NOTE                   | The descriptions of the field settings vary by module instance. NOTE                   | The descriptions of the field settings vary by module instance. NOTE                   |
|             | Instance                                                                               | Field value and description                                                            | Field value and description                                                            |
|             | SPI_0                                                                                  | 0000_0000b - Negate the PCS[x] signal. 0000_0001b - Assert the PCS[x] signal.          | 0000_0000b - Negate the PCS[x] signal. 0000_0001b - Assert the PCS[x] signal.          |
|             | SPI_1                                                                                  | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                |
|             | SPI_2                                                                                  | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                |
|             | SPI_3                                                                                  | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                |
|             | SPI_4                                                                                  | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                |
|             | SPI_5                                                                                  | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                | 0_0000b - Negate the PCS[x] signal. 0_0001b - Assert the PCS[x] signal.                |
| 15-0 TXDATA | Transmit Data Holds SPI data to be transferred according to the associated SPI command | Transmit Data Holds SPI data to be transferred according to the associated SPI command | Transmit Data Holds SPI data to be transferred according to the associated SPI command |

## 49.6.9 PUSH TX FIFO Register In Slave Mode (PUSHR\_SLAVE)

## Offset

| Register    | Offset   |
|-------------|----------|
| PUSHR_SLAVE | 34h      |

## Function

Specifies the data to be transferred to the TX FIFO in Slave mode. An 8- or 16-bit write access to PUSHR transfers the 16-bit TXDATA field to the TX FIFO.

If the value of MCR[XSPI] is 1, up to 32-bit DSPI frames may be queued for transmission or reception.

## Diagram

<!-- image -->

## Fields

| Field   | Function                                                                 |
|---------|--------------------------------------------------------------------------|
| 31-16   | Reserved                                                                 |
| -       |                                                                          |
| 15-0    | Transmit Data                                                            |
| TXDATA  | Holds SPI data to be transferred according to the associated SPI command |

## 49.6.10 POP RX FIFO Register (POPR)

## Offset

| Register   | Offset   |
|------------|----------|
| POPR       | 38h      |

## Function

This register is used to read the RX FIFO. An 8- or 16-bit access to the register has the same effect on the RX FIFO as 32-bit read accesses. A write to this register generates a transfer error.

## Diagram

Serial Peripheral Interface (SPI)

<!-- image -->

| Bits   | 31     | 30     | 29     | 28     | 27     | 26     | 25     | 24     | 23     | 22     | 21     | 20     | 19     | 18     | 17     | 16     |
|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
| R      | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA |
| W      |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |
| Reset  | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      |
| Bits   | 15     | 14     | 13     | 12     | 11     | 10     | 9      | 8      | 7      | 6      | 5      | 4      | 3      | 2      | 1      | 0      |
| R      | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA |
| W      |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |
| Reset  | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      |

## Fields

| Field   | Function                                                                               |
|---------|----------------------------------------------------------------------------------------|
| 31-0    | Received Data                                                                          |
| RXDATA  | Contains the SPI data from the RX FIFO entry to which the pop next data pointer points |

## 49.6.11 Transmit FIFO Registers (TXFR0 - TXFR4)

## Offset

| Register   | Offset   |
|------------|----------|
| TXFR0      | 3Ch      |
| TXFR1      | 40h      |
| TXFR2      | 44h      |
| TXFR3      | 48h      |
| TXFR4      | 4Ch      |

## Function

These registers provide visibility into the TX FIFO for debugging purposes. Each register is an entry in the TX FIFO. The registers can only be read and not modified. Reading the TXFRx registers does not alter the state of the TX FIFO. Also, reading these registers is invalid if the module is operating in the Extended SPI mode.

## Diagram

<!-- image -->

| Bits   | 31           | 30           | 29           | 28           | 27           | 26           | 25           | 24           | 23           | 22           | 21           | 20           | 19           | 18           | 17           | 16           |
|--------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|
| R      | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA | TXCMD_TXDATA |
| W      |              |              |              |              |              |              |              |              |              |              |              |              |              |              |              |              |
| Reset  | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            |
| Bits   | 15           | 14           | 13           | 12           | 11           | 10           | 9            | 8            | 7            | 6            | 5            | 4            | 3            | 2            | 1            | 0            |
| R      | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       | TXDATA       |
| W      |              |              |              |              |              |              |              |              |              |              |              |              |              |              |              |              |
| Reset  | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            | 0            |

## Fields

| Field               | Function                                                                                                                                                                          |
|---------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-16 TXCMD_TXDA TA | Transmit Command or Transmit Data In Master mode, the TXCMD field contains the command that sets the transfer attributes for the SPI data. In Slave mode, this field is reserved. |
| 15-0                | Transmit Data                                                                                                                                                                     |
| TXDATA              | Contains the SPI data to be shifted out.                                                                                                                                          |

## 49.6.12 Receive FIFO Registers (RXFR0 - RXFR4)

## Offset

| Register   | Offset   |
|------------|----------|
| RXFR0      | 7Ch      |
| RXFR1      | 80h      |
| RXFR2      | 84h      |
| RXFR3      | 88h      |
| RXFR4      | 8Ch      |

## Function

These read-only registers provide visibility into the RX FIFO for debugging purposes. Each register is an entry in the RX FIFO. Reading the RXFRx registers does not alter the state of the RX FIFO. However, the value of MCR[MDIS] must be 0 when RXFR is read.

## NOTE

Accessing a RXFRn register causes all subsequent SPI register accesses to be incorrect. Therefore, you must only read received data through SPI\_POPR.

Serial Peripheral Interface (SPI)

## Diagram

<!-- image -->

| Bits   | 31     | 30     | 29     | 28     | 27     | 26     | 25     | 24     | 23     | 22     | 21     | 20     | 19     | 18     | 17     | 16     |
|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
| R      | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA |
| W      |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |
| Reset  | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      |
| Bits   | 15     | 14     | 13     | 12     | 11     | 10     | 9      | 8      | 7      | 6      | 5      | 4      | 3      | 2      | 1      | 0      |
| R      | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA | RXDATA |
| W      |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |        |
| Reset  | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      |

## Fields

| Field   | Function                       |
|---------|--------------------------------|
| 31-0    | Receive Data                   |
| RXDATA  | Contains the received SPI data |

## 49.6.13 Clock and Transfer Attributes Register Extended (CTARE0 - CTARE5)

## Offset

| Register   | Offset   |
|------------|----------|
| CTARE0     | 11Ch     |
| CTARE1     | 120h     |
| CTARE2     | 124h     |
| CTARE3     | 128h     |
| CTARE4     | 12Ch     |
| CTARE5     | 130h     |

## Function

CTARE registers are used to define the extended transfer attributes for an SPI frame. These registers are valid only when Extended SPI mode is enabled (MCR[XSPI]).

When the module is configured as a SPI master, the CTAS field in CMD FIFO entry selects which of the CTARE registers is used.

Serial Peripheral Interface (SPI)

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | FMSZ |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      | E    |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP | DTCP |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    |

## Fields

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-17 -   | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 16 FMSZE  | Frame Size Extended This field is valid only when MCR[XSPI] is set. This field concatenated with CTAR[FMSZ] defines the Frame size of the SPI frames to be transmitted. Effective frame size would be the concatenation of {CTARE[FMSZE], CTAR[FMSZ]} plus 1. 0b - Default Mode. Up to 16 bit SPI frames can be transfered. 1b - Up to 32 bit SPI frames can be transferred. Each Frame transfer will be a result of 2 simultaneous TX FIFO Pop Operation. |
| 15-11 -   | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 10-0 DTCP | Data Transfer Count Preload This field is valid only when SPIx_MCR[XSPI] is set. This field defines the number of data frames (whose size is defined by CTARE[FMSZE] and CTAR[FMSZ]) to be transmitted using the Command frame which selected this SPIx_CTARE register. The value 0 is reserved and should not be written in this field. The default value of this field is 1.                                                                             |

## 49.6.14 Status Register Extended (SREX)

## Offset

| Register   | Offset   |
|------------|----------|
| SREX       | 13Ch     |

## Function

The register contains status fields. The fields reflect the status of the module and indicate the occurrence of events. This register is not writeable.

Serial Peripheral Interface (SPI)

## Diagram

<!-- image -->

| Bits   | 31   | 30      | 29   | 28   | 27      | 26   | 25   | 24     | 23     | 22     | 21     | 20     | 19        | 18        | 17        | 16        |
|--------|------|---------|------|------|---------|------|------|--------|--------|--------|--------|--------|-----------|-----------|-----------|-----------|
| R      | 0    | 0       | 0    | 0    | 0       | 0    | 0    | 0      | 0      | 0      | 0      | 0      | 0         | 0         | 0         | 0         |
| W      |      |         |      |      |         |      |      |        |        |        |        |        |           |           |           |           |
| Reset  | 0    | 0       | 0    | 0    | 0       | 0    | 0    | 0      | 0      | 0      | 0      | 0      | 0         | 0         | 0         | 0         |
| Bits   | 15   | 14      | 13   | 12   | 11      | 10   | 9    | 8      | 7      | 6      | 5      | 4      | 3         | 2         | 1         | 0         |
| R      | 0    | TXCT R4 | 0    |      | RXCT R4 | 0    |      | CMDCTR | CMDCTR | CMDCTR | CMDCTR | CMDCTR | CMDNXTPTR | CMDNXTPTR | CMDNXTPTR | CMDNXTPTR |
| W      |      |         |      |      |         |      |      |        |        |        |        |        |           |           |           |           |
| Reset  | 0    | 0       | 0    | 0    | 0       | 0    | 0    | 0      | 0      | 0      | 0      | 0      | 0         | 0         | 0         | 0         |

## Fields

| Field         | Function                                                                                                                                                                                                                                                                                                                                     |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-15 -       | Reserved                                                                                                                                                                                                                                                                                                                                     |
| 14 TXCTR4     | TX FIFO Counter[4] This bit is an extension of SR[TXCTR]. The concatenated field {TXCTR4, TXCTR} indicates the number of valid entries in the TX FIFO. This field is incremented every time the PUSHR is written. And this field is decremented every time an SPI command is executed and the SPI data is transferred to the Shift register. |
| 13-12 -       | Reserved                                                                                                                                                                                                                                                                                                                                     |
| 11 RXCTR4     | RX FIFO Counter[4] This bit is an extension of SR[RXCTR]. The concatenated field {RXCTR4, RXCTR} indicates the number of entries in the RX FIFO. This field is decremented every time the POPR is read. And this field is incremented every time data is transferred from the Shift register to the RX FIFO.                                 |
| 10-9 -        | Reserved                                                                                                                                                                                                                                                                                                                                     |
| 8-4 CMDCTR    | CMD FIFO Counter Indicates the number of entries in the CMD FIFO. The CMDCTR is incremented every time the command part of PUSHR is written. The CMDCTR is decremented every time a SPI command is executed (all data frames due to current command frame have been transmitted).                                                            |
| 3-0 CMDNXTPTR | Command Next Pointer Indicates which CMD FIFO Entry is used during the next transfer. The CMDNXTPTR field is updated every time SPI data due to current command have been transmitted.                                                                                                                                                       |

Serial Peripheral Interface (SPI)

## Chapter 50 CAN (FlexCAN)

## 50.1 Chip-specific FlexCAN information

## 50.1.1 Overview

This device contains four FlexCAN modules (FlexCAN\_0 to FlexCAN\_3) that implement the CAN 2.0B and the Flexible Data Rate (FD) CAN protocol specification.

- MCR[MDIS] field is set to 1 by default, each FlexCAN module must be enabled through the software after start-up.
- Doze mode is not supported.

## 50.1.2 Message buffers and data rate

Each FlexCAN instance support 128 message buffers and upto 8 Mbps programmable bit rate, subject to presence of Flexible Data Rate (FD) feature. All FlexCAN modules support individual receive buffer masks and ECC on the SRAM arrays.

The expanded message buffer memory feature allows the use of 28 additional message buffers of 64-byte payload in CAN FD mode.

## 50.1.3 Rx FIFO

The enhanced Rx FIFO feature extends the RxFIFO depth and support CAN FD messages.

The module interrupt requests for the Enhanced Rx FIFO feature, enabled with the Enhanced Rx FIFO Interrupt Enable Register (ERFIER), are not mapped to system-level interrupts. If an application enables these module interrupts, software can poll the fields of the Enhanced Rx FIFO Status Register (ERFSR) to determine when the module interrupt requests occur.

## 50.1.4 Mode configuration

FlexCAN registers always operate in supervisor mode regardless of whether REG\_PROT or the system is in user mode.

## 50.1.5 Booting with FlexCAN

FlexCAN\_0 interfaces support booting from boot ROM.

## 50.1.6 High-resolution timestamp

The FlexCAN instances on this chip use the Timestamp module as the timebase source for the high-resolution timestamp.

You can enable use of the high-resolution timestamp on a per-module basis via the following fields in each FlexCAN instance:

- CTRL2[MBTSBASE] (set to 01b or 10b)
- CTRL2[TSTAMPCAP] (set to 01b, 10b, or 11b)

Using the high-resolution timestamp timebase requires the Timestamp module to be properly configured and running.

## NOTE

Changing the timebase source in the Timestamp module requires disabling all module instances using the Timestamp module timebase. To disable a FlexCAN instance, put the instance in Freeze mode.

## 50.2 Overview

FlexCAN is a communication controller implementing the CAN protocol according to the ISO 11898-1:2015 standard and CAN 2.0 B protocol specifications.

CAN (FlexCAN)

The CAN protocol was primarily designed to be used as a vehicle serial data bus, meeting the specific real-time processing and reliable operation requirements in the electromagnetic interference (EMI) environment of a vehicle. FlexCAN is a full implementation of the CAN protocol specification, the CAN with flexible data rate (CAN FD) protocol, and the CAN 2.0 version B protocol. It supports both standard and extended message frames and long payloads.

<!-- image -->

## 50.2.1 Block diagram

Figure 457 shows the main submodules implemented in FlexCAN.

<!-- image -->

The Protocol Engine (PE) submodule manages the serial communication on the CAN bus:

- Requesting RAM access for receiving and transmitting message frames.
- Validating received messages.
- Performing error handling.
- Detecting CAN FD messages.

The Controller Host Interface (CHI) submodule manages:

- Message buffer selection for reception and transmission.
- Arbitration and ID matching algorithms for both CAN FD and non-CAN FD message formats.

The Bus Interface Unit (BIU) submodule controls access to and from the internal interface bus to establish connection to the CPU and to other blocks. The BIU manages access to:

- Clocks
- Address and data buses

- Interrupt outputs
- DMA
- Test signals

## 50.2.2 Features

FlexCAN includes:

- Full implementation of CAN with Flexible data rate (CAN FD) protocol specification and CAN protocol specification, Version 2.0 B
- Standard data frames
- Extended data frames
- Data length of zero to sixty-four bytes
- Programmable bit rate (see chip-specific FlexCAN information for specific maximum rate configuration)
- Content-related addressing
- Compliance with ISO 11898-1:2015 standard
- Flexible message buffers that can be configured to store a payload of 0, 8, 16, 32, or 64 bytes. Increasing the payload size decreases the number of supported message buffers (see FlexCAN memory partition for CAN FD). Message buffers are configurable as receive or transmit, supporting standard and extended messages.
- Individual Receive Mask registers for each message buffer
- Full-featured legacy receive FIFO with storage capacity for six frames and automatic internal pointer handling with DMA support
- Full-featured enhanced receive FIFO with storage capacity of 32 CAN FD frames and automatic internal pointer handling with DMA support
- Transmission abort capability
- Option to use RAM not used by reception or transmission structures as general-purpose RAM space
- Listen-Only mode
- Programmable loopback mode supporting self-test operation
- Programmable transmission priority scheme: lowest ID, lowest buffer number, or highest priority
- Timestamp based on 32-bit free-running timer, with optional external time tick
- Global network time, synchronized by specific message
- Maskable interrupts
- Independence from transmission medium (external transceiver is assumed)
- Short latency time due to arbitration scheme for high-priority messages
- Low-power mode
- Transceiver delay compensation when transmitting CAN FD messages at faster data rates
- Management of remote request frames automatically or by software
- Restriction only to write CAN bit time settings and configuration bits in Freeze mode
- Transmit message buffer status (lowest-priority buffer or empty buffer)
- Identifier Acceptance Filter Hit Indicator (IDHIT) register for received frames
- SYNCH bit in Error in Status 1 register to indicate module is synchronous with CAN bus
- CRC status for transmitted message

CAN (FlexCAN)

- Legacy Receive FIFO Global Mask register
- Selectable priority between message buffers and receive FIFO during matching process
- Powerful legacy receive FIFO ID filtering, capable of matching incoming IDs against either 128 extended IDs, 256 standard IDs, or 512 partial (8-bit) IDs, with 32 individual masking capability
- Powerful enhanced receive FIFO ID filtering, capable of matching incoming IDs against either 64 extended or 128 standard ID filter elements with three filtering schemes: mask plus filter, range, and two filters without mask.
- Complete backward compatibility with previous FlexCAN version
- Detection and correction of errors in memory read accesses.

Each byte of FlexCAN memory is associated to five parity bits. The error correction mechanism ensures that errors in one bit of this 13-bit word can be corrected (correctable errors). Errors in two bits can be detected but not corrected (non-correctable errors).

## 50.3 Functional description

FlexCAN is a CAN protocol engine with a flexible message buffer system for transmitting and receiving CAN frames. The system is a set of message buffers that stores configuration and control data, timestamp, message ID, and data (see Message buffer structure).

For classical CAN frames, FlexCAN supports simultaneous reception through Legacy FIFO and message buffer. For CAN FD frames, FlexCAN supports reception through message buffer and enhanced receive FIFO.

For message buffer reception, a matching algorithm makes it possible to store received frames only into MBs that have the same ID programmed in the ID field. A masking scheme makes it possible to match the ID programmed on the message buffer with a range of IDs on received CAN frames. For transmission, an arbitration algorithm decides the prioritization of message buffers to be transmitted based on the message ID (optionally augmented by three local priority bits) or the message buffer ordering.

A message buffer is active at a given time if it can participate in both the matching and arbitration processes. A receive message buffer with a 0b code is inactive (see Table 382). A transmit message buffer with a 1000b or 1001b code is also inactive (see Table 383).

FlexCAN can receive and transmit messages in CAN FD format. The message buffers are sized to store the quantity of data bytes selected by FDCTRL[MBDSRn]. The quantity of FD message buffers available for a given quantity of data bytes is described in the CAN FD Control (FDCTRL) register. See also FlexCAN memory partition for CAN FD.

## 50.3.1 Modes of operation

FlexCAN has these functional modes:

Table 347. Functional modes

| Mode     | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Normal   | In Normal mode, FlexCAN receives and transmits message frames, errors are managed normally, and all CAN Protocol functions are enabled.                                                                                                                                                                                                                                                                                                                                                                                   |
| Freeze   | Freeze modeis enabled whenMCR[FRZ]=1.Ifenabled,FlexCANentersFreezemodewhenMCR[HALT] is 1 or when is requested at chip level and FlexCAN writes 1 to MCR[FRZACK]. In this mode, no transmission or reception of frames is done, and synchronicity to the CAN bus is lost. See Freeze mode.                                                                                                                                                                                                                                 |
| Loopback | FlexCAN enters this mode when CTRL1[LPB] becomes 1. In this mode, FlexCAN performs an internal loopback that can be used for self-test. The bit stream output of the transmitter is internally fed back to the receiver input. The receiving CAN input pin is ignored and the transmitting CAN output goes to the recessive state (logic 1). FlexCAN behaves as it normally does when transmitting and treats its own transmitted message as a message received from a remote node. To ensure proper reception of its own |

Table continues on the next page...

Table 347. Functional modes (continued)

| Mode          | Description                                                                                                                                                                                                                                                                                                                                                                                     |
|---------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|               | message, FlexCAN ignores the bit sent during the ACK slot in the CAN frame acknowledge field. Both transmit and receive interrupts are generated.                                                                                                                                                                                                                                               |
| Listen-Only   | FlexCAN enters this mode when CTRL1[LOM] becomes 1. In this mode, transmission is disabled, all error counters are frozen, and the module operates in a CAN Error Passive mode. Only messages acknowledged by another CAN station are received. If FlexCAN detects an unacknowledged message, it flags a BIT0 error (without changing the REC), as if it was trying to acknowledge the message. |
| CAN FD Active | In this mode, FlexCAN can transmit and receive all messages formatted according to the CAN FD Standard (2.0) and 2.0B Protocol in an interleaved fashion. The CPUcanput FlexCAN into CANFDActive mode by configuring MCR[FDEN] in Freeze mode.                                                                                                                                                  |

It is important to know which features are available in CAN FD active mode.

Table 348. Differences between classical CAN and CAN FD

| Feature              | Classical CAN   | CAN FD   |
|----------------------|-----------------|----------|
| Legacy RX FIFO DMA   | Yes             | No       |
| Legacy RX FIFO       | Yes             | No       |
| Enhanced RX FIFO DMA | Yes             | Yes      |
| Enhanced RX FIFO     | Yes             | Yes      |

FlexCAN can operate in these low-power modes.

Table 349. Low-power modes

| Mode           | Description                                                                                                                                                                                                                                                                          |
|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Module Disable | FlexCANentersthismodewhentheCPUwrites1toMCR[MDIS]andFlexCANwrites1toMCR[LPMACK]. After FlexCAN is disabled, it issues a request to disable the clocks to the CAN Protocol Engine and Controller Host Interface submodules. Writing 0to MCR[MDIS]exits thismode.SeeModuleDisablemode. |

## 50.3.1.1 Modes of operation details

FlexCAN has functional modes and low-power modes. See Modes of operation for an introductory description of all the modes of operation. The following subsections contain functional details about Freeze mode and low-power modes.

## CAUTION

FlexCAN does not support "Permanent Dominant" failure on the CAN bus line. If a Low-Power request or Freeze mode request occurs during a "Permanent Dominant" condition, the corresponding acknowledgment field can never be 1.

## 50.3.1.1.1 Freeze mode

This mode is requested either by the CPU writing 1 to MCR[HALT] or when the chip is put into Debug mode. MCR[FRZ] must be 1 and the module must not be in a low-power mode.

When MECR[NCEFAFRZ] becomes 1 and a non-correctable error is detected in a memory read access performed by FlexCAN internal processes (see Error response), FlexCAN also requests Freeze mode. This request occurs via both MCR[HALT] and MCR[FRZ] automatically becoming 1.

CAN (FlexCAN)

To obtain acknowledgment, FlexCAN writes 1 to MCR[FRZACK]. The CPU must only consider FlexCAN to be in Freeze mode when both request and acknowledgment conditions are satisfied.

When Freeze mode is requested, FlexCAN:

- Waits to be in either Intermission, Passive Error, Bus Off, or Idle state.
- Waits for all internal activities like arbitration, matching, move-in, and move-out to finish. A pending move-in does not prevent entering Freeze mode.
- Ignores the receive input pin and drives the transmit pin as recessive.
- Stops the prescaler, halting all CAN protocol activities.
- Grants write access to the Error Counters register, which is read-only in other modes.
- Writes 1 to MCR[NOTRDY] and MCR[FRZACK].

After requesting Freeze mode, you must wait for MCR[FRZACK] to become 1 before executing any other action, otherwise FlexCAN may operate unpredictably. In Freeze mode, all memory-mapped registers are accessible.

Freeze mode is exited in one of these conditions:

- CPU writes 0 to MCR[FRZ].
- The chip is removed from Debug mode or the MCR[HALT] becomes 0.

MCR[FRZACK] becomes 0 after the protocol engine recognizes the negation of the freeze request. After leaving Freeze mode, FlexCAN tries to resynchronize to the CAN bus by waiting for 11 consecutive recessive bits.

## 50.3.1.1.2 Module Disable mode

This low-power mode is normally used to disable a complete FlexCAN block temporarily, with no power consumption. The CPU requests this mode by writing 1 to MCR[MDIS], and FlexCAN acknowledges the request by writing 1 to MCR[LPMACK]. The CPU must only consider FlexCAN to be in Disable mode when both the request and acknowledgment conditions are satisfied.

If FlexCAN is disabled during Freeze mode, the module requests to disable the clocks to the PE and CHI submodules, writes 1 to MCR[LPMACK] and writes 0 to MCR[FRZACK].

If the module is disabled during transmission or reception, FlexCAN:

- Waits to be in either Idle or Bus Off state, or waits for the third bit of Intermission and then checks that it is recessive.
- Waits for all internal activities like arbitration, matching, move-in, and move-out to finish. FlexCAN does not take a pending move-in into account.
- Ignores its receive input pin and drives its transmit pin as recessive.
- Shuts down the clocks to the PE and CHI submodules.
- Writes 1 to MCR[NOTRDY] and MCR[LPMACK].

In this mode, the Bus Interface Unit continues to operate, enabling the CPU to access memory-mapped registers, except for:

- The Receive Message Buffers Global Mask registers
- The Receive Buffer 14 Mask register
- The Receive Buffer 15 Mask register



While in Disable mode, these items may not be accessed:

- The message buffers
- The Receive Individual Mask registers
- The reserved words within RAM

CAN (FlexCAN)

To exit this mode, the CPU writes 0 to MCR[MDIS], causing FlexCAN to request to resume the clocks and write 0 to MCR[LPMACK]. This write occurs after the CAN protocol engine recognizes the negation of disable mode requested by the CPU.

## 50.3.2 Transmission process

To transmit a CAN frame, the CPU must prepare a message buffer for transmission by executing the following procedure:

1. Check whether the respective interrupt flag is set, and clear it if necessary.
2. If the message buffer is active (transmission pending), request an abort of the transmission. Write the ABORT code (1001b) to the CODE field of the Control and Status word.
3. Poll the IFLAG register until the corresponding IFLAG flag is set, or wait for the interrupt request (if enabled by the respective IMASK field).
4. Read the CODE field to identify whether the transmission was aborted or transmitted (see Transmission abort mechanism).
5. Clear the corresponding interrupt flag.
6. Write the ID register (containing the local priority if enabled via MCR[LPRIOEN]).
7. Write payload data bytes.
8. Configure the Control and Status word as needed.
- a. Set ID type via MB\_CS[IDE].
- b. Set Remote Transmission Request (if needed) via MB\_CS[RTR].
- c. If MCR[FDEN] = 1, configure MB\_CS[EDL] and MB\_CS[BRS]. For details about the relationship between the written value and transmitted value of MB\_CS[ESI], see Table 359. [4]
- d. Configure Data Length Code in bytes via MB\_CS[DLC]. See Table 386 for detailed information.
- e. To transmit the CAN frame, activate the message buffer by writing Ch to MB\_CS[CODE].

## NOTE

To maximize software performance, configure all the fields in the MB\_CS word in a single 32-bit write operation. If the fields are configured in separate writes, MB\_CS[CODE] must be the last write in the Control and Status word.

When the MB is activated, it participates in the arbitration process and its contents are eventually transmitted according to its priority. When the DLC value stored in the MB selected for transmission exceeds the MB payload size, FlexCAN completes the expected DLC by adding a constant CCh pattern.

After a successful transmission:

- The value of the free-running timer is written into the timestamp field.
- The CODE field in the Control and Status word is updated.
- Both Cyclic Redundancy Check (CRCR) and CAN FD CRC (FDCRC) are updated.
- A status flag is set in the Interrupt Flag register.
- If allowed by the corresponding Interrupt Mask Register field, an interrupt is generated.

After transmission, the new CODE field depends on the code used to activate the message buffer (see Table 382 and Table 383 in Message buffer structure).

When the Abort feature is enabled (MCR[AEN] is 1), after the Interrupt flag is set for an MB configured as transmit buffer, the message buffer is blocked. The CPU cannot update the message buffer until the Interrupt Flag is cleared by the CPU. The CPU must clear the corresponding IFLAG flag before preparing this MB for a new transmission or reception.

[4] There is no need to write the ESI field; it is automatically transmitted as dominant by error active nodes and as recessive by error passive nodes. If FlexCAN is operating as a network gateway, however, the CPU writes MB\_CS[ESI] according to the error status of the node that sent the message.

## NOTE

For backward compatibility (MCR[AEN] is 0), write the INACTIVE code (1000b) to the CODE field to deactivate the MB. In this case, the pending frame may be transmitted without notification (see Message buffer inactivation).

## 50.3.3 Arbitration process

The arbitration process scans the message buffers, searching for the transmission MB that holds the message to be sent at the next opportunity. This MB is called the arbitration winner.

The scan starts from the lowest number MB and runs toward the higher ones.

The arbitration process is triggered in these ways:

- CRC field of the CAN frame arrives. The starting point depends on the value of CTRL2[TASD].
- Error Delimiter field of a CAN frame is in progress.
- Overload Delimiter field of a CAN frame is in progress.
- The winner of the arbitration is deactivated, and the CAN bus has not reached the first bit of the Intermission field.
- CPU writes to the Control and Status word of a winner MB, and the CAN bus has not reached the first bit of the Intermission field.
- CHI is in the Idle state and the CPU writes to the Control and Status word of any message buffer.
- FlexCAN exits Bus Off state.
- FlexCAN leaves Freeze mode or a low-power mode.

If the arbitration process does not evaluate all message buffers before the CAN bus reaches the first bit of the Intermission field, the temporary arbitration winner is invalidated. FlexCAN will not compete for the CAN bus at the next opportunity.

The arbitration process selects the winner among the active transmission message buffers at the end of the scan according to the values of CTRL1[LBUF] and MCR[LPRIOEN].

## 50.3.3.1 Lowest-number message buffer first

If CTRL1[LBUF] is 1, the first (lowest number) active transmission message buffer found is the arbitration winner. MCR[LPRIOEN] has no effect when CTRL1[LBUF] is 1.

## 50.3.3.2 Highest-priority message buffer first

If CTRL1[LBUF] is 0, the arbitration process searches for the active transmission message buffer with the highest priority. The frame of this message buffer has a higher probability of winning the arbitration on the CAN bus when multiple external nodes compete for the bus simultaneously.

The sequence of bits considered for this arbitration is called the arbitration value of the message buffer. The transmission message buffer with the lowest arbitration value among all transmission message buffers has the highest priority.

If two or more message buffers have equivalent arbitration values, the message buffer with the lowest number is the arbitration winner.

The composition of the arbitration value depends on MCR[LPRIOEN].

## 50.3.3.2.1 Local priority disabled

If MCR[LPRIOEN] = 0, the arbitration value is built using the exact sequence of bits that would be transmitted in a CAN frame where local priority is disabled.

CAN (FlexCAN)

Table 350. Composition of the arbitration value when local priority is disabled

| Format             | Message buffer arbitration value (32 bits)   | Message buffer arbitration value (32 bits)   | Message buffer arbitration value (32 bits)   | Message buffer arbitration value (32 bits)   | Message buffer arbitration value (32 bits)   |
|--------------------|----------------------------------------------|----------------------------------------------|----------------------------------------------|----------------------------------------------|----------------------------------------------|
| Standard (IDE = 0) | Standard ID (11 bits)                        | RTR (1 bit)                                  | IDE (1 bit)                                  | -(18 bits)                                   | -(1 bit)                                     |
| Extended (IDE = 1) | Extended ID[28:18] (11 bits)                 | SRR (1 bit)                                  | IDE (1 bit)                                  | Extended ID[17:0] (18 bits)                  | RTR (1 bit)                                  |

## 50.3.3.2.2 Local priority enabled

To enable local priority, MCR[LPRIOEN] must be 1. In this case, the message buffer PRIO field is included at the very left of the arbitration value (see the following table).

Table 351. Composition of the arbitration value when local priority is enabled

| Format             | Message buffer arbitration value (35 bits)   | Message buffer arbitration value (35 bits)   | Message buffer arbitration value (35 bits)   | Message buffer arbitration value (35 bits)   | Message buffer arbitration value (35 bits)   | Message buffer arbitration value (35 bits)   |
|--------------------|----------------------------------------------|----------------------------------------------|----------------------------------------------|----------------------------------------------|----------------------------------------------|----------------------------------------------|
| Standard (IDE = 0) | PRIO (3 bits)                                | Standard ID (11 bits)                        | RTR (1 bit)                                  | IDE (1 bit)                                  | -(18 bits)                                   | -(1 bit)                                     |
| Extended (IDE = 1) | PRIO (3 bits)                                | Extended ID[28:18] (11 bits)                 | SRR (1 bit)                                  | IDE (1 bit)                                  | Extended ID[17:0] (18 bits)                  | RTR (1 bit)                                  |

Because the PRIO field is the most significant part of the arbitration value, message buffers with low PRIO values have higher priority than message buffers with high PRIO values. This priority is maintained regardless of the rest of their arbitration values.

The PRIO field is not part of the frame on the CAN bus. Its purpose is only to affect the internal arbitration process.

## 50.3.3.3 Arbitration process (continued)

After the arbitration winner is found, its content is copied to a hidden auxiliary message buffer called a transmit serial message buffer (TX SMB). The TX SMB has the same structure as a normal message buffer, but is not user accessible. This copy operation is called move-out. After it is done, write access to the Control and Status word of the corresponding MB is blocked (if MCR[AEN] = 1). Write access is restored in the following events:

- The CPU clears the corresponding IFLAG flag after the message buffer is transmitted.
- FlexCAN enters Freeze mode or Bus Off state.
- FlexCAN loses the bus arbitration, or there is an error during the transmission.

At the first opportunity window on the CAN bus, the message on the TX SMB is transmitted according to the CAN protocol rules.

The arbitration process can be triggered under the following conditions:

- During RX and TX frames from CAN CRC field to end of frame. The value of CTRL2[TASD] may be changed to optimize the arbitration start point.
- During CAN Bus Off state from TX\_ERR\_CNT = 124 to 128. The value of CTRL2[TASD] may be changed to optimize the arbitration start point.
- During Control and Status write by CPU in Bus Idle. The first Control and Status write starts the arbitration process, and a second Control and Status write during this same arbitration restarts the process. If other Control and Status writes are performed, the transmission arbitration process is pending. If there is no arbitration winner after the arbitration process has finished, then the TX arbitration machine begins a new arbitration process. If there is a pending arbitration and Bus Idle state starts, then an arbitration process is triggered. In this case, the first and second Control and Status writes in Bus Idle do not restart the arbitration process. If there is not enough time to finish arbitration in the Wait For Bus Idle state and the next state is Idle, the scan is not interrupted. That scan is completed during Bus Idle state. During this arbitration, a Control and Status write does not cause an arbitration restart.

- Deactivation of an arbitration winner during a valid arbitration window.
- Upon exiting Freeze mode (first bit of the Wait For Bus Idle state). If a resynchronization occurs during Wait For Bus Idle, the arbitration process is restarted.

The arbitration process stops when:

- All message buffers were scanned.
- A transmission message buffer is found (if lowest buffer feature is enabled).
- An arbitration winner deactivates or aborts during any arbitration process.
- There is not enough time to finish the transmission arbitration process (for instance, when a deactivation is performed near the end of frame). In this case, the arbitration process is pending.
- An error or overload flag occurs in the bus.
- A low-power or Freeze mode request occurs in Idle state.

Arbitration is considered pending when:

- It is not possible to finish arbitration process in time.
- A Control and Status write occurs during arbitration, when that write is performed in an MB whose number is lower than the transmission arbitration pointer.
- Any Control and Status write occurs when there is no transmission arbitration process in progress.
- RX Match has updated an RX code to TX code.
- FlexCAN enters the Bus Off state.

If a Control and Status write is performed in the arbitration winner, a new process is restarted immediately.

If a Control and Status write is performed in an MB whose number is higher than the transmission arbitration pointer, the ongoing arbitration process scans this MB as normal.

## 50.3.4 Receive process

To be able to receive CAN frames into a message buffer, the CPU must prepare it for reception by executing the following steps:

1. If the message buffer is active (either TX or RX) deactivate it (see Message buffer inactivation), preferably with a safe deactivation (see Transmission abort mechanism).
2. Write the ID word into the message buffer.
3. To activate the message buffer, write the EMPTY code (0100b) to the CODE field of the Control and Status word. No setup is required for EDL, BRS, and ESI fields. The respective fields in the received message overwrite these fields.

After the MB is activated, it can receive frames that match the programmed filter. At the end of a successful reception, the move-in process updates the message buffer (see Move-in) as follows:

1. The received data field (up to eight bytes for Classical CAN message format and up to 64 bytes for CAN FD message format) is stored.
2. The received Identifier field is stored.
3. The value of the free-running timer when the second bit of the Identifier field of the frame is written into the Timestamp field of the MB.
4. The received SRR, IDE, RTR, EDL, BRS, ESI, and DLC fields are stored.
5. The CODE field in the Control and Status word is updated (see Table 382 and Table 383 in Section Message buffer structure).
6. If allowed by the corresponding Interrupt Mask field, a status flag is set in the Interrupt Flag register and an interrupt is generated.

The recommended way for the CPU to service (read) the frame received in a message buffer is:

CAN (FlexCAN)

1. Read the Control and Status word of that message buffer.
2. Verify that the BUSY bit is 0, indicating that the message buffer is locked. Repeat step 1 while the value remains 1. See Message buffer lock mechanism.
3. Read the contents of the message buffer. After the message buffer is locked, FlexCAN move-in processes do not modify its contents. See Move-in.
4. Acknowledge the proper flag in the IFLAG registers.
5. Unlock the message buffer by reading the free-running timer.

To verify frame reception, the CPU should poll the status flag bit for the specific message buffer in one of the IFLAG registers, not the CODE field of that message buffer. Polling the CODE field does not work in this case. After a frame is received and the CPU services the message buffer (by reading the Control and Status word and unlocking the message buffer), the CODE field does not return to EMPTY. It remains FULL, as explained in Table 382. If the CPU tries to work around this behavior by writing to the Control and Status word to force an EMPTY code after reading the message buffer without a prior safe deactivation, a newly received frame matching the filter of that message buffer may be lost.

## CAUTION

In summary: never poll by reading the Control and Status word of the message buffers directly. Instead, read the IFLAG registers.

The Identifier field of the received frame is always stored in the matching message buffer. If the match was due to masking, the contents of the ID field in a message buffer may change. When MCR[SRXDIS] becomes 1, FlexCAN does not store frames transmitted by itself in any MB, even if it contains a matching receive MB. Also, no interrupt flag or interrupt signal is generated. Otherwise, when MCR[SRXDIS] becomes 0, if a matching receive MB exists, FlexCAN can receive frames transmitted by itself.

When MCR[DMA]) becomes 1, upon receiving a frame in the Legacy FIFO, IFLAG1[BUF5I] generates a DMA request and does not generate a CPU interrupt (see Legacy RX FIFO in DMA Operation). The IMASK1 fields in the Legacy RX FIFO region are not used.

The DMA controller must service the received frame using the following procedure:

1. Read the Control and Status word (read 80h address, optional).
2. Read the ID field (read 84h address, optional).
3. Read all data bytes (start read at 88h address, optional).

## 50.3.5 Matching process

The matching process scans the message buffer memory for RX MBs programmed with the same ID as the one received from the CAN bus. . The matching starts from the lowest number message buffer and continues toward the higher-numbered ones.

For enhanced RX FIFO, see Enhanced RX FIFO.

For legacy RX FIFO, see Legacy RX FIFO.

As the frame is received, it is stored in a hidden auxiliary MB called Receive Serial Message Buffer (RX SMB).

The starting point of the matching process depends on the following conditions:

- If the received frame is a remote frame, the starting point is the CRC field of the frame.
- If the received frame is a data frame with DLC field equal to zero, the starting point is the CRC field of the frame.
- If the received frame is a data frame and the DLC field has a nonzero value, the starting point is the DATA field of the frame.

If a matching ID is found in one of the message buffers, the move-in process transfers the contents of the RX SMB to the matched MB. If any CAN protocol error is detected, no match results are transferred to the matched MB at the end of reception.

The matching process scans all matching elements of the the active receive MBs (CODE is EMPTY, FULL, OVERRUN, or RANSWER). The process searches for a successful comparison to the matching elements of the RX SMB that is receiving the frame on the CAN bus. The RX SMB has the same structure as a message buffer. The reception structures (message buffers)

CAN (FlexCAN)

CAN (FlexCAN)

associated with the matching elements that had a successful comparison are the matched structures. The matching winner is selected at the end of the scan among those matched structures. The matching winner depends on conditions described in Table 352.

## Table 352. Matching architecture

| Structure      |   SMB[RTR] | CTRL2[RRS]   | CTRL2[EACE N]   | MB[IDE]   | MB[RTR]   | MB[ID 1 ]   | MB[CODE]                 |
|----------------|------------|--------------|-----------------|-----------|-----------|-------------|--------------------------|
| Message buffer |          0 | -            | 0               | cmp 2     | no_cmp 3  | cmp_msk 4   | EMPTY or FULL or OVERRUN |
| Message buffer |          0 | -            | 1               | cmp_msk   | cmp_msk   | cmp_msk     | EMPTY, FULL, or OVERRUN  |
| Message buffer |          1 | 0            | -               | cmp       | no_cmp    | cmp         | RANSWER                  |
| Message buffer |          1 | 1            | 0               | cmp       | no_cmp    | cmp_msk     | EMPTY, FULL, or OVERRUN  |
| Message buffer |          1 | 1            | 1               | cmp_msk   | cmp_msk   | cmp_msk     | EMPTY, FULL, or OVERRUN  |

3. no\_cmp: The RX SMB contents are not compared to the MB contents.
2. cmp: Compares the RX SMB contents to the MB contents regardless of masks.
4. cmp\_msk: Compares the RX SMB contents to MB contents, accounting for masks.

## NOTE

For Enhanced RX FIFO, see Enhanced RX FIFO matching process.

A reception structure is free-to-receive when any of the following conditions is satisfied:

- The CODE field of the message buffer is EMPTY.
- The CODE field of the message buffer is either FULL or OVERRUN. Also, it has already been serviced (the CPU has read the Control and Status word and unlocked as described in Message buffer lock mechanism).
- The CODE field of the message buffer is either FULL or OVERRUN and an inactivation (see Message buffer inactivation) is performed.

The scan order for message buffers is from the matching element with lowest number to the higher ones.

MCR[IRMQ] affects the matching winner search for MBs. If the field is 0, the matching winner is the first matched MB regardless if it is free-to-receive or not. If it is 1, the matching winner is selected according to this priority:

1. The first free-to-receive matched message buffer
2. The last non-free-to-receive matched message buffer

If a non-safe MB inactivation (see Message buffer inactivation) occurs during the matching process and the inactivated MB is the temporary matching winner, the temporary matching winner is invalidated. The matching elements scan is not stopped and not restarted; it continues normally. The consequence is that the current matching process works as if the matching elements compared before the inactivation did not exist. In this case, a message may be lost.

Consider an example where:

- MCR[IRMQ] is 1.

- There are two message buffers with the same ID: the second and fifth MBs in the array.
- FlexCAN starts receiving messages with that ID.

When the first message arrives, the matching algorithm finds the first match in message buffer number 2. The code of this message buffer is EMPTY, so the message is stored in that MB. When the second message arrives, the matching algorithm finds MB number 2 again, but it is not "free-to-receive", so it keeps looking, finds MB number 5, and stores the message in that MB. If yet another message with the same ID arrives, the matching algorithm finds no matching free-to-receive MBs, so it overwrites the last matched message buffer (MB number 5). In doing so, it sets the CODE field of the message buffer to OVERRUN.

The ability to match the same ID in more than one MB can be used to implement a reception queue to allow more time for the CPU to service the MBs. By programming more than one MB with the same ID, received messages are queued into the message buffers. The CPU can examine the Timestamp field of the message buffers to determine the order in which the messages arrived.

Matching a range of IDs is possible via ID acceptance masks. FlexCAN supports individual masking per message buffer (see Receive Individual Mask (RXIMR0 - RXIMR127)). During the matching algorithm, if a mask field is 1, the corresponding ID bit is compared. If the mask field is 0, the corresponding ID bit is a "don't care". Individual Mask Registers are implemented in RAM, so they are not initialized out of reset. Also, they can only be programmed when the module is in Freeze mode; otherwise, the module blocks them.

FlexCAN also supports an alternate masking scheme with only RX Message Buffers Global Mask (RXMGMASK), Receive 14 Mask (RX14MASK), and Receive 15 Mask (RX15MASK) for backward compatibility with legacy applications. This alternate masking scheme is enabled when the MCR[IRMQ] = 0.

## 50.3.6 Move process

There are two types of move process: move-in and move-out.

## 50.3.6.1 Move-in

The move-in process is the copying of a message received by an RX SMB to an RX message buffer that has matched it. Each RX SMB has its own move-in process, but only one is performed at a given time. The move-in starts only when the message held by the RX SMB has a corresponding match (see Matching process) and all of the following conditions are true:

- The CAN bus has reached or already gone past:
- The second bit of Intermission field next to the frame that carried the message that is in the RX SMB.
- The first bit of an overload frame next to the frame that carried the message in the RX SMB.
- There is no ongoing matching process.
- The CPU is not locking the destination message buffer.
- No move-in process from another RX SMB is ongoing. If more than one move-in process is to be started at the same time, both are performed and the newest process substitutes for the oldest.

The term pending move-in is used throughout the documentation and stands for a move-to-be that does not satisfy all of the above conditions.

If any of the following conditions is satisfied, the move-in is canceled and the RX SMB is able to receive another message.

- The destination message buffer is inactivated after the CAN bus has reached the first bit of the Intermission field next to the frame that carried the message. Also, its matching process has finished.
- There is a previous pending move-in to the same destination message buffer.
- The RX SMB is receiving a frame transmitted by FlexCAN itself and self-reception is disabled (MCR[SRXDIS] = 1).
- Any CAN protocol error is detected.

If the module enters Freeze or Low-Power mode, the pending move-in is not canceled. It remains on hold, waiting for Freeze and Low-Power mode to be exited and for the module to be unlocked. If a message buffer is unlocked during Freeze mode, the move-in occurs immediately.

The move-in process is FlexCAN executing the following steps:

CAN (FlexCAN)

1. Read all data words from the RX SMB in accordance with the selected payload size for the RX storage element.
2. Write all data words to the RX message buffer according to the selected payload size for the RX storage element. If the data size of the storage element is smaller than the original payload size described in the DLC field of the message, the payload is truncated. The high-order bytes that do not fit the destination size are lost.
3. Read the Control and Status and ID words from the RX SMB.
4. Write the Control and Status and ID words to the RX message buffer, and update the CODE field.

The move-in process is not atomic; the inactivation of the destination message buffer immediately cancels it (see Message buffer inactivation). In this case, the message buffer may remain partially updated, and therefore incoherent.

To alert the CPU that the message buffer content is temporarily incoherent, the BUSY Bit (least significant bit of the CODE field) of the destination message buffer becomes 1 during move-in.

## 50.3.6.2 Move-out

The move-out process is the copying of content from a TX message buffer to the TX SMB when a message for transmission is available (see Arbitration process). The move-out occurs in the following conditions:

- In the first bit of Intermission field
- During the Bus Off state, when TX Error Counter is in the 124 to 128 range
- During the Bus Idle state
- During the Wait For Bus Idle state

The move-out process is not atomic. Only the CPU has priority to access the memory concurrently outside the Bus Idle state. In Bus Idle, the move-out has the lowest priority of the concurrent memory accesses.

## 50.3.7 Data coherence

In order to maintain data coherency and proper FlexCAN operation, the CPU must obey the rules described in Transmission process and Receive process.

## 50.3.7.1 Transmission abort mechanism

The abort mechanism provides a safe way to request the abortion of a pending transmission. A feedback mechanism is provided to inform the CPU whether the transmission was aborted or the frame could not be aborted and was transmitted instead.

These primary conditions must be fulfilled in order to abort a transmission:

- MCR[AEN] must be 1.
- The first CPU action must be the writing of abort code (1001b) into the CODE field of the Control and Status word.

Active message buffers configured for transmission must be aborted before they can be updated. The write operation is blocked and the transmission is not disturbed when the abort code is written to:

- A message buffer currently being transmitted.
- A message buffer that was already loaded into the TX SMB for transmission.

In this case, the abort request is captured and kept pending until one of the following conditions is satisfied:

- The module loses the bus arbitration.
- There is an error during the transmission.
- The module is put into Freeze mode.
- The module enters the Bus Off state.
- There is an overload frame.

If none of the conditions above are reached:

- The message buffer is transmitted correctly.
- The interrupt flag is set in the proper IFLAG register.
- If enabled, an interrupt to the CPU is generated.

The abort request is automatically cleared when the interrupt flag is set. If only one of the above conditions is reached, the frame is not transmitted. In this case:

- The abort code is written into the CODE field.
- The interrupt flag is set in the proper IFLAG register.
- Optionally, an interrupt is generated to the CPU.

If the CPU writes the abort code before the transmission begins internally, the write operation is not blocked. The MB is updated and the interrupt flag is set. In this way, the CPU only must read the abort code to verify that the active MB was safely inactivated. In this case, although MCR[AEN] = 1 and the CPU wrote the abort code, the MB is inactivated and not aborted, because the transmission did not start yet. A message buffer is aborted only when the abort request is captured and kept pending until one of the previous conditions is satisfied.

## 50.3.7.2 Message buffer inactivation

Inactivation protects the message buffer against updates by FlexCAN internal processes. It allows the CPU to rely on message buffer data coherence after having updated it, even in Normal mode.

Inactivation of transmission message buffers must be performed only when MCR[AEN] = 0.

If a message buffer is inactivated, it does not participate in the arbitration process or the matching process until it is reactivated. See Transmission process and Receive process for detailed instructions on how to inactivate and reactivate a message buffer.

To inactivate a message buffer, the CPU must update its CODE field to INACTIVE (either 0b or 1000b).

Because you cannot synchronize the CODE field update with FlexCAN internal processes, an inactivation can have the following consequences:

- A frame in the bus that matches the filtering of an inactivated RX message buffer may be lost without notice. This loss can occur even if there are other message buffers with the same filter.
- A frame containing the message within an inactivated TX message buffer may be transmitted without setting the respective IFLAG flag.

To perform a safe inactivation and avoid the above consequences for TX message buffers, the CPU must use the transmission abort mechanism (see Transmission abort mechanism).

The inactivation automatically unlocks the message buffer (see Message buffer lock mechanism).

## 50.3.7.3 Message buffer lock mechanism

In addition to message buffer inactivation, FlexCAN uses a message buffer lock mechanism to maintain data coherence for the receive process. When the CPU reads the Control and Status word of an RX message buffer with codes FULL or OVERRUN, FlexCAN is configured to allow the CPU to read the whole message buffer in an atomic operation. It sets an internal lock flag for that message buffer.

The lock is released when:

- The CPU reads the free-running timer (global unlock operation).
- The CPU reads the Control and Status word of another message buffer, regardless of its code.
- The CPU writes into the Control and Status word. This procedure is not recommended for normal unlocking, because it cancels a pending move and may lose a received message.

The message buffer lock prevents a new frame from being written into the message buffer while the CPU is reading it.

CAN (FlexCAN)

## NOTE

The locking mechanism applies only to RX message buffers that have a code other than INACTIVE (0b) or EMPTY [1]  (0100b). Also, TX message buffers cannot be locked.

Consider an example where:

- The second and the fifth message buffers of the array are programmed with the same ID.
- FlexCAN has already received and stored messages into these two message buffers.
- The CPU reads message buffer number 5 while another message with the same ID is arriving.

When the CPU reads the Control and Status word of message buffer number 5, this message buffer is locked. The new message arrives and the matching algorithm finds no free-to-receive message buffers, so it overrides message buffer number 5. This message buffer is locked, so the new message cannot be written to it. The message remains in the RX SMB until the message buffer is unlocked, and only then is it written to the message buffer.

If the message buffer remains locked and another new message with the same ID arrives, the new message overwrites the one in the RX SMB. There is no indication of lost messages in the CODE field of the message buffer or in the Error and Status Register.

While the message is moved from the RX SMB to the message buffer, the BUSY bit on the CODE field becomes 1. If the CPU reads the Control and Status word and identifies that the BUSY bit is 1, it should wait until the BUSY bit becomes 0 to access the MB.

## NOTE

If the BUSY bit is 1 or the message buffer is empty, reading the Control and Status word does not lock the message buffer.

Inactivation takes precedence over locking. If the CPU inactivates a locked receive message buffer, then its lock status is negated and the message buffer is marked as invalid for the current matching round. Any pending message on the RX SMB is not transferred to the message buffer. A message buffer is unlocked when the CPU reads Free-Running Timer (TIMER) or the Control and Status word of another message buffer.

The lock and unlock mechanisms have the same functionality in Normal and Freeze modes.

An unlock during Normal or Freeze mode results in the move-in of the pending message. If unlocking occurs during a low-power mode, however, the move-in is postponed (see Modes of operation). Move-in takes place only when the module returns to Normal or Freeze mode.

## 50.3.8 Enhanced RX FIFO

FlexCAN supports an enhanced RX FIFO engine which can store up to 32 CAN FD messages. The region 2000h-204Fh contains the output of the FIFO, which the CPU should read. To enable the enhanced RX FIFO, write 1 to ERFCR[ERFEN]. FlexCAN has two FIFO options, Legacy RX FIFO and Enhanced RX FIFO, but both options cannot be enabled at the same time. See Legacy RX FIFO for information about Legacy RX FIFO.

To configure the enhanced RX FIFO watermark, write a value to ERFCR[ERFWM]. If ERFCR[ERFWM] is configured, the CPU is notified only if a minimum number of messages is stored in the FIFO. When the number of stored messages is greater than the value in ERFCR[ERFWM], the module sets ERFSR[ERFWMI]. Optionally, if MCR[DMA] or ERFIER[ERFWMIIE] are set, an interrupt or a DMA transfer can be triggered, respectively.

For the enhanced RX FIFO to receive, the CPU must execute the configuration procedure below. If the CPU must change any configurations of the Enhanced RX FIFO, the same procedure must be followed.

## Prerequisites

MCR[RFEN] must be 0.

## Procedure

[1] In previous FlexCAN versions, reading the Control and Status word locked the message buffer even if it was EMPTY. This behavior is maintained when the IRMQ bit is 0.

CAN (FlexCAN)

|   Step | Purpose                                                                                                     | Programming                                                                            | Notes                                                                                                      |
|--------|-------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
|      1 | Enter Freeze mode.                                                                                          | See Freeze mode.                                                                       | -                                                                                                          |
|      2 | If enhanced RX FIFO is not already enabled, enable it.                                                      | Write 1 to ERFCR[ERFEN].                                                               | -                                                                                                          |
|      3 | Reset enhanced RX FIFO engine.                                                                              | Write 1 to ERFSR[ERFCLR].                                                              | -                                                                                                          |
|      4 | If the enhanced RX FIFO error flags are set, clear them.                                                    | Write 1 to these flags:  ERFSR[ERFUFW]  ERFSR[ERFOVF]  ERFSR[ERFWMI]  ERFSR[ERFDA] | -                                                                                                          |
|      5 | Specify the total number of enhanced RX FIFO filter elements to be used in Enhanced RX FIFO reception.      | Write the number to ERFCR[NFE].                                                        | -                                                                                                          |
|      6 | Specify the number of extended ID and standard ID filter elements to be used in Enhanced RX FIFO reception. | Write the number to ERFCR[NEXIF].                                                      | ERFCR[NEXIF]  ERFCR[NFE] + 1.                                                                             |
|      7 | If you are using DMA, enable DMA.                                                                           | Write 1 to MCR[DMA].                                                                   | -                                                                                                          |
|      8 | If you are using DMA, specify the number of words to transfer for each Enhanced RX FIFO data element.       | Write the number to ERFCR[DMALW].                                                      | -                                                                                                          |
|      9 | Specify the Enhanced RX FIFO watermark.                                                                     | Write the number to ERFCR[ERFWM].                                                      | If MCR[DMA] = 1, ERFCR[ERFWM] should be 0h.                                                                |
|     10 | If you are using interrupts, enable the interrupts.                                                         | Write 1 to the interrupt enables in Enhanced RX FIFO Interrupt Enable (ERFIER).        | -                                                                                                          |
|     11 | Configure the filter elements.                                                                              | Write to the ERFFEL n registers.                                                       | ERFFEL n registers are implemented in RAM; you must explicitly initialize them before prior any reception. |
|     12 | Exit Freeze mode.                                                                                           | See Freeze mode.                                                                       | -                                                                                                          |

There are two types of enhanced RX FIFO filter elements that can be stored in ERFFELn registers: extended-ID filter elements and standard-ID filter elements. Each extended-ID filter element is stored in two ERFFELn registers, while each standard-ID filter element is stored in one ERFFELn register. ERFCR[NFE] defines the total number of Enhanced RX FIFO filter elements.

In addition, the filter memory space can be split into two regions: one for extended-ID filter elements and another for standard-ID filter elements, according to ERFCR[NEXIF]. Figure 458 shows how the enhanced RX filter elements are defined. See Enhanced RX FIFO matching process for information about the Enhanced RX FIFO matching process and filter element formats.

<!-- image -->

## 50.3.8.1 Enhanced RX FIFO matching process

When ERFCR[ERFEN] = 1, FlexCAN scans the ERFFELn memory region. If at least one filter element satisfies the matching criteria, the CAN message content is transferred to the enhanced RX FIFO memory. If multiple filters match the incoming message ID, the first matching filter found by the matching process must be indicated in IDHIT.

Each ERFFELn register can store one standard filter element. ERFFELn[FSCH] determines the matching criteria in this way:

- If FSCH = b00, the filter scheme is based on mask and filter. A CAN message matches a standard ID filter element only if these criteria are reached:
1. CAN message is base-frame format (IDE = 0).
2. (ID[n] = STD ID filter [n]) or (STD ID Mask[n] = 0) for each bit n from 0 to 10.
3. (RTR = RTR Filter) or (RTR MASK = 0).

In this explanation, RTR and ID are the Remote Transmit Request field and the ID from a CAN message, respectively. If FSCH = b00, the filters and masks are defined as shown in Table 353.

## Table 353. Standard ID filter element with filter and mask scheme (FSCH = b00)

| 31         | 30         | 29       | 28       | 27         | 26            | 16       | 15       | 12       | 11       | 10          | 0           |
|------------|------------|----------|----------|------------|---------------|----------|----------|----------|----------|-------------|-------------|
| FSCH = b00 | FSCH = b00 | Reserved | Reserved | RTR filter | STD ID filter | Reserved | Reserved | RTR mask | RTR mask | STD ID mask | STD ID mask |

- If FSCH = b01, the filter scheme is based on range. A CAN message matches a standard ID filter element only if these criteria are reached:

1. CAN message is base frame format (IDE = 0).
2. ID  STD ID Filter1.
3. ID  STD ID Filter2.
4. (RTR = RTR filter) or (RTR MASK = 0).

RTR and ID are the Remote Transmit Request bit and ID from a CAN message, respectively. If FSCH = b01, the filters and mask are defined as shown in Table 354.

## Table 354. Standard ID filter element with range scheme (FSCH = b01)

|            | 30         | 29       | 28       | 27         | 26             | 31             | 16       | 15       | 12       | 11       | 10             | 0              |
|------------|------------|----------|----------|------------|----------------|----------------|----------|----------|----------|----------|----------------|----------------|
| FSCH = b01 | FSCH = b01 | Reserved | Reserved | RTRfil ter | STD ID Filter2 | STD ID Filter2 | Reserved | Reserved | Reserved | RTR mask | STD ID Filter1 | STD ID Filter1 |

- If FSCH = b10, the filter scheme is based on two filters without masks. A CAN message matches a standard ID filter element only if these criteria are reached:
1. CAN message is base frame format (IDE = 0).
2. (ID[n] = STD ID Filter1[n]) or (ID[n] = STD ID Filter2[n]) for each bit n from 0 to 10.
3. (RTR = RTR Filter1) or (RTR = RTR Filter2).

RTR and ID are the Remote Transmit Request bit and ID from a CAN message, respectively. If FSCH = b10, the filters are defined as shown in Table 355.

Table 355. Standard ID filter element with two-filter scheme (FSCH = b10)

|            | 30         | 29       | 28       | 27           | 26   | 31             | 16             | 15       | 12       | 11           | 10           |                | 0              |
|------------|------------|----------|----------|--------------|------|----------------|----------------|----------|----------|--------------|--------------|----------------|----------------|
| FSCH = b10 | FSCH = b10 | Reserved | Reserved | RTR Filter 2 |      | STD ID Filter2 | STD ID Filter2 | Reserved | Reserved | RTR Filter 1 | RTR Filter 1 | STD ID Filter1 | STD ID Filter1 |

Each pair of ERFFELn registers can store one extended filter element. ERFFELn[FSCH] determines the matching criteria in this way:

- If FSCH = b00, the filter scheme is based on mask and filter. A CAN message matches an extended ID filter element only if these criteria are reached:
1. CAN message is extended frame format (IDE = 1).
2. (ID[n] = EXT ID filter [n]) or (EXT ID Mask[n] = 0) for each bit n from 0 to 28.
3. (RTR = RTR Filter) or (RTR MASK = 0).

If FSCH = b00, the filters and masks are defined as shown in Table 356.

Table 356. Extended ID filter element with filter + mask scheme (FSCH = b00)

| 31       | 30       | 29         | 28            |
|----------|----------|------------|---------------|
| FSCH     | FSCH     | RTR filter | EXT ID filter |
| Reserved | Reserved | RTR mask   | EXT ID mask   |

- If FSCH = b01, the filter scheme is based on range. A CAN message matches an extended ID filter element only if the following criteria are reached:
1. CAN message is extended frame format (IDE = 1).

CAN (FlexCAN)

2. ID  EXT ID Filter1.
3. ID  EXT ID Filter2.
4. (RTR = RTR Filter) or (RTR MASK = 0).

If FSCH = b01, the filters and masks are defined as shown in Table 357.

Table 357. Extended ID filter element with range scheme (FSCH = b01)

| 31       | 30       | 29         | 28              |
|----------|----------|------------|-----------------|
| FSCH     | FSCH     | RTR filter | EXT ID Filter2  |
| Reserved | Reserved | RTR mask   | EXT ID filter 1 |

- If FSCH = b10, the filter scheme is based on two filters without masks. A CAN message matches an extended ID filter element only if these criteria are reached:
1. CAN message is extended frame format (IDE = 1).
2. (ID[n] = EXT ID Filter1[n]) or (ID[n] = EXT ID Filter2[n]) for each bit n from 0 to 28.
3. (RTR = RTR Filter1) or (RTR = RTR Filter2).

If FSCH = b10, the filters are defined as shown in Table 358.

## Table 358. Extended ID filter element with two-filter scheme (FSCH = b10)

| 31       | 30       | 29          | 28              |
|----------|----------|-------------|-----------------|
| FSCH     | FSCH     | RTR Filter2 | EXT ID Filter2  |
| Reserved | Reserved | RTR Filter1 | EXT ID filter 1 |

## 50.3.8.2 Enhanced RX FIFO under DMA operation

You can enable the DMA feature by writing 1 to both ERFCR[ERFEN] and MCR[DMA]. The DMA controller can read the received message by reading a message buffer structure at the enhanced FIFO output port at the address range defined in Enhanced RX FIFO structure.

FlexCAN supports 32-bit access only for DMA transfers.

NOTE

For proper FIFO engine operation, the CPU should not access the Enhanced FIFO output port address range during DMA operation. Before writing 1 to MCR[DMA], the CPU must service Enhanced RX FIFO status bits. Otherwise, these bits may show that the FIFO has data to be serviced, and mistakenly generate a DMA request. Before writing 0 to MCR[DMA], the CPU must first clear the ERFSR[ERFUFW], ERFSR[ERFOVF], ERFSR[ERFWMI], and ERFSR[ERFDA] flags. It must then clear the enhanced RX FIFO engine by writing one to ERFSR[ERFCLR].

When there is one frame available to be read from the Enhanced RX FIFO, FlexCAN sets ERFSR[ERFDA]. Upon receiving the request, the DMA controller can read the message in the Enhanced RX FIFO output. Each message reading process must end by the address defined in ERFCR[DMALW].

Follow these rules for Enhanced RX FIFO DMA operation:

- Because a DMA transfer cannot be changed dynamically, program ERFCR[DMALW] so the enhanced RX FIFO element can store the largest CAN message present on the CAN bus.
- Data bytes are valid according to the DLC field. See Table 386.

CAN (FlexCAN)

CAN (FlexCAN)

Each time the DMA controller reads one message from the FIFO, FlexCAN clears ERFSR[ERFDA]. If there is at least one message stored in the FIFO, FlexCAN sets it again.

Consider an example where the maximum number of bytes in the data field of a CAN frame for a certain application is eight, and high-resolution timestamp is enabled. In that case, the last enhanced RX FIFO address offset can be found in Table 397 and Table 398. Using this address offset, ERFCR[DMALW] can be determined in this way:

- Maximum number of data bytes = 8.
- HR TIME STAMP enabled.
- Last address offset = TS\_OFF = 2014h.
- DMALW = 5.

## 50.3.8.3 Enhanced RX FIFO clear operation

When ERFCR[ERFEN] is 1, the CPU can clear the Enhanced RX FIFO by writing 1 to ERFSR[ERFCLR]. The clear operation resets the internal FIFO pointers, but the FIFO content stored in RAM is not changed. This operation can only be performed in Freeze mode; the module blocks the operation in other modes. This operation does not clear ERFSR[ERFUFW], ERFSR[ERFOVF], ERFSR[ERFDA], or ERFSR[ERFWMI]. The CPU must service all these fields before executing the clear FIFO operation.

## 50.3.9 Legacy RX FIFO

The Legacy RX FIFO is receive-only. To enable it, write 1 to MCR[RFEN]. To maintain software backward compatibility with previous versions of FlexCAN that did not have the Legacy FIFO feature, the reset value of this field is zero.

## CAUTION

Do not enable Legacy RX FIFO when the CAN FD feature is enabled.

The Legacy FIFO is six messages deep. The memory region the Legacy FIFO structure occupies (both message buffers and Legacy FIFO engine) is described in Legacy RX FIFO structure. The CPU can read the received messages sequentially, in the order they were received, by repeatedly reading a message buffer structure at the output of the Legacy FIFO.

IFLAG1[BUF5I] (Frames Available in Legacy RX FIFO) is set when at least one frame is available to be read from the Legacy FIFO. If the corresponding mask bit enables it, an interrupt is generated. Upon receiving the interrupt, the CPU can read the message (accessing the output of the Legacy FIFO as a message buffer) and Legacy RX FIFO Information (RXFIR), then clear the interrupt. If there are more messages in the Legacy FIFO, clearing the interrupt:

1. Updates the output of the Legacy FIFO with the next message.
2. Updates RXFIR with the attributes of that message.
3. Reissues the interrupt to the CPU.

Otherwise, the flag remains cleared. The output of the Legacy FIFO is valid only while IFLAG1[BUF5I] is set.

IFLAG1[BUF6I] (Legacy RX FIFO Warning) is set when the Legacy RX FIFO receives a new message that increases the number of unread messages to five from four. This change means that the Legacy RX FIFO is almost full. The flag remains set until the CPU clears it.

IFLAG1[BUF7I] (Legacy RX FIFO Overflow) is set when an incoming message is lost because the Legacy RX FIFO is full. The flag is not set when the Legacy RX FIFO is full and a message buffer captures the message. The flag remains set until the CPU clears it.

Clearing one of the three flags above does not affect the state of the other two.

If an IFLAG flag is set and the corresponding mask bit is 1, an interrupt is generated.

A powerful filtering scheme is provided to accept only frames intended for the target application, reducing the interrupt servicing workload. The filtering criteria are specified by programming a table of up to 128 32-bit registers, according to CTRL2[RFFN]. This table can be configured to one of the following formats (see also Legacy RX FIFO structure):

- Format A: 128 Identifier Acceptance Filters (IDAFs) - extended or standard IDs including IDE and RTR

- Format B: 256 IDAFs - standard IDs or extended 14-bit ID slices including IDE and RTR
- Format C: 512 IDAFs - standard or extended 8-bit ID slices)

## NOTE

A chosen format is applied to all entries of the filter table. It is not possible to mix formats within the table.

Every frame available in the Legacy RX FIFO has a corresponding Identifier Acceptance Filter Hit Indicator (IDHIT). The IDHIT can be read in the IDHIT field in the Control and Status word, as shown in the Legacy RX FIFO Structure description. The CPU can also obtain this information by accessing Legacy RX FIFO Information (RXFIR). RXFIR[IDHIT] refers to the message at the output of the Legacy FIFO, and is valid while IFLAG1[BUF5I] is set. RXFIR must be read only before clearing the flag, guaranteeing that the information refers to the correct frame within the Legacy FIFO.

The Individual Mask Registers (RXIMRn) individually affect up to 32 elements of the filter table, according to the value of CTRL2[RFFN]. This configuration allows very powerful filtering criteria to be defined. If MCR[IRMQ] is 0, the Legacy RX FIFO filter table is affected by Legacy RX FIFO Global Mask (RXFGMASK).

## NOTE

See Table 348 for information about the difference between FD and non-FD regarding this feature.

## 50.3.9.1 Legacy RX FIFO in DMA Operation

The receive-only Legacy FIFO can support DMA. To enable this feature, write 1 to both MCR[RFEN] and MCR[DMA]. To maintain backward compatibility with previous versions of the module that did not have the DMA feature, the reset value of MCR[DMA] is zero.

The DMA controller can read the received message by reading a message buffer structure at the Legacy FIFO output port in the 80h-8Ch address range.

## NOTE

FlexCAN supports 32-bit access only for DMA transfers.

When MCR[DMA] = 1, the CPU must not access the Legacy FIFO output port address range. Before writing 1 to MCR[DMA], the CPU must service the IFLAG flags set in the Legacy RX FIFO region. Otherwise, these flags may indicate that the FIFO has data to be serviced, and mistakenly generate a DMA request. Before writing 0 to MCR[DMA], the CPU must perform a clear Legacy FIFO operation.

When at least one frame available to be read from the FIFO, IFLAG1[BUF5I] (Frames available in Legacy RX FIFO) is set. A DMA request is generated simultaneously. Upon receiving the request, the DMA controller can read the message (accessing the output of the Legacy FIFO as a message buffer). The DMA reading process must end by reading address 8Ch. This read operation:

- Clears IFLAG1[BUF5I].
- Updates the FIFO output with the next message (if the FIFO is not empty).
- Updates Legacy RX FIFO Information (RXFIR) with the attributes of the new message.

If there are more messages stored in the FIFO, IFLAG1[BUF5I] is reasserted and another DMA request is issued. Otherwise, the flag remains cleared.

IFLAG1[BUF6I] and IFLAG1[BUF7I] are not used when the DMA feature is enabled.

When FlexCAN is working with DMA, the CPU does not receive any Legacy RX FIFO interruption and must not clear the related IFLAG flags. The related IMASK bits are not used to mask the generation of DMA requests.

## NOTE

See Table 348 for information about the difference between FD and non-FD regarding this feature.

CAN (FlexCAN)

## 50.3.9.2 Clear Legacy FIFO

When MCR[RFEN] = 1, you can use the clear Legacy FIFO operation to empty Legacy FIFO contents. When the CPU writes 1 to IFLAG1[BUF0I], the clear FIFO operation occurs. This operation can only be performed in Freeze mode; FlexCAN blocks it in other modes. This operation does not clear the FIFO IFLAG flags; the CPU must service all FIFO IFLAG flags before executing the clear FIFO operation.

When Legacy RX FIFO is working with DMA, the clear FIFO operation clears IFLAG1[BUF5I], and the DMA request is canceled.

## CAUTION

The clear Legacy FIFO operation does not clear IFLAG flags, except when MCR[DMA] = 1; in this case, only IFLAG1[BUF5I] is cleared.

## 50.3.10 CAN protocol-related features

This section describes features related to the CAN protocol.

## 50.3.10.1 CAN FD ISO compliance

The CAN FD protocol has been improved to increase the failure-detection capability that was in the original CAN FD protocol. This original protocol is also called non-ISO CAN FD, by CAN in Automation (CiA). A three-bit stuff counter and a parity bit have been introduced in the improved CAN FD protocol, now called ISO CAN FD. The CRC calculation has also been modified. All these improvements make the ISO CAN FD protocol incompatible with the non-ISO CAN FD protocol. FlexCAN still supports non-ISO CAN FD, so it can be used during an intermediate phase, for evaluation and development purposes.

It is recommended that you configure FlexCAN with the ISO CAN FD protocol by writing 1 to CTRL2[ISOCANFDEN].

## 50.3.10.2 CAN FD frames

ISO 11898-1:2015 specifies the Classical Frame format compliant to ISO 11898-1:2003 (2003) and introduces the CAN Flexible Data Rate Frame format (CAN FD). The Classical Frame format allows bit rates up to one Mbit/s and payloads up to eight bytes per frame. The Flexible Data Rate Frame format allows bit rates faster than one Mbit/s and payloads longer than eight bytes per frame. FlexCAN can receive and transmit CAN FD messages interleaved with Classical CAN messages.

There are additional control bits in the CAN FD frame:

- The Extended Data Length (EDL) bit enables a longer data payload with different data length coding.
- The Bit Rate Switch (BRS) bit decides whether the bit rate is switched inside a CAN FD format frame.
- The Error State Indicator (ESI) flag is transmitted dominant by error active nodes, and recessive by error passive nodes.

There are no Remote Frames (see Remote frames) in the CAN FD format. A message configured to transmit a Remote Frame is always sent out in Classical CAN format. When an FD frame is received and matches a message buffer, the RTR bit in the receiving message buffer becomes 0. The RTR bit must be considered in classical frames only.

CAN FD messages may be formatted as long frames where the data field exceeds eight bytes, and may range from 12 up to 64 bytes. They can also be configured to support bit rate switching. In this case, the control field, data field, and CRC field of a CAN frame are transmitted with a higher bit rate than the beginning and end of the frame. Messages in Classical CAN format are limited to transport a maximum payload of eight bytes at nominal rate. Figure 459 illustrates the message formats for Classical and FD frames with either standard or extended ID.

CAN (FlexCAN)

CAN (FlexCAN)

<!-- image -->

MCR[FDEN] enables the ability to receive and transmit CAN FD messages. A recessive R0 bit in CAN frames with 11-bit identifiers, or a recessive R1 bit in CAN frames with 29-bit identifiers, is decoded as an EDL bit (not a reserved one). A recessive EDL bit identifies a CAN FD frame, and a dominant EDL bit identifies a Classical CAN frame. The BRS bit specifies whether this frame switches the bit rate in its data phase. A long frame is decoded according to the DLC field value (see DLC definition in Message buffer structure).

CAN FD messages can be transmitted with two different bit rates. The first part of a CAN FD frame, from the Start of Frame (SOF) bit until the Bit Rate Switch (BRS) bit is called the arbitration phase. This part is transmitted with the nominal bit rate based on a set of nominal CAN bit timing configuration values. The second part, from the BRS bit until the CRC Delimiter bit, is called the data phase. When this second part is transmitted, a second set of CAN data bit timing configuration values determines the data bit rate. Finally, from the CRC delimiter until the Intermission bits, the transmission returns to nominal bit rate.

In CAN FD frames with bit rate switching, the bit timing changes inside the frame at the sample point of the BRS bit if this bit is recessive. Before the BRS bit, in the CAN FD arbitration phase, the nominal CAN bit timing is used as defined by CAN Bit Timing (CBT). (Control 1 (CTRL1) also defines this timing for backward compatibility.) Upon detecting a recessive BRS bit, the CAN data bit timing is used as defined by CAN FD Bit Timing (FDCBT).

## NOTE

If the time quantum length in nominal bit timing and in the data bit timing are not identical, a quantization error of up to one time quantum of the arbitration phase may be present as a phase error. This situation can occur after the switch from arbitration to data phase, and it lasts until the next synchronization event. The length of the time quantum should be the same in nominal and data bit timing. This configuration minimizes the chance of error frames on the CAN bus, and optimizes the clock tolerance in networks that use FD frames.

If BRS = 1 in the selected TX MB, FDCTRL[FDRATE] enables the transmission of all frames with bit rate switching. If FDCTRL[FDRATE] = 0, the transmission is performed at nominal rate regardless of the BRS bit value. FDCTRL[FDRATE] can be written at any time but takes effect only for the next message transmitted or received.

Nominal bit timing is resumed at the sample point of the CRC Delimiter bit or when an error is detected, whichever occurs first. Figure 460 describes the mechanism for entering and leaving the data phase when the BRS bit is recessive.

<!-- image -->

## NOTE

In Classical CAN frames, the CRC delimiter is one recessive bit. In CAN FD frames, the CRC delimiter may consist of one or two recessive bits. FlexCAN sends only one recessive bit as the CRC delimiter. It accepts two recessive bits before the edge from recessive to dominant that starts the acknowledge slot. As a receiver, FlexCAN sends its acknowledge bit after the first CRC delimiter bit. In CAN FD frames, FlexCAN accepts a two-bit dominant ACK slot as a valid ACK to compensate for phase shifts between the receivers.

The maximum configurable bit rate in the CAN FD data phase depends on the clock frequency of the CAN\_PE subblock. For example, for a CAN\_PE clock frequency of 40 MHz and the shortest configurable bit time of 5 time quanta, the bit rate in the data phase is 8 Mbit/s.

## NOTE

The frequency used in this example may not be supported on this chip. It is shown only to demonstrate how the maximum configurable bit rate is calculated.

The value of the ESI bit is determined:

- By the error state of the transmitter at the start of the transmission, if the frame is originated in the FlexCAN node,
- Or by the original transmitting node when FlexCAN is acting as a gateway for the message.

If the transmitter is error-passive, ESI is transmitted recessive; otherwise, it is transmitted dominant. The permutations of the relationship between the written value and the transmitted value of the ESI are shown in Table 359.

Table 359. Written versus transmitted values of ESI field

| FlexCAN fault confinement status at start of frame   |   ESI bit of TX MB | Transmitted ESI   |
|------------------------------------------------------|--------------------|-------------------|
| Error active                                         |                  0 | 0 (Error Active)  |
| Error passive                                        |                  0 | 1 (Error Passive) |
| Error active                                         |                  1 | 1 (Error Passive) |
| Error passive                                        |                  1 | 1 (Error Passive) |

Different CAN frame formats have different CRC polynomials. The first polynomial, CRC\_15, is used for all frames in Classical CAN format. The second, CRC\_17, is used for frames in CAN FD format with a data field up to sixteen bytes long. The third, CRC\_21, is used for frames in CAN FD format with a data field longer than sixteen bytes. Each polynomial results in a Hamming distance of 6. At the start of the frame, all three CRC polynomials are calculated concurrently. The values of the EDL bit and the DLC field select the CRC sequence to be transmitted. When receiving a message, FlexCAN decodes EDL and DLC to select the adequate CRC polynomial to check for a CRC error.

In CAN FD format frames, stuff bits are included in the bit stream for CRC calculation. In Classical CAN format frames, stuff bits are not included. After the transmission of the last bit relevant to the CRC calculation, CAN FD CRC (FDCRC) stores the calculated CRC for the transmitted message. This storage is performed with adequate length for the type of message, for CAN FD and non-FD messages. Cyclic Redundancy Check (CRCR) reports a valid CRC for Classical CAN messages only.

In CAN FD format frames, the CAN bit stuffing method changes for the CRC sequence, so the stuff bits are inserted at fixed positions. When FlexCAN is transmitting a CAN FD frame, a fixed stuff bit is inserted just before the first bit of the CRC sequence. This insertion occurs even if the last bits of the preceding field do not fulfill the CAN stuff condition. Additional stuff bits are inserted after each fourth bit of the CRC sequence. The value of any fixed stuff bit is the inverse value of its preceding bit. When FlexCAN receives a CAN FD frame, it discards the fixed stuff bits from the bit stream for the CRC check. A stuff error is detected if the fixed stuff bit has the same value as its preceding bit.

FlexCAN detects errors in CAN FD frames the same way as in Classical CAN frames. The error counters ECR[RXERRCNT] and ECR[TXERRCNT] accumulate the counts of RX and TX errors, respectively, for both FD and non-FD frames indiscriminately. Two extra error counters, ECR[RXERRCNT\_FAST] and ECR[TXERRCNT\_FAST], accumulate RX and TX errors occurring in the data phase of CAN FD frames with BRS = 1 only. The rules for updating the error counters are the same for both CAN FD and non-FD frames (see Error Counter (ECR)).

These error flags report errors in both CAN FD and non-FD frames:

- ESR1[BIT1ERR]
- ESR1[BIT0ERR]
- ESR1[ACKERR]
- ESR1[CRCERR]
- ESR1[FRMERR]
- ESR1[STFERR]

If CTRL1[ERRMSK] = 1, they also generate the ERRINT interrupt.

These additional error flags indicate the occurrence of errors in the data phase of CAN FD frames with BRS = 1:

- ESR1[BIT1ERR\_FAST]
- ESR1[BIT0ERR\_FAST]
- ESR1[CRCERR\_FAST]
- ESR1[FRMERR\_FAST]
- ESR1[STFERR\_FAST]

No ACKERR is detected in the data phase of a CAN FD frame. Fault confinement status reported in ESR1[FLTCONF] is the same for both CAN FD and Classical CAN frames, and is based on ECR[RXERRCNT] and ECR[TXERRCNT] only. Information in ECR[RXERRCNT\_FAST] and ECR[TXERRCNT\_FAST] may be considered as status to help detect the error nature related to the bit rate value.

When FlexCAN detects an error while transmitting or receiving a CAN FD message in the data phase, it immediately switches:

- Back to the arbitration phase, and
- Back to the nominal rate to start an error flag.

Resynchronization and hard synchronization occur in CAN FD frames in the same way as in Classical CAN ones. A hard synchronization is also performed at the recessive-to-dominant edge from EDL to R0 in CAN FD format frames. FlexCAN does not resynchronize while transmitting in the CAN FD data phase.

## 50.3.10.3 Transceiver delay compensation

The CAN FD protocol allows the transmission and reception of data at a higher bit rate than the nominal rate used in the arbitration phase, when BRS = 1 in the message. This feature enables the use of rates up to 8 Mbit/s.

During the data phase of a CAN FD frame, if the transmitter cannot receive its own latest transmitted bit at the sample point of that bit, it detects a bit error. When bit rate switching is enabled (BRS = 1), the CAN bit time in the data phase can become shorter than the loop delay of the transceiver. This condition impedes the correct comparison between the transmitted bit and the received bit within the current CAN bit time interval.

The transceiver delay compensation (TDC) process defines a secondary sample point where the transmitted bit is correctly compared to the received bit to check for bit errors.

You can enable the TDC mechanism via FDCTRL[TDCEN] or ETDC[ETDCEN]. It is effective only during the data phase of FD frames with BRS = 1. It has no effect either on non-FD frames, or on FD frames transmitted at the normal bit rate. When the transmitted message has BRS = 1, TDC is active from the sample point of the BRS bit until the sample point of the CRC Delimiter bit. When TDC is active, the real received bit is compared to the delayed transmitted bit, where the delay is calculated based on the measured transceiver loop delay.

## NOTE

The transmitters using TDC disregard value of the CRC Delimiter bit. A global error at the end of the CRC field causes the receivers to send error frames that the transmitter detects during Acknowledge or End of Frame.

CAN (FlexCAN)

CAN (FlexCAN)

For every transmitted FD frame with BRS = 1, the transition from the recessive EDL bit to the dominant R0 bit triggers the delay measurement (as shown in Figure 461). The loop delay is measured in Protocol Engine (PE) clock periods (CANCLK, see Protocol timing), from the transmitted EDL-R0 edge to the received EDL-R0 edge. The measured loop delay time added to an offset value specified in FDCTRL[TDCOFF] or ETDC[ETDCOFF] determines the position of the secondary sample point. FDCTRL[TDCVAL] or ETDC[ETDCVAL] stores the result of this calculation. The TDCVAL and ETDCVAL value saturates at its maximum value of 63 CANCLK and 255 CANCLK when the delay measurement is too long.

<!-- image -->

The measured loop delay is not enough to define the secondary sample point, because it relates to the CAN bit edges. The transceiver delay compensation offset FDCTRL[TDCOFF] or ETDC[ETDCOFF] is used to shift the secondary sample point to an intermediate point inside the bit time, far away from its edges. The value of FDCTRL[TDCOFF] or ETDC[ETDCOFF] cannot be larger than the CAN bit duration in the data phase.

If the secondary sample point is set very near the CAN bit edge (SYNC field), problems may occur during the bit sampling in the data phase. For the TDC to work reliably, the offset must use optimal settings. To ensure that bit sampling is performed in the best region, configure the TDC offset as shown in this equation:

```
Offset = ( FPSEG1 + FPROPSEG + 2)  ( FPRESDIV + 1) or
```

```
Offset = ( DTSEG1 + 2)  ( EDPRESDIV + 1), if ETDCEN
```

Figure 462 shows the SSP position when these settings are used.

<!-- image -->

Alternatively, if CTRL2[BTE] and ETDC[ETDCEN] are 1, you can write 1 to ETDC[TDMDIS] to disable the transceiver delay measurement. In this case, only ETDC[ETDCOFF] defines the SSP position. Figure 463 shows the secondary sample point position when the transceiver delay measurement is disabled.

CAN (FlexCAN)

<!-- image -->

During the data phase of CAN FD frames with bit rate switching enabled, at the onset of every TX CAN bit:

- The transmitted TX bit value is temporarily stored in a buffer.
- A time countdown based on FDCTRL[TDCVAL] or ETDC[ETDCVAL] is started. This countdown ends with the comparison of the received RX bit (delayed by the external loop delay plus the specified offset) to the stored TX bit.

If a bit error is detected at the secondary sample point, FlexCAN issues an error flag to the CAN bus at the next sample point.

During the arbitration phase, delay compensation is always disabled. During the data phase, the TDC mechanism of FlexCAN can compensate a maximum delay of 3 CAN bit times - 2 Tq. Beyond this limit, the FDCTRL[TDCFAIL] or ETDC[ETDCFAIL] flag is set. The flag indicates when the TDC mechanism is out of range and is unable to compensate the transceiver loop delay.

## 50.3.10.4 Remote frames

A remote frame is a special type of frame. You can program a message buffer to be a remote request frame by configuring the message buffer as Transmit with the RTR = 1. After the remote request frame is transmitted successfully, the message buffer becomes a receive message buffer, with the same ID as before.

When FlexCAN receives a remote request frame, the frame can be treated in different ways, depending on remote request storing (CTRL2[RRS]) and RX FIFO Enable (MCR[RFEN]):

- If RRS = 0 the ID of the frame is compared to the IDs of the transmit message buffers with the CODE field 1010b. If a matching ID exists, this message buffer frame is transmitted. If the matching message buffer has the RTR = 1, FlexCAN transmits a remote frame as a response. The received remote request frame is not stored in a receive buffer. It is only used to trigger a transmission of a frame in response.

The mask registers are not used in remote frame matching, and all ID bits (except RTR) of the incoming received frame should match. If a remote request frame is received and matches a message buffer, this message buffer immediately enters the internal arbitration process. However, it is considered a normal TX message buffer, with no higher priority. The data length of this frame is independent of the DLC field in the remote frame that initiated its transmission.

- If CTRL2[RRS] = 1, the ID of the frame is compared to the IDs of the receive message buffers with the CODE field 0100b, 0010b, or 0110b. If a matching ID exists, this message buffer stores the remote frame in the same fashion as a data frame. No automatic remote response frame is generated. The mask registers are used in the matching process.
- If MCR[RFEN] = 1, FlexCAN does not generate an automatic response for remote request frames that match the Legacy FIFO filtering criteria. If the remote frame matches one of the target IDs, it is stored in the Legacy FIFO and presented to the CPU.

For filtering formats A and B, it is possible to select whether remote frames are accepted or not. For format C, remote frames are always accepted if they match the ID. Remote request frames are considered as normal frames. They generate a Legacy FIFO overflow when a successful reception occurs and the Legacy FIFO is already full.

- If ERFCR[ERFEN] = 1, FlexCAN does not generate an automatic response for remote request frames that match the Enhanced RX FIFO filtering criteria. Remote Request Frames are considered normal frames. They generate an Enhanced RX FIFO overflow when a successful reception occurs and the enhanced RX FIFO is already full.

## NOTE

There is no remote frame in the CAN FD format. A fixed dominant RRS bit replaces the RTR bit. FlexCAN receives and transmits remote frames in the Classical CAN format.

## 50.3.10.5 Overload frames

When a dominant bit is detected on the CAN bus in these locations, FlexCAN transmits overload frames:

- The first or second bit of Intermission.
- The seventh bit (last) of End of Frame field (RX frames).
- The eighth bit (last) of Error Frame Delimiter or Overload Frame Delimiter.

## 50.3.10.6 Message buffer timestamp

The value of the free-running timer is sampled at the beginning of the Identifier field on the CAN bus. This value is stored at the end of move-in in the TIME STAMP field of a message buffer, providing network behavior regarding time.

When CTRL2[TIMER\_SRC] = 1, an external time tick continuously clocks the free-running timer.

When CTRL2[TIMER\_SRC] = 0, the FlexCAN bit clock clocks the free-running timer, which defines the baud rate on the CAN bus. During a message transmission or reception, it increments by one for each bit that is received or transmitted. When there is no message on the bus, it counts using the previously programmed baud rate.

The free-running timer is not incremented during Disable and Freeze modes. It can be reset upon a specific frame reception, enabling network time synchronization. See CTRL1[TSYN].

Alternatively, by configuring CTRL2[MBTSBASE], the timestamp of the message buffer can capture the lower or higher 16 bits of the high-resolution dedicated counter.

## 50.3.10.7 High-resolution timestamp

The high-resolution timestamp, HR\_TIME\_STAMP, uses a dedicated timer with a 32-bit counter operating in free-running mode. CTRL2[TSTAMPCAP] enables the high-resolution timestamp. When this field is not zero, the dedicated 32-bit counter value is captured during a valid CAN frame and stored in an HR\_TIME\_STAMPn register.

Each HR\_TIME\_STAMPn corresponds to a specific message buffer. For example, HR\_TIME\_STAMP0 stores the 32-bit timestamp associated with message buffer 0. HR\_TIME\_STAMP1 stores the 32-bit timestamp associated with message buffer 1, and so on.

The counter value is captured according to CTRL2[TSTAMPCAP]. For classical CAN frames, the capture points can be the start of frame bit or the point in time a CAN frame is considered valid. This valid point is the seventh bit of end of frame for transmission and the sixth bit of end of frame for reception.

For CAN FD frames, the capture points can be:

- The start of frame
- The point in time a CAN FD frame is considered valid
- The res bit of a CAN FD frame

The 16-bit timestamp of the message buffer can be configured to capture the lower or higher 16 bits of the high-resolution timer. This configuration is made by CTRL2[MBTSBASE].

## 50.3.10.8 Protocol timing

Figure 464 shows the structure of the clock generation circuitry that feeds the CAN Protocol Engine (PE) submodule .

## NOTE

To identify the proper clock source, see the clock distribution chapter (module clocks table).

CANCLK

Sclock

(Tq)

Prescaler

Oscillator clock

Figure 464. CAN engine clocking scheme

FlexCAN supports various means to configure bit timing parameters required by the CAN protocol. Control 1 (CTRL1) has various fields to control bit timing parameters:

- CTRL1[PRESDIV]
- CTRL1[PROPSEG]
- CTRL1[PSEG1]
- CTRL1[PSEG2]
- CTRL1[RJW]

CAN Bit Timing (CBT) extends the range of the CAN bit timing variables in CTRL1. Enhanced Data Phase CAN Bit Timing (EDCBT) provides a second set of CAN bit timing variables to be applied at the data phase of CAN FD frames with the Bit Rate Switch (BRS) = 1.

Enhanced Nominal CAN Bit Timing (ENCBT) extends the range of CAN bit timing variables in CBT. Enhanced Nominal CAN Bit Timing (ENCBT) extends the range of CAN bit timing variables in FDCBT. When using ENCBT and EDCBT, you must program the nominal bit timing and data phase serial clock (Sclock) dividers in Enhanced CAN Bit Timing Prescalers (EPRS).

## NOTE

When the CAN FD feature is enabled, always write 1 to CBT[BTF] or CTRL2[BTE] and specify the CAN bit timing variables in CBT or ENCBT. See CAN Bit Timing (CBT) or Enhanced Nominal CAN Bit Timing (ENCBT).

CTRL1[PRESDIV] (and its extended range CBT[EPRESDIV] (or EPRS[ENPRESDIV]) and FDCBT[FPRESDIV] (or EPRS[EDPRESDIV]) for the data phase bits of CAN FD messages) defines the prescaler value that generates the serial clock (Sclock). (See the equation below.) The period of Sclock defines the time quantum used to compose the CAN waveform. A time quantum (Tq) is the atomic unit of time managed by the CAN engine. It is the smallest time unit for all configuration values.

<!-- formula-not-decoded -->

## Equation 16. Time quantum

The bit rate, which defines the rate the CAN message is received or transmitted, is calculated with the formula:

CAN bit time = ( Number of time quanta in 1 bit time )  Tq

<!-- formula-not-decoded -->

## Equation 17. CAN bit time and baud rate

A bit time is subdivided into three segments as shown in Figure 465. See also Figure 466, Figure 467, and Table 360.

## NOTE

For further explanation of the underlying concepts, see ISO 11898-1:2015. See also the CAN 2.0A/B protocol specification for bit timing.

CAN (FlexCAN)

<!-- image -->

The three segments are:

- SYNC\_SEG. This segment has a fixed length of one time quantum. Signal edges are expected to occur within this section.
- Time Segment 1. This segment includes the propagation segment and the phase segment 1 of the CAN standard.

It can be programmed by configuring CTRL1[PROPSEG] and CTRL1[PSEG1] so that the sum (plus 2) is 2 to 16 time quanta. When CBT[BTF] = 1, FlexCAN uses CBT[EPROPSEG] and CBT[EPSEG1] so that the sum (plus 2) is 2 to 96 time quanta. For messages in CAN FD format with the BRS = 1, FlexCAN uses FDCBT[FPROPSEG] and FDCBT[FPSEG1] so that the sum (plus 1) is 2 to 39 time quanta.

If CTRL2[BTE] = 1, FlexCAN uses ENCBT[NTSEG1] to configure time segment 1 to 2 to 256 time quanta. For the data phase in CAN FD messages with BRS = 1, EDCBT[DTSEG1] must be used for configuring time segment 1 to 2 to 32 time quanta.

- Time Segment 2. This segment represents the phase segment 2 of the CAN standard.

It can be programmed by configuring CTRL1[PSEG2] (plus 1) to be 2 to 8 time quanta. When CBT[BTF] = 1, FlexCAN uses CBT[EPSEG2] so that its value (plus 1) is 2 to 32 time quanta. For messages in CAN FD format with the BRS = 1, FlexCAN

CAN (FlexCAN)

uses FDCBT[FPSEG2] instead, so that its value (plus 1) is 2 to 8 time quanta. Time segment 2 cannot be smaller than the Information Processing Time (IPT), which is 2 time quanta in FlexCAN.

If CTRL2[BTE] = 1, FlexCAN uses ENCBT[NTSEG2] to configure time segment 2 to 2 to 128 time quanta. For the data phase in CAN FD messages with BRS = 1, EDCBT[DTSEG2] must configure time segment 2 to 2 to 16 time quanta.

## NOTE

The bit time defined by the above time segments must not be smaller than five time quanta. For bit time calculations, use an Information Processing Time (IPT) of two, which is the value implemented in the FlexCAN module.

Figure 466. Segments within the bit time (example using CTRL1 bit timing variables for Classical CAN format)

<!-- image -->

Figure 467. Segments within the bit time (example using CBT and FDCBT bit timing variables for CAN FD format)

<!-- image -->

Table 360. Time segment syntax

| Syntax         | Description                                                                                                                                   |
|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| SYNC_SEG       | Period during which the system expects transitions to occur on the bus                                                                        |
| TSEG1          | Period corresponding to the sum of PROPSEG and PSEG1.                                                                                         |
| TSEG2          | Period corresponding to the PSEG2 value.                                                                                                      |
| Transmit point | Point at which a node in Transmit mode transfers a new value to the CAN bus                                                                   |
| Sample point   | Point at which a node samples the bus. If the option of three samples per bit is selected, this point marks the position of the third sample. |

Table 361 gives some examples of the CAN compliant segment settings for Classical CAN format (Bosch CAN 2.0B) (non-FD) messages.

Table 361. Bosch CAN 2.0B standard compliant bit time segment settings

| Time segment 1   |   Time segment 2 | Resynchronization jump width   |
|------------------|------------------|--------------------------------|
| 5 to 10          |                2 | 1 to 2                         |
| 4 to 11          |                3 | 1 to 3                         |
| 5 to 12          |                4 | 1 to 4                         |
| 6 to 13          |                5 | 1 to 4                         |
| 7 to 14          |                6 | 1 to 4                         |
| 8 to 15          |                7 | 1 to 4                         |
| 9 to 16          |                8 | 1 to 4                         |

## NOTE

You must ensure the bit time settings comply with the CAN Protocol standard (ISO 11898-1:2015).

A CAN bit can be used as a measure of duration (for example, estimating the occurrence of a CAN bit event in a message). When a CAN bit is used in this way, the number of peripheral clocks in one CAN bit (NumClkBit) can be calculated as:

<!-- formula-not-decoded -->

## Equation 18. Number of peripheral clocks per CAN bit when CTRL2[BTE] = 0

## Or, if CTRL2[BTE] = 1:

<!-- formula-not-decoded -->

## Equation 19. Number of peripheral clocks per CAN bit when CTRL2[BTE] = 1

## Where:

- NumClkBit is the number of peripheral clocks in one CAN bit.
- f CANCLK is the Protocol Engine (PE) Clock (see Figure 464), in Hz.
- f SYS is the frequency of operation of the system (CHI) clock, in Hz.
- PSEG1 is the value of CTRL1[PSEG1].
- PSEG2 is the value of CTRL1[PSEG2].
- PROPSEG is the value of CTRL1[PROPSEG].
- PRESDIV is the value in CTRL1[PRESDIV].
- ENPRESDIV is the value of EPRS[ENPRESDIV].
- NTSEG1 is the value of ENCBT[NTSEG1].
- NTSEG2 is the value of ENCBT[NTSEG2].

The formula above is also applicable to the alternative CAN bit timing variables described in:

- CAN Bit Timing (CBT)
- Enhanced Nominal CAN Bit Timing (ENCBT)
- CAN FD Bit Timing (FDCBT)

CAN (FlexCAN)

- Enhanced Nominal CAN Bit Timing (ENCBT)

For example, 180 CAN bits = (180  NumClkBit) peripheral clock periods.

## 50.3.10.9 Arbitration and matching timing

During normal reception and transmission, the matching, arbitration, move-in, and move-out processes are executed during certain time windows inside the CAN frame. These windows are shown in the following figures.

<!-- image -->

## NOTE

In these figures, the matching and arbitration timing do not consider delays caused by concurrent memory access due to the CPU or other internal FlexCAN subblocks.

## 50.3.10.10 TX arbitration start delay

CTRL2[TASD] (TX Arbitration Start Delay) indicates the number of CAN bits that FlexCAN uses to delay the TX arbitration process starting point from the first bit of the CRC field of the current frame. This variable can be written only in Freeze mode; FlexCAN blocks it in other modes.

The ability of the CPU to reconfigure message buffers for transmission after the end of the internal arbitration process impacts transmission performance. In the arbitration process, FlexCAN finds the winner MB for transmission (see Arbitration process). If the arbitration ends too early before the first bit of Intermission field, the CPU may reconfigure some TX message buffers. It is possible that the winning message buffer is no longer the best candidate to be transmitted.

CAN (FlexCAN)

TASD can optimize the transmission performance by defining the arbitration start point, as shown in Figure 471, based on factors such as:

- Peripheral-to-oscillator clock ratio
- CAN bit timing variables that determine the CAN bit rate
- Number of message buffers in use by the matching and arbitration processes

<!-- image -->

The duration of an arbitration process, in terms of CAN bits, is:

- Directly proportional to the number of available message buffers
- Directly proportional to the CAN bit rate
- Inversely proportional to the peripheral clock frequency.

The optimal arbitration timing occurs when the last message buffer is scanned immediately before the first bit of the Intermission field of a CAN frame. For instance, if:

- There are few message buffers,
- The peripheral-to-oscillator clock ratio is high,
- And the CAN baud rate is low,

Then the arbitration can be placed closer to the end of the frame, adding more delay to its starting point, and vice versa.

If CTRL2[TASD] = 0, the arbitration start is not delayed, and more time is reserved for arbitration. Alternatively, if CTRL2[TASD] is close to 24, the CPU can configure a TX message buffer later, and less time is reserved for arbitration. If too little time is reserved for arbitration, FlexCAN may not be able to find a winner MB in time. The transmitted arbitration winner may not have the best chance to win the bus arbitration against external nodes on the CAN bus.

The optimal TASD value can be calculated as follows:

## Equation 20. Optimal value for TASD

## Where:

For CAN FD frames and (MAXMB + 1)  NMBEND

<!-- formula-not-decoded -->

For CAN FD frames and (MAXMB + 1) &gt; NMBEND

<!-- formula-not-decoded -->

For non-FD frames

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

## Equation 21. Variables used in TASD calculation

- MAXMB is the value in MCR[MAXMB].
- NMBEND is the number of message buffers that the arbitration process can scan during the last nine CAN bits at the end of a frame. (See the figure above.)
- BITRATEN is the CAN bit rate in bits per second calculated by the nominal CAN bit time variables.
- BITRATEF is the CAN bit rate in bits per second calculated by the data CAN bit time variables.
- CPCBN is the number of peripheral clocks per CAN bit in nominal bit rate for CAN FD frames.
- CPCBF is the number of peripheral clocks per CAN bit in data bit rate for CAN FD frames.
- CPCB is the number of peripheral clocks per CAN bit for non-FD frames.
- f CANCLK is the oscillator clock, in Hz.
- f SYS is the peripheral clock, in Hz.
- EPSEG1 is the value in CBT[EPSEG1] (CTRL1[PSEG1] can also be used).
- EPSEG2 is the value in CBT[EPSEG2] (CTRL1[PSEG2] can also be used).
- EPROPSEG is the value in CBT[EPROPSEG] (CTRL1[PROPSEG] can also be used).
- EPRESDIV is the value in CBT[EPRESDIV] (CTRL1[PRESDIV] can also be used).
- FPSEG1 is the value in FDCBT[FPSEG1].

CAN (FlexCAN)

- FPSEG2 is the value in FDCBT[FPSEG2].
- FPROPSEG is the value in FDCBT[FPROPSEG].
- FPRESDIV is the value in FDCBT[FPRESDIV].
- NTSEG1 is the value in ENCBT[NTSEG1].
- NTSEG2 is the value in ENCBT[NTSEG2].
- ENPRESDIV is the value in EPRS[ENPRESDIV].
- DTSEG1 is the value in EDCBT[DTSEG1].
- DTSEG2 is the value in EDCBT[DTSEG2].
- EDPRESDIV is the value in EPRS[EDPRESDIV].

## If CTRL2[BTE] = 1, then:

<!-- formula-not-decoded -->

## Equation 22. Nominal baud rate when CTRL2[BTE] = 1

<!-- formula-not-decoded -->

## Equation 23. Fast baud rate when CTRL2[BTE] = 1

See also Protocol timing for more details.

The following tables show the TASD value calculated for some configuration cases.

## Case 1:

- Clock ratio = 2:1 (for example, peripheral clock 80 MHz and oscillator clock 40 MHz)
- Bit rate in arbitration phase = 1 Mbaud

## Table 362. TASD values in Case 1

|   Number of message buffers |   TASD value | Maximum bit rate in data phase (MBd)   |
|-----------------------------|--------------|----------------------------------------|
|                          16 |           24 | Invalid                                |
|                          32 |           24 | 8.0                                    |
|                          64 |           23 | 8.0                                    |
|                          96 |           22 | 8.0                                    |
|                         100 |           22 | 8.0                                    |
|                         128 |           21 | 3.6                                    |

## Case 2:

- Clock ratio = 1:1 (for example, peripheral clock 40 MHz and oscillator clock 40 MHz)
- Bit rate in arbitration phase = 1 Mbaud

CAN (FlexCAN)

Table 363. TASD values in Case 2

|   Number of message buffers |   TASD value | Maximum bit rate in data phase (MBd)   |
|-----------------------------|--------------|----------------------------------------|
|                          16 |           24 | Invalid                                |
|                          32 |           23 | 6.67                                   |
|                          54 |           22 | 5.0                                    |
|                          64 |           21 | 3.33                                   |
|                          96 |           20 | 1.6                                    |
|                         128 |           18 | 1.05                                   |

## Case 3:

- Clock ratio = 2:1 (for example, peripheral clock 40 MHz and oscillator clock 20 MHz)
- Bit rate in arbitration phase = 1 Mbaud

## Table 364. TASD values in Case 3

|   Number of message buffers |   TASD value | Maximum bit rate in data phase (MBd)   |
|-----------------------------|--------------|----------------------------------------|
|                          16 |           24 | Invalid                                |
|                          32 |           23 | 4.0                                    |
|                          54 |           22 | 4.0                                    |
|                          64 |           21 | 3.33                                   |
|                          96 |           20 | 1.54                                   |
|                         128 |           18 | 1.05                                   |

## 50.3.11 Clocks

The following table describes the clock sources for FlexCAN. See the chip clocking chapter for clock setting, configuration, and gating information.

Table 365. FlexCAN clocks

| Clock name                                          | Description                        |
|-----------------------------------------------------|------------------------------------|
| MODULE_CLK (system_clk)                             | Peripheral clock                   |
| MODULE_CLK_CHI (host_clock)                         | Control Host Interface (CHI) clock |
| MODULE_CLK_PE (protocol_engine_clock)               | Protocol Engine (PE) clock         |
| MODULE_CLK_PE_NOGATE (protocol_engine_clock_nogate) | Protocol Engine clock (no gating)  |
| MODULE_CLK_S (system_clock_nogate)                  | Peripheral access clock            |

## 50.3.11.1 Clock domains and restrictions

FlexCAN has two clock domains asynchronous to each other:

- The bus domain feeds the Control Host Interface (CHI) submodule.

- The oscillator domain feeds the CAN Protocol Engine (PE) submodule.

When the two domains are connected to clocks with different frequencies or phases, the frequency relationship between the two clock domains is restricted. In asynchronous operation, the bus domain clock frequency must always be greater than the oscillator domain clock frequency.

## NOTE

Asynchronous operation with a 1:1 ratio between peripheral and oscillator clocks is not allowed.

When performing matching and arbitration, FlexCAN must scan the whole message buffer memory during the time slot of one CAN frame, comprised of a number of CAN bits. To provide sufficient time for the scan, observe the following requirements:

- The peripheral clock frequency cannot be less than the oscillator clock frequency.
- There must be a minimum number of peripheral clocks per CAN bit, as specified in Table 366.

Table 366. Minimum number of peripheral clocks per CAN bit for Classical CAN format

|   Number of message buffers |   Value of MCR[RFEN] |   Value of ERFCR[ERFEN] |   Minimum number of peripheral clocks per CAN bit |
|-----------------------------|----------------------|-------------------------|---------------------------------------------------|
|                          16 |                    0 |                       0 |                                                16 |
|                          32 |                    0 |                       0 |                                                16 |
|                          64 |                    0 |                       0 |                                                25 |
|                          96 |                    0 |                       0 |                                                37 |
|                         128 |                    0 |                       0 |                                                49 |
|                          16 |                    1 |                       0 |                                                16 |
|                          32 |                    1 |                       0 |                                                17 |
|                          64 |                    1 |                       0 |                                                30 |
|                          96 |                    1 |                       0 |                                                42 |
|                         128 |                    1 |                       0 |                                                54 |
|                          16 |                    0 |                       1 |                                                16 |
|                          32 |                    0 |                       1 |                                                19 |
|                          64 |                    0 |                       1 |                                                31 |
|                          96 |                    0 |                       1 |                                                42 |
|                         128 |                    0 |                       1 |                                                55 |

For classical frame format, the minimum number of peripheral clocks per CAN bit specified in Table 366 determines the minimum peripheral clock frequency for a given number of message buffers and for an expected CAN bit rate. The CAN bit rate depends on the number of time quanta in a CAN bit. This number can be defined by adjusting one or more of the bit timing values contained in Control 1 (CTRL1) or CAN Bit Timing (CBT) or Enhanced Nominal CAN Bit Timing (ENCBT). The time quantum (Tq) is defined in Protocol timing. The minimum number of time quanta per CAN bit must be eight, so the oscillator clock frequency should be at least eight times the CAN bit rate.

For CAN FD frame format, some constraints must be satisfied. The equation below calculates the number of peripheral clocks per CAN bit in nominal bit rate (NumClkNomBit).

CAN (FlexCAN)

<!-- formula-not-decoded -->

Where PRESDIV, PSEG1, and PSEG2 are CAN bit time values in Control 1 (CTRL1). Alternatively, EPRESDIV, EPSEG1, and EPSEG2 values in CAN Bit Timing (CBT) or the values of EPRS[ENPRESDIV], ENCBT[NTSEG1], and ENCBT[NTSEG2] can be used instead. NumClkNomBit can also be calculated as a function of the expected nominal bit rate used in the arbitration phase (NomBitRate), as shown in the equation above.

The number of CAN bits in the data phase of an FD frame with BRS = 1 (fast CAN bits) depends on the number of data bytes in the payload. The number of fast CAN bits (NumOfFastBits) can be determined in Table 367. Having fewer data bytes means having fewer fast CAN bits. It also means that less time is available for FlexCAN to scan the whole message buffer memory during the internal matching and arbitration processes.

Table 367. Number of fast CAN bits in a CAN FD frame

|   Minimum number of data bytes | DLC field   |   NumOfFastBits |
|--------------------------------|-------------|-----------------|
|                              0 | 0h          |              21 |
|                              1 | 1h          |              29 |
|                              2 | 2h          |              37 |
|                              3 | 3h          |              45 |
|                              4 | 4h          |              53 |
|                              5 | 5h          |              61 |
|                              6 | 6h          |              69 |
|                              7 | 7h          |              77 |
|                              8 | 8h          |              85 |
|                             12 | 9h          |             117 |
|                             16 | Ah          |             149 |
|                             20 | Bh          |             186 |
|                             24 | Ch          |             218 |
|                             32 | Dh          |             282 |
|                             48 | Eh          |             410 |
|                             64 | Fh          |             538 |

The critical part of a CAN FD frame is during the data phase, where the CAN bit rate is faster than in the arbitration phase. The minimum number of peripheral clocks per fast CAN bit (MinNumClkFastBit) can be calculated to guarantee that enough time is available for FlexCAN to scan the message buffer memory during reception and transmission. The equation below calculates this constraint.

<!-- formula-not-decoded -->

Equation 25. Minimum number of peripheral clocks per fast CAN bit for FlexCAN scan process

CAN (FlexCAN)

Where MaxNumOfMb is the maximum number of available message buffers defined in MCR[MAXMB]. NFE and ERFEN are the fields defined in Enhanced RX FIFO Control (ERFCR).

The clock-domain-crossing circuit between the CHI and PE subblocks also imposes a minimum number of peripheral clocks per fast CAN bit. This minimum is required for the handshake mechanism to work properly without losing status information through the interface, as shown in the equation below.

<!-- formula-not-decoded -->

## Equation 26. Minimum number of peripheral clocks per fast CAN bit for FlexCAN clock domain interface

Therefore, the larger of the two values calculated above determines the minimum number of peripheral clocks per fast CAN bit (MinNumClkFastBit).

MinNumClkFastBit = Maximum ( MinNumClkFastBitA , MinNumClkFastBitB )

## Equation 27. Minimum number of peripheral clocks per fast CAN bit

Then, the maximum CAN bit rate in the data phase of CAN FD frames (DataBitRateMAX) can be calculated as below.

<!-- formula-not-decoded -->

## Equation 28. Maximum achievable baud rate for data phase

These factors affect the maximum data bit rate attainable by FlexCAN in CAN FD mode:

- The peripheral and oscillator clock frequencies
- The maximum number of message buffers
- The expected nominal bit rate

Also, the data bit rate depends on the minimum payload size of FD frames used in a given application.

To illustrate how the configuration of FlexCAN variables affects the CAN FD bit rate, consider this application example:

- The peripheral clock frequency is set to 50 MHz
- The oscillator clock frequency set to 40 MHz
1. Considering the nominal bit rate as 1 Mbit/s, the number of peripheral clocks per CAN bit in nominal bit rate is calculated as below.

<!-- formula-not-decoded -->

## Equation 29. Calculation example for number of peripheral clocks per nominal CAN bit

2. The number of fast CAN bits (NumOfFastBits) is determined in the table presented above. For example, if the minimum payload in FD frames is 8 bytes, there are 85 CAN bits in the data phase.
3. Assuming the maximum number of message buffers is 96, and Enhanced RX FIFO is disabled, the minimum number of peripheral clocks per fast CAN bit (MinNumClkFastBit) can be calculated.

<!-- formula-not-decoded -->

## Equation 30. Calculation example for number of peripheral clocks per fast CAN bit for FlexCAN scan process

<!-- formula-not-decoded -->

## Equation 31. Calculation example for number of peripheral clocks per fast CAN bit for FlexCAN clock domain interface

MinNumClkFastBit = Maximum ( 5.06, 6.75 ) = 6.75

## Equation 32. Calculation example for number of peripheral clocks per fast CAN bit

4. The maximum CAN bit rate in the data phase can finally be found.

<!-- formula-not-decoded -->

Equation 33. Calculation example for maximum achievable baud rate

Even though the oscillator clock frequency (40 MHz) is adequate to generate a data rate of 8 Mbit/s in CAN FD mode, the specific FlexCAN configuration limits this rate to 6.667 Mbit/s. This limitation is mainly due to the low peripheral clock frequency that imposes the MinNumClkFastBitB bound.

Table 368 shows the maximum data rate for CAN FD with Enhanced RX FIFO disabled according to clock frequencies, payload size, and number of available message buffers. For some cases, if the number of available message buffers is reduced, FlexCAN can then achieve a data rate up to 8 Mbit/s.

Table 368. Maximum CAN bit rate in data phase on CAN FD frames with Enhanced RX FIFO disabled

|   Peripheral clock frequency (MHz) | Payload size   | Number of available message buffers   | Maximum data rate (Mbit/s)   |
|------------------------------------|----------------|---------------------------------------|------------------------------|
|                                 40 | 8              | 94                                    | 6.667                        |
|                                 40 | 8              | 114                                   | >5.0                         |
|                                 40 | 12             | >117                                  | 6.667                        |
|                                 40 | 12             | 128                                   | 5.714                        |
|                                 50 | 12 to 64       | 128                                   | 6.667                        |
|                                 60 | 8              | 126                                   | 8.0                          |
|                                 60 | 12             | 128                                   | 8.0                          |
|                                 67 | 6              | 128                                   | 8.0                          |
|                                 80 | 3              | 128                                   | 8.0                          |
|                                100 | 0              | 128                                   | 8.0                          |

## 50.3.12 Reset

You can reset FlexCAN in two ways:

- Chip-level hard reset, which resets all memory-mapped registers asynchronously.
- Soft reset
- MCR[SOFTRST], which resets some of the memory-mapped registers synchronously. See To see which registers soft reset affects, see Table 371.

Soft reset is synchronous and must follow an internal request-and-acknowledge procedure across clock domains. Therefore, it may take some time to propagate its effects fully. MCR[SOFTRST] remains 1 while soft reset is pending, so software can poll this field to identify when the reset has completed. Soft reset cannot be applied while clocks are shut down in a low-power mode. The low-power mode should be exited and the clocks resumed before applying soft reset.

When the module is enabled (MCR[MDIS] becomes 0), FlexCAN automatically enters Freeze mode. In Freeze mode:

1. FlexCAN is unsynchronized to the CAN bus.
2. MCR[HALT] and MCR[FRZ] become 1.
3. The internal state machines are disabled.
4. MCR[FRZACK] and MCR[NOTRDY] become 1.

The TX pin is in the recessive state and FlexCAN does not initiate any transmission or reception of CAN frames. Reset does not affect the message buffers and the RX Individual Mask registers, so they are not automatically initialized.

## 50.3.13 Interrupts

FlexCAN has many interrupt sources:

- Interrupts due to message buffers
- Interrupts due to interrupts combined via an OR operator from:
- Message buffers
- Bus Off
- Bus Off Done
- Error
- Error Fast (errors detected in the data phase of CAN FD format messages with BRS = 1)
- TX Warning
- RX Warning

If its corresponding IMASK bit is 1, each message buffer can be an interrupt source. There is no distinction between TX and RX interrupts for a particular buffer, under the assumption that the buffer is initialized for either transmission or reception. Each buffer has an assigned flag bit in the IFLAG registers. When the corresponding buffer completes a successful transfer, the flag is set. When the CPU writes 1 to it, the flag is cleared (unless another interrupt is generated at the same time).

## NOTE

The CPU must clear only the bit causing the current interrupt. For this reason, do not use bit manipulation instructions (BSET) to clear interrupt flags. These instructions may cause accidental clearing of interrupt flags which are set after entering the current interrupt handler.

If the Legacy RX FIFO is enabled (MCR[RFEN] = 1) and DMA is disabled (MCR[DMA] = 0), the interrupts corresponding to message buffers 0 to 7 have different meanings.

- Bit 7 of Interrupt Flags 1 (IFLAG1) becomes the Legacy FIFO Overflow flag
- Bit 6 becomes the Legacy FIFO Warning flag
- Bit 5 becomes the Frames Available in Legacy FIFO flag
- Bits 4-0 are unused.

CAN (FlexCAN)

See Interrupt Flags 1 (IFLAG1) for more information.

If both Legacy RX FIFO and DMA are enabled (MCR[RFEN] = 1 and MCR[DMA] = 1), FlexCAN does not generate any Legacy FIFO interrupt. Bit 5 of IFLAG1 still indicates Frames Available in Legacy FIFO and generates a DMA request. Bits 7, 6, 4-0 are unused.

## CAUTION

Legacy FIFO cannot be enabled when CAN FD is enabled.

When multiple message buffer interrupt sources are combined via an OR operator into a single interrupt, the interrupt is generated when any associated message buffer (or FIFO, if applicable) generates an interrupt. In this case, the CPU must read the IFLAG registers to determine which message buffer or FIFO source caused the interrupt.

These interrupt sources generate interrupts like the message buffer interrupt sources, and can be read from Error and Status 1 (ESR1):

- Bus Off
- Bus Off Done
- Error
- Error Fast
- TX Warning
- RX Warning

The Bus Off, Error, TX Warning, and RX Warning interrupt masks are located in Control 1 (CTRL1).

## 50.3.14 Bus interface

CPU access to FlexCAN registers is subject to the following rules:

- Read and write access to implemented reserved address space results in an access error.
- Write access to positions whose bits are all currently read-only results in an access error. If at least one of the bits is not read-only, no access error is issued. Write permission to positions or some of their bits can change depending on the mode of operation or transitory state. See register and field descriptions for details.
- Read and write access to unimplemented address space results in an access error.
- Read and write access to RAM-located positions during Low-Power mode results in an access error.
- The RXIMR memory region can be considered as general-purpose memory and available for access via these methods:
1. If you write 0 to MCR[IRMQ], the individual masks (RXIMR) are disabled. In this case, the RXIMR memory region is considered general-purpose memory.
2. If MCR[MAXMB] is programmed with a value smaller than the available number of message buffers, the unused memory space can be used as general-purpose RAM space. Reserved words within RAM cannot be used. For example, suppose the RAM in FlexCAN can support up to 16 message buffers, CTRL2[RFFN] = 0h, and MCR[MAXMB] = 0.
- In this case, the maximum number of message buffers becomes one.
- The RAM starts at 0080h, and the space 0080h-008Fh is used by the one message buffer.
- The memory space 0090h-017Fh is available.
- The space 0180h-087Fh is reserved.
- The space 0880h-0883h is used by the one individual mask and the available memory in the mask register space is 0884h-08BFh.
- In the space from 08C0h-09DFh, there are reserved words for internal use which cannot be used as generalpurpose RAM.

CAN (FlexCAN)

As a rule, free memory space for general purpose depends only on MCR[MAXMB].

3. If MCR[FDEN] = 1, general-purpose memory can be used only outside Freeze mode.

## Table 369. Access permissions

| Modes of operation   | Normal                        | Freeze                        | Low-power                     |
|----------------------|-------------------------------|-------------------------------|-------------------------------|
| MCR                  | bus error                     | bus error                     | bus error                     |
| CTRL1                | read and write                | read write                    | read and write                |
| TIMER                | read and write                | read and write                | read and write                |
| TCR                  | bus error                     | bus error                     | bus error                     |
| RXMGMASK 1           | bus error for write operation | read and write                | bus error for write operation |
| RX14MASK 1           | bus error for write operation | read and write                | bus error for write operation |
| RX15MASK 1           | bus error for write operation | read and write                | bus error for write operation |
| ECR                  | bus error for write operation | read and write                | bus error for write operation |
| ESR1                 | read and write                | read and write                | read and write                |
| IMASK2               | read and write                | read and write                | read and write                |
| IMASK1               | read and write                | read and write                | read and write                |
| IFLAG2               | read and write                | read and write                | read and write                |
| IFLAG1               | read and write                | read and write                | read and write                |
| CTRL2                | read and write                | read and write                | read and write                |
| ESR2                 | read and write                | read and write                | read and write                |
| CRCR                 | bus error for write operation | bus error for write operation | bus error for write operation |
| RXFGMASK 1           | bus error for write operation | read and write                | bus error for write operation |
| RXFIR 1              | bus error for write operation | bus error for write operation | bus error for write operation |
| CBT                  | bus error for write operation | read and write                | bus error for write operation |
| DBG1                 | bus error for write operation | bus error for write operation | bus error for write operation |
| DBG2                 | bus error for write operation | bus error for write operation | bus error for write operation |
| IMASK4               | read and write                | read and write                | read and write                |
| IMASK3               | read and write                | read and write                | read and write                |
| IFLAG4               | read and write                | read and write                | read and write                |

Table continues on the next page...

Table 369. Access permissions (continued)

| Modes of operation           | Normal                        | Freeze                        | Low-power                     |
|------------------------------|-------------------------------|-------------------------------|-------------------------------|
| IFLAG3                       | read and write                | read and write                | read and write                |
| MB 1 2                       | read and write                | read and write                | read and write                |
| Legacy FIFO header 1         | read and write                | read and write                | read and write                |
| Legacy FIFO reserved space 1 | bus error                     | bus error                     | bus error                     |
| Legacy FIFO filters 1        | read and write                | read and write                | read and write                |
| RXIMR 1                      | bus error                     | read and write                | bus error                     |
| MECR                         | read and write                | read and write                | read and write                |
| ERRIAR                       | read and write                | read and write                | read and write                |
| ERRIDPR                      | read and write                | read and write                | read and write                |
| ERRIPPR                      | read and write                | read and write                | read and write                |
| RERRAR 3                     | read and write                | read and write                | read and write                |
| RERRDR 3                     | read and write                | read and write                | read and write                |
| RERRSYNR 3                   | read and write                | read and write                | read and write                |
| ERRSR                        | read and write                | read and write                | read and write                |
| EPRS                         | bus error for write operation | read and write                | bus error for write operation |
| ENCBT                        | bus error for write operation | read and write                | bus error for write operation |
| EDCBT                        | bus error for write operation | read and write                | bus error for write operation |
| ETDC                         | bus error for write operation | read and write                | bus error for write operation |
| FDCTRL                       | read and write                | read and write                | read and write                |
| FDCBT                        | read and write 3              | read and write                | read and write 3              |
| FDCRC                        | bus error for write operation | bus error for write operation | bus error for write operation |
| ERFCR                        | read and write 3              | read and write                | read and write 3              |
| ERFIER                       | read and write                | read and write                | read and write                |
| ERFSR                        | read and write                | read and write                | read and write                |
| HR_TIME_STAMP                | read and write                | read and write                | read and write                |
| EXTRA CAN FD MB              | read and write                | read and write                | read and write                |

Table continues on the next page...

Table 369. Access permissions (continued)

| Modes of operation                | Normal                        | Freeze                        | Low-power                     |
|-----------------------------------|-------------------------------|-------------------------------|-------------------------------|
| Enhanced Rx FIFO header 4         | bus error for write operation | bus error for write operation | bus error for write operation |
| Enhanced Rx FIFO reserved space 4 | bus error                     | bus error                     | bus error                     |
| ERFFEL                            | bus error for write operation | read and write                | bus error for write operation |
| General purpose RAM 1             | read and write                | read and write                | read and write                |
| Reserved space (used) 1           | bus error                     | bus error                     | bus error                     |
| Reserved space (empty) 1          | bus error                     | bus error                     | bus error                     |

3. Write operation has no effect.
2. If MCR[RFEN] = 1, see Legacy FIFO access rules below.
4. If MCR[RFEN] = 1, do not access Enhanced RX FIFO.

## 50.3.15 Detection and correction of memory errors

To update the parity bits in memory properly, all FlexCAN memory must be initialized before starting its operation. CTRL2[WRMFRZ] grants write access to all memory positions that require initialization, from 080h-ADFh and from C20h-31FFh. You must also initialize these registers:

- RX Message Buffers Global Mask (RXMGMASK)
- Receive 14 Mask (RX14MASK)
- Receive 15 Mask (RX15MASK)
- Legacy RX FIFO Global Mask (RXFGMASK)

MCR[RFEN] and ERFCR[ERFEN] must not be 1 during memory initialization.

FlexCAN supports detection and correction of errors in memory read accesses. Each byte of FlexCAN memory is associated with five parity bits that ensure a Hamming distance of four. The error correction mechanism ensures that in this 13-bit word, errors in one bit can be corrected (correctable errors). Errors in two bits can be detected but not corrected (uncorrectable errors). Errors in more than two bits may not be detected. For uncorrectable errors, the error correction logic does not change the corrupted data. When a read access is performed, the parity bits are used to calculate a syndrome, which indicates the error in each byte.

When an all-zeroes or an all-ones read occurs, FlexCAN detects an uncorrectable error. See Error Report Syndrome (RERRSYNR).

Memory errors are indicated to the host via status register (Error Status (ERRSR)) and bus transfer errors. Memory errors are reported via these report registers:

- Error Report Address (RERRAR)
- Error Report Data (RERRDR)
- Error Report Syndrome (RERRSYNR)

MECR[ECCDIS] determines whether the error detection and correction mechanism can be activated. When disabled, updates on indications and reporting registers are stopped. To ensure that memory has consistent parity bits associated with the data, the parity bits are still calculated and written with data in memory write operations.

To avoid accidentally changing the critical error correction configuration, follow this protocol to enable the update of Memory Error Control (MECR):

1. Write 1 to CTRL2[ECRWRE]. (By default, CTRL2[ECRWRE] is 0 and MECR[ECRWRDIS] is 1.)

2. Write 0 to MECR[ECRWRDIS].
3. All writes to Memory Error Control (MECR) must keep MECR[ECRWRDIS] = 0.
4. After configuration is done, lock MECR by writing 1 to MECR[ECRWRDIS] or writing 0 to CTRL2[ECRWRE].

## 50.3.15.1 Sources of memory access

These major sources (or requestors) can access FlexCAN memory:

- Host (CPU). The largest word accessed is 32-bit.
- FlexCAN internal processes:
- RX matching
- TX arbitration
- Move-in on reception
- Move-out on transmission

The largest word accessed is 64-bit.

The source of access determines the way that uncorrectable errors are indicated and reported.

## 50.3.15.2 Error indication

These flags indicate memory errors:

- ERRSR[HANCEIF]
- ERRSR[FANCEIF]
- ERRSR[CEIF]

Uncorrectable errors detected in memory reads requested by the host are indicated separately from the errors detected in requests by FlexCAN internal processes. When correctable errors are detected, FlexCAN makes no distinction of the source of the access. There are three independent flags for these three cases masks it. If both uncorrectable and correctable errors are found in different bytes in the same read operation, both flags are set.

An uncorrectable error detected in host access is also indicated as a bus transfer error. A bus wait request may be asserted to extend the memory transaction to the moment the report registers are updated. This indication cannot be masked.

Each indication flag has one overrun flag in Error Status (ERRSR). The overrun flags do not request interrupts. Overrun flags for uncorrectable errors indicate that other errors of the same nature were detected after current error being treated. Overrun flags for correctable errors indicate that other errors of the same nature were detected before the current error being treated.

The recommended handling sequence for error indication is:

1. Get error report information from report registers.
2. Use this information to take proper measures in the application.
3. Clear the ERRSR[HANCEIF], ERRSR[FANCEIF], and ERRSR[CEIF] flags.
4. If the overrun flag is active:
- a. Alert the application that at least one error could not be managed.
- b. Clear the overrun flag.

FlexCAN internal processes can access memory in transactions larger than 32 bits. For the indication, this kind of access is considered a consecutive sequence of 32-bit accesses. If errors are found in two or more 32-bit words, the interrupt and overrun flags are set simultaneously.

CAN (FlexCAN)

## 50.3.15.3 Error reporting

The error report registers provide detailed information about the address read, raw data, and syndrome read with error. The flags described in Error indication indicate these report registers:

- Error Report Address (RERRAR)
- Error Report Data (RERRDR)
- Error Report Syndrome (RERRSYNR)

The address, data, and syndrome registers are updated simultaneously with the error flags, according to these rules:

1. If either of the uncorrectable error flags is set, the report registers are not updated. The previous uncorrectable error reporting is preserved.
2. Otherwise, either no error flag is set or only the correctable error flag is set. The report registers are updated according to the new error, or according to the most severe new error, if uncorrectable and correctable errors are simultaneously detected.

Reporting of errors detected in accesses larger than 32 bits follows the rules described in Error indication and in the description of Error Report Address (RERRAR).

The addresses reported in RERRAR and defined in ERRIAR are not the same as the addresses listed in the module memory map. The relation between the reported addresses and the respective ones in the module memory map is shown in the description of Error Injection Address (ERRIAR).

Addresses reported when reading memory portions organized as FIFOs refer to the address of the specific entry accessed in the FIFO, not to the FIFO base address. Such memory portions include:

- Legacy RX FIFO Structure
- Enhanced RX FIFO Structure
- Legacy RX FIFO Information (RXFIR)

To assure coherence of error report registers, disable the report update by writing 1 to MECR[RERRDIS] before reading the report registers.

## 50.3.15.4 Error response

Correctable errors have no consequence to FlexCAN operation, because the host or FlexCAN internal processes corrects affected data before its use.

For host-initiated reads, an uncorrectable error may affect the host, but does not affect FlexCAN operation.

Uncorrectable errors detected on memory read operations requested by FlexCAN internal processes may result in incorrect operation depending on the state of MECR[NCEFAFRZ], as follows:

- During reception (either matching or move-in process), when an uncorrectable error occurs:
- An incorrect destination may be selected to store the incoming frame.
- A corrupted frame may be stored in the correct destination.
- Both of these events may occur.

If MECR[NCEFAFRZ] = 1, FlexCAN stops operation automatically and enters Freeze mode to prevent corrupted data from being treated as valid by FlexCAN internal processes. If MECR[NCEFAFRZ] = 0, FlexCAN continues working, and a corrupted frame is received.

- During arbitration, when an uncorrectable error occurs:
- A non-highest-priority TX message buffer may be mistakenly selected for transmission.
- Its data may be corrupted.

If MECR[NCEFAFRZ] = 1, FlexCAN stops operation automatically and enters Freeze mode before starting the move-out. If MECR[NCEFAFRZ] = 0, FlexCAN proceeds to move-out with a corrupted frame that will be transmitted on the CAN bus.

CAN (FlexCAN)

CAN (FlexCAN)

- During move-out, when an uncorrectable error occurs, a corrupted frame is copied from the selected TX MB that won the arbitration to the TX SMB for transmission. If MECR[NCEFAFRZ] = 1, FlexCAN stops operation automatically and enters Freeze mode before starting the transmission. When MECR[NCEFAFRZ] = 0, the corrupted frame is transferred from the TX SMB to the Protocol Engine (PE) subblock and is transmitted on the CAN bus.
- An uncorrectable error can also be detected beyond move-out, when TX data is read from TX SMB (buffer located in RAM) to be transferred to the PE subblock for transmission. In this case, a frame with corrupted ID or data is transmitted on the CAN bus.

To prevent the external nodes from successfully receiving the frame, FlexCAN inverts all bits in the CRC field (CRC sequence plus CRC delimiter). Also, it transmits an error flag just after CRC delimiter due to self-detecting a Bit1 error and a form error due to the CRC field inversion. When MECR[NCEFAFRZ] = 1, FlexCAN stops operation automatically and enters Freeze mode just after the error frame. When MECR[NCEFAFRZ] = 0, FlexCAN may attempt to retransmit the same frame, as long as no other higher-priority TX MB is configured for transmission after.

If the uncorrectable error persists, FlexCAN eventually reaches the Bus Off state due to consecutive error detections. ECR[TXERRCNT] is updated every time FlexCAN inverts the CRC field, causing errors as described above.

When MECR[NCEFAFRZ] = 1 and FlexCAN enters Freeze mode, only the CPU can cause FlexCAN to exit Freeze mode and resume Normal mode. MECR[NCEFAFRZ] becoming 1 is the only way to prevent corrupted frames from being transmitted on the CAN bus to the move-out internal process.

The error report registers can provide information to the application for customized management of these situations.

## 50.3.15.5 Error injection

These error injection registers are used to inject errors in memory reads to force errors and update the indication and reporting registers:

- Error Injection Address (ERRIAR)
- Error Injection Data Pattern (ERRIDPR)
- Error Injection Parity Pattern (ERRIPPR)

The relation between the error injection addresses and the corresponding addresses in the module memory map is shown in Error Injection Address (ERRIAR).

The injection is done by flipping the data and parity bits corresponding to the bits set to 1 in ERRIDPR and ERRIPPR. You can select injection specifically for memory accesses requested by the host or by FlexCAN internal processes.

For accesses larger than 32 bits, MECR[EXTERRIE] extends the injection pattern, replicating it in 32-bit words to fill the width of the access.

## NOTE

While it is very unlikely, error injection may correct a bit with error. This correction does not raise the error flags and reports as expected.

To ensure coherence among error injection registers and avoid spurious error injections, you must clear MECR[HAERRIE] and MECR[FAERRIE] when configuring the memory injection registers.

## 50.4 External signal descriptions

FlexCAN has two I/O signals connected to the external chip pins. These signals are summarized in Table 370 and described in the next subsections.

Table 370. FlexCAN signal descriptions

| Signal   | Description      | I/O    |
|----------|------------------|--------|
| CAN RX   | CAN receive pin  | Input  |
| CAN TX   | CAN transmit pin | Output |

## 50.4.1 CAN RX

This pin is the receive pin from the CAN bus transceiver. Logic level 0 represents its dominant state. Logic level 1 represents its recessive state.

## 50.4.2 CAN TX

This pin is the transmit pin to the CAN bus transceiver. Logic level 0 represents its dominant state. Logic level 1 represents its recessive state.

## 50.5 Memory map and register definition

This section describes the registers and data structures in FlexCAN. The base address of the module depends on the particular memory map of the chip.

## 50.5.1 FlexCAN memory mapping

The address space occupied by FlexCAN has 128 bytes for registers starting at the module base address, followed by embedded RAM starting at address offset 0080h.

Each individual register is identified by its complete name and corresponding mnemonic .

## NOTE

An invalid register access results in a bus error. Invalid accesses include reading a write-only register, writing a read-only register, and accessing an invalid address.

## NOTE

To update the parity bits in memory properly, all FlexCAN memory must be initialized before reading registers which are implemented in memory. CTRL2[WRMFRZ] grants write access to all memory positions that require initialization, from 080h-ADFh and from C20h-31FFh. You must also initialize RX Message Buffers Global Mask (RXMGMASK), Receive 14 Mask (RX14MASK), Receive 15 Mask (RX15MASK) and Legacy RX FIFO Global Mask (RXFGMASK). MCR[RFEN] and ERFCR[ERFEN] must not be 1 during memory initialization.

Table 371. Register reset information

| Register                                  | Affected by hard reset   | Affected by soft reset   |
|-------------------------------------------|--------------------------|--------------------------|
| Module Configuration (MCR)                | Yes                      | Yes                      |
| Control 1 (CTRL1)                         | Yes                      | No                       |
| Free-Running Timer (TIMER)                | Yes                      | Yes                      |
| RX Message buffers Global Mask (RXMGMASK) | No                       | No                       |
| RX Buffer 14 Mask (RX14MASK)              | No                       | No                       |
| RX Buffer 15 Mask (RX15MASK)              | No                       | No                       |
| Error Counter (ECR)                       | Yes                      | Yes                      |
| Error and Status 1 (ESR1)                 | Yes                      | Yes                      |
| Interrupt Masks 2 (IMASK2)                | Yes                      | Yes                      |

Table continues on the next page...

CAN (FlexCAN)

Table 371. Register reset information (continued)

| Register                                   | Affected by hard reset   | Affected by soft reset   |
|--------------------------------------------|--------------------------|--------------------------|
| Interrupt Masks 1 (IMASK1)                 | Yes                      | Yes                      |
| Interrupt Flags 2 (IFLAG2)                 | Yes                      | Yes                      |
| Interrupt Flags 1 (IFLAG1)                 | Yes                      | Yes                      |
| Control 2 (CTRL2)                          | Yes                      | No                       |
| Error and Status 2 (ESR2)                  | Yes                      | Yes                      |
| Cyclic Redundancy Check (CRCR)             | Yes                      | Yes                      |
| RX FIFO Global Mask (RXFGMASK)             | No                       | No                       |
| RX FIFO Information (RXFIR)                | No                       | No                       |
| CAN Bit Timing (CBT)                       | Yes                      | No                       |
| Interrupt Masks 4 (IMASK4)                 | Yes                      | Yes                      |
| Interrupt Masks 3 (IMASK3)                 | Yes                      | Yes                      |
| Interrupt Flags 4 (IFLAG4)                 | Yes                      | Yes                      |
| Interrupt Flags 3 (IFLAG3)                 | Yes                      | Yes                      |
| Message buffers                            | No                       | No                       |
| RX Individual Masks                        | No                       | No                       |
| Memory Error Control (MECR)                | Yes                      | Yes                      |
| Error Injection Address (ERRIAR)           | Yes                      | Yes                      |
| Error Injection Data Pattern (ERRIDPR)     | Yes                      | Yes                      |
| Error Injection Parity Pattern (ERRIPPR)   | Yes                      | Yes                      |
| Error Report Address (RERRAR)              | Yes                      | Yes                      |
| Error Report Data (RERRDR)                 | Yes                      | Yes                      |
| Error Report Syndrome (RERRSYNR)           | Yes                      | Yes                      |
| Error Status (ERRSR)                       | Yes                      | Yes                      |
| Enhanced CAN Bit Timing Prescalers (EPRS)  | Yes                      | No                       |
| Enhanced Nominal CAN Bit Timing (ENCBT)    | Yes                      | No                       |
| Enhanced Data Phase CAN bit Timing (EDCBT) | Yes                      | No                       |

Table continues on the next page...

CAN (FlexCAN)

Table 371. Register reset information (continued)

| Register                                       | Affected by hard reset   | Affected by soft reset   |
|------------------------------------------------|--------------------------|--------------------------|
| Enhanced Transceiver Delay Compensation (ETDC) | Yes                      | No                       |
| CAN FD Control (FDCTRL)                        | Yes                      | No                       |
| CAN FD Bit Timing (FDCBT)                      | Yes                      | No                       |
| CAN FD CRC (FDCRC)                             | Yes                      | Yes                      |
| Enhanced RX FIFO Control (ERFCR)               | Yes                      | Yes                      |
| Enhanced RX FIFO Interrupt Enable (ERFIER)     | Yes                      | Yes                      |
| Enhanced RX FIFO Status (ERFSR)                | Yes                      | Yes                      |
| High-Resolution Timestamp (HR_TIME_STAMP)      | No                       | No                       |
| Extra CAN FD Message Buffers                   | No                       | No                       |
| Enhanced RX FIFO                               | No                       | No                       |
| Enhanced RX FIFO Filter Element (ERFFEL)       | No                       | No                       |

FlexCAN can store CAN messages for transmission and reception using message buffers and RX FIFO structures.

## 50.5.2 CAN register descriptions

The table below shows the FlexCAN memory map.

The address range from offset 80h-87Fh allocates the one hundred twenty-eight 128-bit message buffers.

The address range from offset 1000h-17FFh allocates an extra message buffer space which can be used for CAN FD operation mode.

The memory maps for the message buffers are in FlexCAN message buffer memory map.

The address range from offset 2000h-204Ch allocates the Enhanced RX FIFO output, and the address range from offset 2050h-29FCh allocates the rest of Enhanced RX FIFO 31 elements.

The memory map for the Enhanced RX FIFO is in Enhanced RX FIFO structure.

## 50.5.2.1 CAN memory map

CAN\_0 base address: 401B\_4000h

CAN\_1 base address: 401B\_E000h

CAN\_2 base address: 402A\_8000h

CAN\_3 base address: 402B\_2000h

| Offset   | Register                   |   Width (In bits) | Access   | Reset value   |
|----------|----------------------------|-------------------|----------|---------------|
| 0h       | Module Configuration (MCR) |                32 | RW       | D890_000Fh    |
| 4h       | Control 1 (CTRL1)          |                32 | RW       | 0000_0000h    |

Table continues on the next page...

CAN (FlexCAN)

Table continued from the previous page...

| Offset      | Register                                    |   Width (In bits) | Access   | Reset value   |
|-------------|---------------------------------------------|-------------------|----------|---------------|
| 8h          | Free-Running Timer (TIMER)                  |                32 | RW       | 0000_0000h    |
| 10h         | RX Message Buffers Global Mask (RXMGMASK)   |                32 | RW       | See section   |
| 14h         | Receive 14 Mask (RX14MASK)                  |                32 | RW       | See section   |
| 18h         | Receive 15 Mask (RX15MASK)                  |                32 | RW       | See section   |
| 1Ch         | Error Counter (ECR)                         |                32 | RW       | 0000_0000h    |
| 20h         | Error and Status 1 (ESR1)                   |                32 | RW       | 0000_0000h    |
| 24h         | Interrupt Masks 2 (IMASK2)                  |                32 | RW       | 0000_0000h    |
| 28h         | Interrupt Masks 1 (IMASK1)                  |                32 | RW       | 0000_0000h    |
| 2Ch         | Interrupt Flags 2 (IFLAG2)                  |                32 | RW       | 0000_0000h    |
| 30h         | Interrupt Flags 1 (IFLAG1)                  |                32 | RW       | 0000_0000h    |
| 34h         | Control 2 (CTRL2)                           |                32 | RW       | 0010_0000h    |
| 38h         | Error and Status 2 (ESR2)                   |                32 | R        | 0000_0000h    |
| 44h         | Cyclic Redundancy Check (CRCR)              |                32 | R        | 0000_0000h    |
| 48h         | Legacy RX FIFO Global Mask (RXFGMASK)       |                32 | RW       | See section   |
| 4Ch         | Legacy RX FIFO Information (RXFIR)          |                32 | R        | See section   |
| 50h         | CAN Bit Timing (CBT)                        |                32 | RW       | 0000_0000h    |
| 68h         | Interrupt Masks 4 (IMASK4)                  |                32 | RW       | 0000_0000h    |
| 6Ch         | Interrupt Masks 3 (IMASK3)                  |                32 | RW       | 0000_0000h    |
| 70h         | Interrupt Flags 4 (IFLAG4)                  |                32 | RW       | 0000_0000h    |
| 74h         | Interrupt Flags 3 (IFLAG3)                  |                32 | RW       | 0000_0000h    |
| 880h - A7Ch | Receive Individual Mask (RXIMR0 - RXIMR127) |                32 | RW       | See section   |
| AE0h        | Memory Error Control (MECR)                 |                32 | RW       | 800C_0080h    |
| AE4h        | Error Injection Address (ERRIAR)            |                32 | RW       | 0000_0000h    |
| AE8h        | Error Injection Data Pattern (ERRIDPR)      |                32 | RW       | 0000_0000h    |
| AECh        | Error Injection Parity Pattern (ERRIPPR)    |                32 | RW       | 0000_0000h    |
| AF0h        | Error Report Address (RERRAR)               |                32 | R        | 0000_0000h    |
| AF4h        | Error Report Data (RERRDR)                  |                32 | R        | 0000_0000h    |
| AF8h        | Error Report Syndrome (RERRSYNR)            |                32 | R        | 0000_0000h    |
| AFCh        | Error Status (ERRSR)                        |                32 | RW       | 0000_0000h    |
| BF0h        | Enhanced CAN Bit Timing Prescalers (EPRS)   |                32 | RW       | 0000_0000h    |
| BF4h        | Enhanced Nominal CAN Bit Timing (ENCBT)     |                32 | RW       | 0000_0000h    |

Table continues on the next page...

Table continued from the previous page...

| Offset        | Register                                                      |   Width (In bits) | Access   | Reset value   |
|---------------|---------------------------------------------------------------|-------------------|----------|---------------|
| BF8h          | Enhanced Data Phase CAN Bit Timing (EDCBT)                    |                32 | RW       | 0000_0000h    |
| BFCh          | Enhanced Transceiver Delay Compensation (ETDC)                |                32 | RW       | 0000_0000h    |
| C00h          | CAN FD Control (FDCTRL)                                       |                32 | RW       | 8000_0100h    |
| C04h          | CAN FD Bit Timing (FDCBT)                                     |                32 | RW       | 0000_0000h    |
| C08h          | CAN FD CRC (FDCRC)                                            |                32 | R        | 0000_0000h    |
| C0Ch          | Enhanced RX FIFO Control (ERFCR)                              |                32 | RW       | 0000_0000h    |
| C10h          | Enhanced RX FIFO Interrupt Enable (ERFIER)                    |                32 | RW       | 0000_0000h    |
| C14h          | Enhanced RX FIFO Status (ERFSR)                               |                32 | RW       | 0000_0000h    |
| C30h - E2Ch   | High-Resolution Timestamp (HR_TIME_STAMP0 - HR_TIME_STAMP127) |                32 | RW       | See section   |
| 3000h - 31FCh | Enhanced RX FIFO Filter Element (ERFFEL0 - ERFFEL127)         |                32 | RW       | See section   |

## 50.5.2.2 Module Configuration (MCR)

## Offset

| Register   | Offset   |
|------------|----------|
| MCR        | 0h       |

## Function

Defines global system configurations, including the module operation modes and the maximum message buffer configuration.

## Diagram

<!-- image -->

## Fields

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 MDIS   | Module Disable Disables FlexCAN. Whendisabled, FlexCAN disables the clocks to the CANProtocol Engine and Controller Host Interface submodules. Soft reset does not affect this field. 0b - Enable 1b - Disable                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 30 FRZ    | Freeze Enable Specifies FlexCAN behavior when MCR[HALT] = 1 or when Debug mode is requested at chip level. When this field becomes 1, FlexCAN can enter Freeze mode. Writing 0 to this field causes FlexCAN to exit from Freeze mode. The chip writes 1 to this field when a non-correctable error is detected (MECR[NCEFAFRZ] becomes 1). 0b - Disable 1b - Enable                                                                                                                                                                                                                                                                                                                                                                                              |
| 29 RFEN   | Legacy RX FIFO Enable Enables the Legacy RX FIFO feature. When this field is 1, message buffers 0-5 cannot be used for normal reception and transmission. The corresponding memory region (80h-DCh) is used by the FIFO engine and additional message buffers (up to 32, depending on CTRL2[RFFN]). These message buffers are used as Legacy RX FIFO ID filter table elements. This field also impacts the definition of the minimum number of peripheral clocks per CAN bit as described in Table 366. This field can be written in Freeze mode only; the module blocks it in other modes. When CAN FD operation is enabled (see MCR[FDEN]), you cannot write 1 to this field. NOTE This field must not be 1 if ERFCR[ERFEN] = 1. NOTE 0b - Disable 1b - Enable |
| 28 HALT   | Halt FlexCAN Puts FlexCAN into Freeze mode. The CPU should write 0 to this field after initializing the message buffers and Control 1 (CTRL1) and Control 2 (CTRL2). FlexCAN performs no reception or transmission before this field becomes 0. Freeze mode cannot be entered when FlexCAN is in a low-power mode. The module writes 1 to this field when a non-correctable error is detected and MECR[NCEFAFRZ] = 1. 0b - No request 1b - Enter Freeze mode, if MCR[FRZ] = 1.                                                                                                                                                                                                                                                                                   |
| 27 NOTRDY | FlexCAN Not Ready Indicates whether FlexCAN is in Disable mode or Freeze mode. When FlexCAN has exited these modes, this field becomes 0. Soft reset does not affect this field.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |

Table continues on the next page...

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | 0b - FlexCAN is in Normal mode, Listen-Only mode, or Loopback mode. 1b - FlexCAN is in Disable mode or Freeze mode.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 26 -       | Reserved When writing to this field, always write the reset value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 25 SOFTRST | Soft Reset Resets internal state machines of FlexCAN and some memory-mapped registers. The CPUcanwrite 1 to this field directly.. Because soft reset is synchronous and must follow a request-and- acknowledge procedure across clock domains, it may take some time to propagate its effect fully. While reset is pending, this field remains 1; it automatically becomes 0 when reset completes. You can poll this field to know when the soft reset has completed. Soft reset cannot be applied when clocks are shut down in a low-power mode. Transfer the module out of the low-power mode before applying soft reset. Soft reset does not affect this field. 0b - No reset 1b - Soft reset affects reset registers                                                                                                                                                                  |
| 24 FRZACK  | Freeze Mode Acknowledge Indicates whether FlexCAN is in Freeze mode and its prescaler is stopped. The Freeze mode request cannot be granted until current transmission or reception processes have finished. Therefore the software can poll the FRZACK bit to know when FlexCAN has entered Freeze mode. If the Freeze mode request is negated, this field becomes 0 after the FlexCAN prescaler is running again. If Freeze mode is requested when FlexCAN is in a low-power mode, this field becomes 1 only when the low-power mode is exited. See Freeze mode. Soft reset does not affect this field. FRZACK becomes 1 within 178 CAN bits following the Freeze mode request by the CPU. This field becomes 0 within 2 CAN bits after the Freeze mode request removal (see Protocol timing). NOTE 0b - Not in Freeze mode, prescaler running. 1b - In Freeze mode, prescaler stopped. |
| 23 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 22 -       | Reserved When writing to this field, always write the reset value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 21 WRNEN   | Warning Interrupt Enable Enables the generation of the flags ESR1[TWRNINT] and ESR1[RWRNINT]. When this field is 1, TWRNINT and RWRNINT flags are set when the respective error counter transitions from less than 96 to greater than or equal to 96. When this field is 0, the TWRNINT and RWRNINT flags are always                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

Table continues on the next page...

## Table continued from the previous page...

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|           | zero, independent of the values of the error counters. No warning interrupt is generated. This field can be written in Freeze mode only; the module blocks it in other modes. 0b - Disable 1b - Enable                                                                                                                                                                                                                                                                                                                                                                           |
| 20 LPMACK | Low-Power Mode Acknowledge Indicates whether FlexCAN is in a low-power mode (Disable mode). A low-power mode cannot be entered until all current transmission and reception processes have finished. The CPU can poll this field to know when FlexCAN has entered low-power mode. Soft reset does not affect this field. This field becomes 1 within 180 CAN bits after the low-power mode request by the CPU. This field becomes 0 within 2 CAN bits after the low-power mode request removal (see Protocol timing). NOTE 0b - Not in a low-power mode 1b - In a low-power mode |
| 19 -      | Reserved When writing to this field, always write the reset value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 18 -      | Reserved When writing to this field, always write the reset value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 17 SRXDIS | Self-Reception Disable Determines whether FlexCAN can receive frames transmitted by itself. If 1, frames transmitted by the module are not stored in any MB, regardless of whether the MB is programmed with an ID that matches the transmitted frame. No interrupt flag or interrupt signal is generated due to the frame reception. This field can be written only in Freeze mode; the module blocks it in other modes. 0b - Enable 1b - Disable                                                                                                                               |
| 16 IRMQ   | Individual RX Masking and Queue Enable Indicates whether RX matching process is based on individual masking and queue, or based on a masking scheme with RX Message Buffers Global Mask (RXMGMASK), Receive 14 Mask (RX14MASK), Receive 15 Mask (RX15MASK), and Legacy RX FIFO Global Mask (RXFGMASK). When this field is disabled, for backward compatibility with legacy applications, the reading of Control and Status word locks the MB even if it is empty. This field can be written in Freeze mode only. The module blocks it in other modes. 0b - Disable 1b - Enable   |
| 15        | DMA Enable                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |

Table continues on the next page...

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| DMA        | Enables DMA. The DMA feature can only be used in Legacy RX FIFO or Enhanced RX FIFO, so MCR[RFEN] or ERFCR[ERFEN] must be 1. When DMA and RFEN are 1, IFLAG1[BUF5I] generates the DMA request, and no RX FIFO interrupt is generated. This field can be written in Freeze mode only; the module blocks it in other modes. 0b - Disable 1b - Enable                                                                                                                                                                                                                       |
| 14 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 13 LPRIOEN | Local Priority Enable Enables the local priority feature. It is used to expand the ID used during the arbitration process. With this expanded ID concept, the arbitration process is done based on the full 32-bit word. However, the actual transmitted ID is 11 bits for standard frames and 29 bits for extended frames. This field can be written only in Freeze mode; the module blocks it in other modes. This bit is provided for backward compatibility with legacy applications. 0b - Disable 1b - Enable                                                       |
| 12 AEN     | Abort Enable Enables the TX abort mechanism. This mechanism guarantees a safe procedure for aborting a pending transmission, so that no frame is sent in the CAN bus without notification. This field can be written only in Freeze mode; the module blocks it in other modes. When this field is 1, only use the abort mechanism (see Transmission abort mechanism) to update message buffers configured for transmission. NOTE Writing the abort code into RX message buffers can cause unpredictable results when this field is 1. CAUTION 0b - Disabled 1b - Enabled |
| 11 FDEN    | CAN FD Operation Enable Enables the CAN with flexible data rate (CAN FD) operation. This field can be written in Freeze mode only. FlexCAN can receive and transmit messages in CAN 2.0 format. If this field is enabled, FlexCAN can also receive and transmit messages in CAN FD format. FlexCAN can transmit FD frame format according to ISO 11898-1:2015. If the value of this field is 1, the Legacy RX FIFO Enable (MCR[RFEN]) field cannot be 1. NOTE                                                                                                            |

Table continues on the next page...

## Table continued from the previous page...

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|           | 0b - Disable 1b - Enable                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 10 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 9-8 IDAM  | ID Acceptance Mode Identifies the format of the Legacy RXFIFO ID filter table elements. This field configures all elements of the table at the sametime; they are all the sameformat. SeeLegacy RXFIFOstructure. This field can be written only in Freeze mode; the module blocks it in other modes. 00b - Format A: One full ID (standard and extended) per ID filter table element. 01b - Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID filter table element. 10b - Format C: Four partial 8-bit standard IDs per ID filter table element. 11b - Format D: All frames rejected.                                                                                                                |
| 7 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 6-0 MAXMB | Number of the Last Message Buffer Defines the number of the last messagebuffer that takes part in the matching and arbitration processes.The reset value (0Fh) is equivalent to a 16-MB configuration. This field can be written only in Freeze mode; the module blocks it in other modes. You must write a value smaller than or equal to the number of available message buffers to this field, as described in FlexCAN memory partition for CAN FD. NOTE Additionally, the MAXMBvalue must consider the region of message buffers occupied by Legacy RX FIFO and its ID filters table space defined by CTRL2[RFFN]. MAXMB also impacts the definition of the minimum number of peripheral clocks per CAN bit, as described in Table 366. |

## 50.5.2.3 Control 1 (CTRL1)

## Offset

| Register   | Offset   |
|------------|----------|
| CTRL1      | 4h       |

## Function

Contains specific FlexCAN control features related to the CAN bus. These features include bit rate, programmable sampling point within an RX bit, Loopback mode, Listen-Only mode, Bus Off recovery behavior, and interrupt enabling (Bus-Off, Error, Warning). It also determines the division factor for the clock prescaler.

CAN (FlexCAN)

The CAN bit timing variables (CTRL1[PRESDIV], CTRL1[PROPSEG], CTRL1[PSEG1], CTRL1[PSEG2], and CTRL1[RJW]) can also be configured in CAN Bit Timing (CBT), which extends the range of all these variables. If CBT[BTF] = 1, PRESDIV, PROPSEG, PSEG1, PSEG2, and RJW become read-only.

If CBT[BTE] = 1, CTRL1[PRESDIV], CTRL1[PROPSEG], CTRL1[PSEG1], CTRL1[PSEG2], and CTRL1[RJW] are not used by the module. Instead, these fields are read as zero, and a write operation to them has no effect.

## NOTE

When the CAN FD feature is enabled, do not use CTRL1[PRESDIV], CTRL1[PROPSEG], CTRL1[PSEG1], CTRL1[PSEG2], and CTRL1[RJW] for CAN bit timing. Instead use CBT[EPRESDIV], CBT[ERJW], CBT[EPSEG1], CBT[EPSEG2], and CBT[EPROPSEG].

The CAN bit variables in CTRL1 and in CBT are stored in the same register.

Soft reset does not affect the contents of this register.

## Diagram

<!-- image -->

| Bits   | 31       | 30      | 29        | 28      | 27       | 26       | 25      | 24      | 23   | 22       | 21    | 20    | 19    | 18      | 17      | 16      |
|--------|----------|---------|-----------|---------|----------|----------|---------|---------|------|----------|-------|-------|-------|---------|---------|---------|
| R W    | PRESDIV  | PRESDIV | PRESDIV   | PRESDIV | PRESDIV  | PRESDIV  | PRESDIV | PRESDIV | RJW  | RJW      | PSEG1 | PSEG1 | PSEG1 | PSEG2   | PSEG2   | PSEG2   |
| Reset  | 0        | 0       | 0         | 0       | 0        | 0        | 0       | 0       | 0    | 0        | 0     | 0     | 0     | 0       | 0       | 0       |
| Bits   | 15       | 14      | 13        | 12      | 11       | 10       | 9       | 8       | 7    | 6        | 5     | 4     | 3     | 2       | 1       | 0       |
| R W    | BOFF MSK | ERRM SK | Reserv ed | LPB     | TWRN MSK | RWRN MSK | 0       | 0       | SMP  | BOFF REC | TSYN  | LBUF  | LOM   | PROPSEG | PROPSEG | PROPSEG |
| Reset  | 0        | 0       | 0         | 0       | 0        | 0        | 0       | 0       | 0    | 0        | 0     | 0     | 0     | 0       | 0       | 0       |

## Fields

| Field         | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|---------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-24 PRESDIV | Prescaler Division Factor Determines the ratio between the PE clock frequency and the serial clock (Sclock) frequency. The Sclock period defines the time quantum of the CAN protocol. For the reset value, the Sclock frequency is equal to the PE clock frequency. The maximum value of this field is FFh, which gives a minimum Sclock frequency equal to the PE clock frequency divided by 256. See Protocol timing for more information. This field can be written only in Freeze mode; the module blocks it in other modes. Sclock frequency = PE clock frequency  (PRESDIV + 1). |
| 23-22 RJW     | Resync Jump Width Defines the maximum number of time quanta that one resynchronization can change a bit time. One time quantum is equal to one Sclock period. The valid programmable values are 0-3. See Protocol timing for more information. This field can be written only in Freeze mode; the module blocks it in other modes. Resync Jump Width = RJW + 1.                                                                                                                                                                                                                          |
| 21-19 PSEG1   | Phase Segment 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |

Table continues on the next page...

## Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | Defines the length of phase segment 1 in the bit time. The valid programmable values are 0-7. See Protocol timing for more information. This field can be written only in Freeze mode; the module blocks it in other modes. Phase Buffer Segment 1 = (PSEG1 + 1)  Time Quanta.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 18-16 PSEG2 | Phase Segment 2 Defines the length of phase segment 2 in the bit time. The valid programmable values are 1-7. See Protocol timing for more information. This field can be written only in Freeze mode; the module blocks it in other modes. Phase Buffer Segment 2 = (PSEG2 + 1)  Time Quanta.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 15 BOFFMSK  | Bus Off Interrupt Mask Provides a mask for the Bus Off interrupt ESR1[BOFFINT]. 0b - Interrupt disabled 1b - Interrupt enabled                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 14 ERRMSK   | Error Interrupt Mask Provides a mask for the Error interrupt ESR1[ERRINT]. 0b - Interrupt disabled 1b - Interrupt enabled                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 13 -        | Reserved Writeable only if the module is disabled. Otherwise the access type is read-only. NOTE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 12          | Loopback Mode                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| LPB         | Configures FlexCAN to operate in Loopback mode. In this mode, FlexCAN performs an internal loopback that can be used for self-test operation. The bit stream output of the transmitter is fed back internally to the receiver input. The RX CAN input pin is ignored and the TX CAN output goes to the recessive state (logic 1). FlexCAN behaves as it normally does when transmitting, and treats its own transmitted message as a message received from a remote node. In this mode, FlexCAN ignores the bit sent during the ACK slot in the CAN frame acknowledge field. It generates an internal acknowledge bit to ensure proper reception of its own message. Both transmit and receive interrupts are generated. This field can be written only in Freeze mode; the module blocks it in other modes. In this mode, MCR[SRXDIS]cannotbecome1.This setting would impede the self-reception of a transmitted message. NOTE FDCTRL[TDCEN] and MCR[ETDCEN] must be 0 when this field is 1. NOTE |

Table continues on the next page...

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | 0b - Disabled 1b - Enabled                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 11 TWRNMSK | TX Warning Interrupt Mask Provides a mask for the TX Warning interrupt associated with the ESR1[TWRNINT] flag. When MCR[WRNEN] = 0, this field is read as 0. This field can be written only if MCR[WRNEN] = 1. 0b - Disabled 1b - Enabled                                                                                                                                                                                                                                                                                                                                                                                      |
| 10 RWRNMSK | RX Warning Interrupt Mask Provides a mask for the RX Warning interrupt associated with the ESR1[RWRNINT] flag. When MCR[WRNEN] = 0, this field is read as 0. This field can be written only if MCR[WRNEN] = 1. 0b - Disabled 1b - Enabled                                                                                                                                                                                                                                                                                                                                                                                      |
| 9 -        | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 8 -        | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 7 SMP      | CAN Bit Sampling Determines the sampling mode of CAN bits at the RX input. This field can be written in Freeze mode only; the module blocks it in other modes. For proper operation, to write 1to this field, you must guaranteeaminimumvalueoftwotime quanta in CTRL1[PSEG1] (or CBT[EPSEG1]).This bit cannot become 1 when CAN FD is enabled (MCR[FDEN] = 1). NOTE 0b - One sample is used to determine the bit value. 1b - Three samples are used to determine the value of the received bit: the regular one (sample point) and two preceding samples. A majority rule is used.                                            |
| 6 BOFFREC  | Bus Off Recovery Determines how FlexCAN recovers from Bus Off state. If 0, automatic recovering from Bus Off state occurs according to the CAN Specification 2.0B. If 1, automatic recovering from Bus Off is disabled. The module remains in Bus Off state until you write 1 to this field. If this field becomes 0 before 128 sequences of 11 recessive bits are detected on the CAN bus, Bus Off recovery happens as if this field had never become 1. If this field becomes 0 after 128 sequences of 11 recessive bits occurred, FlexCAN resynchronizes to the bus. It waits for 11 recessive bits before joining the bus. |

Table continues on the next page...

## Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|-------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|             | After this field becomes 0, it can become 1 again during Bus Off, but it will be effective only the next time the module enters Bus Off. If this field becomes 0 when the module is in Bus Off, writing 1 to this field is not effective for the current Bus Off recovery. See Bus Off in the CAN Protocol standard (ISO 11898-1:2015) for details. NOTE 0b - Enabled 1b - Disabled                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 5 TSYN      | Timer Sync Enables a mechanism that resets the free-running timer each time a message is received in message buffer 0. This feature provides the means to synchronize multiple FlexCAN stations with a special "SYNC" message (that is, global network time). If MCR[RFEN] = 1 (Legacy RX FIFO enabled), the first available message buffer, according to CTRL2[RFFN] is used for timer synchronization instead of MB0. This field can be written in Freeze mode only; the module blocks it in other modes. 0b - Disable 1b - Enable                                                                                                                                                                                                                                                                                               |
| 4 LBUF      | Lowest Buffer Transmitted First Determines the ordering mechanism for message buffer transmission. When 1, MCR[LPRIOEN] does not affect the priority arbitration. This field can be written in Freeze mode only; the module blocks it in other modes. 0b - Buffer with highest priority is transmitted first. 1b - Lowest number buffer is transmitted first.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 3 LOM       | Listen-Only Mode Configures FlexCAN to operate in Listen-Only mode. In this mode, transmission is disabled, all error counters described in Error Counter (ECR) are frozen, and the module operates in CAN Error Passive mode. Only messages acknowledged by another CAN station are received. If FlexCAN detects an unacknowledged message, it flags a BIT0 error without changing the receive error counter (ECR[RXERRCNT]), as if it was trying to acknowledge the message. The state of ESR1[FLTCONF] indicating Passive Error acknowledges Listen-Only mode. There can be some delay between the Listen-Only mode request and its acknowledgment. This field can be written in Freeze mode only; the module blocks it in other modes. 0b - Listen-Only mode is deactivated. 1b - FlexCAN module operates in Listen-Only mode. |
| 2-0 PROPSEG | Propagation Segment Defines the length of the propagation segment in the bit time. The valid programmable values are 0-;7. This field can be written only in Freeze mode; the module blocks it in other modes. Propagation segment time = (PROPSEG + 1)  Time Quanta.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                              |
|---------|---------------------------------------|
|         | One Time Quantum = one Sclock period. |

## 50.5.2.4 Free-Running Timer (TIMER)

## Offset

| Register   | Offset   |
|------------|----------|
| TIMER      | 8h       |

## Function

Represents a 16-bit free-running counter that the CPU can read and write. The timer starts from 0h after reset, counts linearly to FFFFh, and wraps around.

When CTRL2[TIMER\_SRC] = 1, an external time tick continuously increments the timer. The time tick must be synchronous to the peripheral clock, with a minimum pulse width of one clock cycle.

When CTRL2[TIMER\_SRC] = 0, the CAN bit clock increments the timer, which defines the baud rate on the CAN bus. During a message transmission or reception, it increments by one for each bit that is received or transmitted. When there is no message on the bus, it counts using the previously programmed baud rate. The timer is not incremented during Disable and Freeze modes.

The timer value is captured when the second bit of the identifier field of any frame is on the CAN bus. This captured value is written into the timestamp entry in a message buffer after a successful reception or transmission of a message.

If CTRL1[TSYN] = 1, the timer is reset whenever a message is received in the first available message buffer, according to CTRL2[RFFN].

The CPU can write to this register anytime. However, if the write occurs simultaneously with the timer being reset by a reception in the first message buffer, the write value is discarded.

Reading this register affects the message buffer unlocking procedure (see Message buffer lock mechanism).

## Diagram

<!-- image -->

| Bits   | 31    | 30    | 29    | 28    | 27    | 26    | 25    | 24    | 23    | 22    | 21    | 20    | 19    | 18    | 17    | 16    |
|--------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| R      | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |
| W      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |
| Reset  | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |
| Bits   | 15    | 14    | 13    | 12    | 11    | 10    | 9     | 8     | 7     | 6     | 5     | 4     | 3     | 2     | 1     | 0     |
| R      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |
| W      | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER | TIMER |
| Reset  | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |

## Fields

| Field   | Function                                 |
|---------|------------------------------------------|
| 31-16   | Reserved                                 |
| 15-0    | Timer Value                              |
| TIMER   | Contains the free-running counter value. |

## 50.5.2.5 RX Message Buffers Global Mask (RXMGMASK)

## Offset

| Register   | Offset   |
|------------|----------|
| RXMGMASK   | 10h      |

## Function

Mask the filter bits of all RX message buffers, excluding MBs 14-15, which have individual mask registers.

This register is located in RAM.

RXMGMASK is provided for legacy application support.

- When MCR[IRMQ] is 0, RXMGMASK is always in effect. The bits in RXMGMASK[MG] mask the MB filter bits).
- When MCR[IRMQ] is 1, RXMGMASK has no effect. The bits in RXMGMASK[MG] do not mask the MB filter bits.

This register can only be written in Freeze mode; the module blocks it in other modes.

## Diagram

<!-- image -->

## Fields

| Field   | Function                           |
|---------|------------------------------------|
| 31-0    | Global Mask for RX Message Buffers |

CAN (FlexCAN)

| Field   | Function                                                                                                                                                                                                                                                                                             | Function                                                                                                                                                                                                                                                                                             | Function                                                                                                                                                                                                                                                                                             | Function                                                                                                                                                                                                                                                                                             | Function                                                                                                                                                                                                                                                                                             | Function                                                                                                                                                                                                                                                                                             |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| MG      | Masks the message buffer filter bits. The alignment with the ID word of the message buffer is imperfect. The two most significant MGbits affect the fields RTRandIDE, which are located in the Control and Status word of the MB. The following table shows which MG bits mask each MB filter field. | Masks the message buffer filter bits. The alignment with the ID word of the message buffer is imperfect. The two most significant MGbits affect the fields RTRandIDE, which are located in the Control and Status word of the MB. The following table shows which MG bits mask each MB filter field. | Masks the message buffer filter bits. The alignment with the ID word of the message buffer is imperfect. The two most significant MGbits affect the fields RTRandIDE, which are located in the Control and Status word of the MB. The following table shows which MG bits mask each MB filter field. | Masks the message buffer filter bits. The alignment with the ID word of the message buffer is imperfect. The two most significant MGbits affect the fields RTRandIDE, which are located in the Control and Status word of the MB. The following table shows which MG bits mask each MB filter field. | Masks the message buffer filter bits. The alignment with the ID word of the message buffer is imperfect. The two most significant MGbits affect the fields RTRandIDE, which are located in the Control and Status word of the MB. The following table shows which MG bits mask each MB filter field. | Masks the message buffer filter bits. The alignment with the ID word of the message buffer is imperfect. The two most significant MGbits affect the fields RTRandIDE, which are located in the Control and Status word of the MB. The following table shows which MG bits mask each MB filter field. |
| MG      | SMB[RTR] 1                                                                                                                                                                                                                                                                                           | CTRL2[RRS]                                                                                                                                                                                                                                                                                           | N]                                                                                                                                                                                                                                                                                                   | CTRL2[EACE Message                                                                                                                                                                                                                                                                                   | CTRL2[EACE Message                                                                                                                                                                                                                                                                                   | CTRL2[EACE Message                                                                                                                                                                                                                                                                                   |
| MG      | SMB[RTR] 1                                                                                                                                                                                                                                                                                           | CTRL2[RRS]                                                                                                                                                                                                                                                                                           | N]                                                                                                                                                                                                                                                                                                   | MB[RTR] MB[IDE]                                                                                                                                                                                                                                                                                      | MB[ID]                                                                                                                                                                                                                                                                                               | Reserved                                                                                                                                                                                                                                                                                             |
| MG      | 0                                                                                                                                                                                                                                                                                                    | -                                                                                                                                                                                                                                                                                                    | 0                                                                                                                                                                                                                                                                                                    | note 2 note 3                                                                                                                                                                                                                                                                                        | MG[28:0]                                                                                                                                                                                                                                                                                             | MG[31:29]                                                                                                                                                                                                                                                                                            |
| MG      | 0                                                                                                                                                                                                                                                                                                    | -                                                                                                                                                                                                                                                                                                    | 1                                                                                                                                                                                                                                                                                                    | MG[31] MG[30]                                                                                                                                                                                                                                                                                        | MG[28:0]                                                                                                                                                                                                                                                                                             | MG[29]                                                                                                                                                                                                                                                                                               |
| MG      | 1                                                                                                                                                                                                                                                                                                    | 0                                                                                                                                                                                                                                                                                                    | - -                                                                                                                                                                                                                                                                                                  | -                                                                                                                                                                                                                                                                                                    | -                                                                                                                                                                                                                                                                                                    | MG[31:0]                                                                                                                                                                                                                                                                                             |
| MG      | 1                                                                                                                                                                                                                                                                                                    | 1                                                                                                                                                                                                                                                                                                    | 0 -                                                                                                                                                                                                                                                                                                  | -                                                                                                                                                                                                                                                                                                    | MG[28:0]                                                                                                                                                                                                                                                                                             | MG[31:29]                                                                                                                                                                                                                                                                                            |
| MG      | 1                                                                                                                                                                                                                                                                                                    | 1                                                                                                                                                                                                                                                                                                    | 1                                                                                                                                                                                                                                                                                                    | MG[31] MG[30]                                                                                                                                                                                                                                                                                        | MG[28:0]                                                                                                                                                                                                                                                                                             | MG[29]                                                                                                                                                                                                                                                                                               |

## 50.5.2.6 Receive 14 Mask (RX14MASK)

## Offset

| Register   | Offset   |
|------------|----------|
| RX14MASK   | 14h      |

## Function

Masks the filter fields of message buffer 14.

This register is located in RAM.

RX14MASK is provided for legacy application support. When MCR[IRMQ] = 1, RX14MASK has no effect.

This register can only be programmed when the module is in Freeze mode; the module blocks it in other modes.

## Diagram

<!-- image -->

| Bits    | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24    | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|---------|------|------|------|------|------|------|------|-------|------|------|------|------|------|------|------|------|
| R W     |      |      |      |      |      |      |      | RX14M |      |      |      |      |      |      |      |      |
| Reset   | u    | u    | u    | u    | u    | u    | u    | u     | u    | u    | u    | u    | u    | u    | u    | u    |
| Bits    | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8     | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R       |      |      |      |      |      |      |      | RX14M |      |      |      |      |      |      |      |      |
| W Reset | u    | u    | u    | u    | u    | u    | u    | u     | u    | u    | u    | u    | u    | u    | u    | u    |

## Fields

| Field   | Function                                                                                                                                                                                                                                                                             |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | RX Buffer 14 Mask Bits                                                                                                                                                                                                                                                               |
| RX14M   | Masks the corresponding message buffer 14 filter field in the same way that RX Message Buffers Global Mask (RXMGMASK) masks the filters of the other message buffers. 0b - The corresponding bit in the filter is "don't care." 1b - The corresponding bit in the filter is checked. |

## 50.5.2.7 Receive 15 Mask (RX15MASK)

## Offset

| Register   | Offset   |
|------------|----------|
| RX15MASK   | 18h      |

## Function

Masks the filter fields of message buffer 15.

This register is located in RAM.

RX15MASK is provided for legacy application support. When MCR[IRMQ] = 1, RX15MASK has no effect.

This register can be programmed only when the module is in Freeze mode; the module blocks it in other modes.

CAN (FlexCAN)

## Diagram

<!-- image -->

| Bits    | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24    | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|---------|------|------|------|------|------|------|------|-------|------|------|------|------|------|------|------|------|
| R W     |      |      |      |      |      |      |      | RX15M |      |      |      |      |      |      |      |      |
| Reset   | u    | u    | u    | u    | u    | u    | u    | u     | u    | u    | u    | u    | u    | u    | u    | u    |
| Bits    | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8     | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R       |      |      |      |      |      |      |      | RX15M |      |      |      |      |      |      |      |      |
| W Reset | u    | u    | u    | u    | u    | u    | u    | u     | u    | u    | u    | u    | u    | u    | u    | u    |

## Fields

| Field   | Function                                                                                                                                                                                                                                                                         |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | RX Buffer 15 Mask Bits                                                                                                                                                                                                                                                           |
| RX15M   | Masks the corresponding message buffer 15 filter field in the same way that RX Message Buffers Global Mask (RXMGMASK) masks the filters of other message buffers. 0b - The corresponding bit in the filter is "don't care." 1b - The corresponding bit in the filter is checked. |

## 50.5.2.8 Error Counter (ECR)

## Offset

| Register   | Offset   |
|------------|----------|
| ECR        | 1Ch      |

## Function

Contains error counters for received and transmitted messages.

TXERRCNT and RXERRCNT consider all errors in both CAN FD and non-FD message formats. TXERRCNT\_FAST and RXERRCNT\_FAST count only the errors that occur in the data phase of CAN FD frames that have BRS = 1.

The Fault Confinement state (ESR1[FLTCONF]) is updated based on TXERRCNT and RXERRCNT counters only. The rules for increasing and decreasing these counters are described in the CAN protocol and are entirely implemented in FlexCAN.

The basic rules for FlexCAN bus state transitions are:

- If the value of TXERRCNT or RXERRCNT becomes greater than or equal to 128, ESR1[FLTCONF] is updated to reflect Error Passive state.
- If the state of FlexCAN is Error Passive, and TXERRCNT or RXERRCNT decrements to a value less than 128 when the other already satisfies this condition, ESR1[FLTCONF] is updated to reflect Error Active state.
- If the value of TXERRCNT becomes greater than 255, ESR1[FLTCONF] is updated to reflect Bus Off state, and an interrupt may be issued. The value of TXERRCNT is then reset to zero.
- If FlexCAN is in Bus Off, TXERRCNT is cascaded with another internal counter to count the 128th occurrences of 11 consecutive recessive bits on the bus. TXERRCNT is reset to zero. It counts in a manner where the internal counter

CAN (FlexCAN)

counts 11 such bits and then wraps around when incrementing the TXERRCNT. When TXERRCNT reaches the value of 128, ESR1[FLTCONF] is updated to Error Active, and both error counters are reset to zero. Upon any instance of a dominant bit following a stream of less than 11 consecutive recessive bits, the internal counter resets itself to zero without affecting the TXERRCNT value. The TXERRCNT\_FAST counter is frozen during Bus Off.

- If only one node is operating during system startup, its TXERRCNT increases upon each attempted message transmission, as a result of acknowledge errors (indicated by ESR1[ACKERR]). After the transition to Error Passive state, TXERRCNT no longer increments upon acknowledge errors. The device never goes into the Bus Off state.
- If RXERRCNT increases to a value greater than 127, it is not incremented further, even if more errors are detected while being a receiver. At the next successful message reception, the counter is set to a value between 119 and 127 to return to the Error Active state.
- TXERRCNT\_FAST and RXERRCNT\_FAST error counter values increment and decrement based on errors detected only in the data phase of CAN FD frames that have BRS = 1. These counters follow the same increment and decrement rules as TXERRCNT and RXERRCNT. These counters do not wrap around and get stuck at their maximum value (255). They stop counting and keep their values frozen when FlexCAN is in Bus Off state. They are reset when FlexCAN leaves Bus Off state and resume counting after FlexCAN returns to the Error Active state.

See Fault confinement in the CAN Protocol standard (ISO 11898-1:2015) for details. NOTE

## Diagram

<!-- image -->

## Fields

| Field                | Function                                                                                                                                                                                                                         |
|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-24 RXERRCNT_F AST | Receive Error Counter for Fast Bits Counts errors detected in the data phase of received CAN FD messages that have BRS = 1. This field is read-only except in Freeze mode, where the CPU can write an 8-bit zero value only.     |
| 23-16 TXERRCNT_FA ST | Transmit Error Counter for Fast Bits Counts errors detected in the data phase of transmitted CAN FD messages that have BRS = 1. This field is read-only except in Freeze mode, where the CPU can write an 8-bit zero value only. |
| 15-8 RXERRCNT        | Receive Error Counter Counts all errors detected in received messages. This field is read-only except in Freeze mode, where the CPU can write to it.                                                                             |

Table continues on the next page...

Table continued from the previous page...

| Field    | Function                                                                                                                          |
|----------|-----------------------------------------------------------------------------------------------------------------------------------|
| 7-0      | Transmit Error Counter                                                                                                            |
| TXERRCNT | Counts all errors detected in transmitted messages. This field is read-only except in Freeze mode, where the CPU can write to it. |

## 50.5.2.9 Error and Status 1 (ESR1)

## Offset

| Register   | Offset   |
|------------|----------|
| ESR1       | 20h      |

## Function

Reports various error conditions detected in the reception and transmission of a CAN frame. This register provides some general status of the device, and is the source of some interrupts to the CPU. The reported error conditions are:

## NOTE

Reading host can clear these fields.

- Errors detected in CAN frames of any format:
- BIT1ERR
- BIT0ERR
- ACKKERR
- CRCERR
- FRMERR
- STFERR
- Errors detected in the data phase of CAN FD frames with the BRS bit set only:
- BIT1ERR\_FAST
- BIT0ERR\_FAST
- CRCERR\_FAST
- FRMERR\_FAST
- STFERR\_FAST

One or more error flags may report an error detected in a single CAN frame. To account for more error events occurring in subsequent frames when the CPU does not attempt to read this register, error reporting is cumulative.

## Status flags:

- TXWRN
- RXWRN
- IDLE
- TX

- FLTCONF
- RX
- SYNCH

## Interrupt flags:

- BOFFINT
- BOFFDONEINT
- ERRINT
- ERRINT\_FAST
- TWRNINT
- RWRNINT

The CPU should follow this procedure when servicing interrupt requests generated by these flags:

1. Read this register to capture all error condition and status flags. This action clears the respective flags that were set since the last read access.
2. Write 1 to clear the interrupt flag that triggered the interrupt request.
3. Write 1 to clear the ERROVR flag, if it is set.

Starting from all error flags cleared, a first error event sets either ERRINT or ERRINT\_FAST (provided the corresponding mask bit is 1). If other error events in subsequent frames occur before the CPU serves the interrupt request, the ERROVR flag is set to indicate that errors from different frames have accumulated.

## Table 372. CAN bus status

See Fault confinement in the CAN Protocol standard (ISO 11898-1:2015) for details. NOTE

|   SYNCH |   IDLE | TX   | RX   | FlexCAN state               |
|---------|--------|------|------|-----------------------------|
|       0 |      0 | 0    | 0    | Not synchronized to CAN bus |
|       1 |      1 | X    | X    | Idle                        |
|       1 |      0 | 1    | 0    | Transmitting                |
|       1 |      0 | 0    | 1    | Receiving                   |

## Diagram

<!-- image -->

| Bits   | 31          | 30          | 29      | 28          | 27          | 26          | 25     | 24     | 23   | 22   | 21      | 20          | 19          | 18       | 17       | 16       |
|--------|-------------|-------------|---------|-------------|-------------|-------------|--------|--------|------|------|---------|-------------|-------------|----------|----------|----------|
| R      | BIT1E RR... | BIT0E RR... | 0       | CRCE RR_... | FRME RR_... | STFE RR_... | 0      | 0      | 0    | 0    | ERRO VR | ERRIN T_... | BOFF DON... | SYNC H   | TWRN INT | RWRN INT |
| W      |             |             |         |             |             |             |        |        |      |      | W1C     | W1C         | W1C         |          | W1C      | W1C      |
| Reset  | 0           | 0           | 0       | 0           | 0           | 0           | 0      | 0      | 0    | 0    | 0       | 0           | 0           | 0        | 0        | 0        |
| Bits   | 15          | 14          | 13      | 12          | 11          | 10          | 9      | 8      | 7    | 6    | 5       | 4           | 3           | 2        | 1        | 0        |
| R      | BIT1E RR    | BIT0E RR    | ACKE RR | CRCE RR     | FRME RR     | STFE RR     | TXWR N | RXWR N | IDLE | TX   | FLTCONF | FLTCONF     | RX          | BOFFI NT | ERRIN T  | 0        |
| W      |             |             |         |             |             |             |        |        |      |      |         |             |             | W1C      | W1C      |          |
| Reset  | 0           | 0           | 0       | 0           | 0           | 0           | 0      | 0      | 0    | 0    | 0       | 0           | 0           | 0        | 0        | 0        |

CAN (FlexCAN)

## Fields

| Field            | Function                                                                                                                                                                                                                                                                                                                                                                        |
|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 BIT1ERR_FAS T | Fast Bit1 Error Flag Indicates when an inconsistency occurs between the transmitted and the received bit in the data phase of CAN FD frames that have BRS = 1. After a read operation, the field's value clears to 0. 0b - No such occurrence. 1b - At least one bit sent as recessive is received as dominant.                                                                 |
| 30 BIT0ERR_FAS T | Fast Bit0 Error Flag Indicates when an inconsistency occurs between the transmitted and the received bit in the data phase of CAN FD frames that have BRS = 1. After a read operation, the field's value clears to 0. 0b - No such occurrence. 1b - At least one bit sent as dominant is received as recessive.                                                                 |
| 29 -             | Reserved                                                                                                                                                                                                                                                                                                                                                                        |
| 28 CRCERR_FAS T  | Fast Cyclic Redundancy Check Error Flag Indicates that the receiver node has detected a CRC error in the CRC field of CAN FD frames that have BRS = 1. This error means that the calculated CRC is different from the received CRC. After a read operation, the field's value clears to 0. 0b - No such occurrence. 1b - A CRC error occurred since last read of this register. |
| 27 FRMERR_FAS T  | Fast Form Error Flag Indicates whether the receiver node has detected a form error in the data phase of CAN FD frames that have BRS = 1. This error means that a fixed-form bit field contains at least one illegal bit. After a read operation, the field's value clears to 0. 0b - No such occurrence. 1b - A form error occurred since last read of this register.           |
| 26 STFERR_FAST   | Fast Stuffing Error Flag Indicates that a stuffing error has been detected in the data phase of CAN FD frames that have BRS = 1. After a read operation, the field's value clears to 0. 0b - No such occurrence. 1b - A stuffing error occurred since last read of this register.                                                                                               |
| 25-22 -          | Reserved                                                                                                                                                                                                                                                                                                                                                                        |

Table continues on the next page...

Table continued from the previous page...

| Field          | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 21 ERROVR      | Error Overrun Flag Indicates that an error condition occurred when any error flag is already set. 0b - No overrun 1b - Overrun                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 20 ERRINT_FAST | Fast Error Interrupt Flag Indicates that at least one error flag detected in the data phase of CAN FD frames that have BRS = 1 (BIT1ERR_FAST, BIT0ERR_FAST, CRCERR_FAST, FRMERR_FAST, or STFERR_FAST) is set. If CTRL2[ERRMSK_FAST] = 1, an interrupt is generated to the CPU. 0b - No such occurrence. 1b - Error flag set in the data phase of CAN FD frames that have BRS = 1.                                                                                                                                                                                                                                             |
| 19 BOFFDONEINT | Bus Off Done Interrupt Flag Indicates whether ECR[TXERRCNT] has finished counting 128 occurrences of 11 consecutive recessive bits on the CAN bus and is ready to leave Bus Off. If CTRL2[BOFFDONEMSK] = 1, an interrupt is generated to the CPU. 0b - No such occurrence 1b - FlexCAN module has completed Bus Off process.                                                                                                                                                                                                                                                                                                  |
| 18 SYNCH       | CAN Synchronization Status Flag Indicates whether the FlexCAN is synchronized to the CANbusandabletoparticipate in the communication process. FlexCAN sets and clears this flag. See the table in Error and Status 1 (ESR1). 0b - Not synchronized 1b - Synchronized                                                                                                                                                                                                                                                                                                                                                          |
| 17 TWRNINT     | TX Warning Interrupt Flag Indicates whether TX error counter changed from less than 96 to greater than or equal to 96. IfMCR[WRNEN]=1, this flag is set when the TXWRNflag transitions from 0 to 1, meaning that the TX error counters reached 96. If CTRL1[TWRNMSK] = 1, an interrupt is sent to the CPU. When MCR[WRNEN] = 0, this flag is masked. The CPU must clear this flag before writing 0 to MCR[WRNEN]. Otherwise, this flag be set when MCR[WRNEN] = 1 again. Writing 0 has no effect. This flag is not generated while in the Bus Off state. This flag is not updated during Freeze mode. 0b - No such occurrence |
| 16 RWRNINT     | RX Warning Interrupt Flag Indicates whether the RX error counter changed from less than 96 to greater than or equal to 96. If MCR[WRNEN]=1,this flag is set when the RXWRNflagtransitions from 0 to 1, meaning that the RXerror counters reached 96. If CTRL1[RWRNMSK] = 1, an interrupt is sent to the CPU. When MCR[WRNEN] = 0,                                                                                                                                                                                                                                                                                             |

Table continues on the next page...

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | this flag is masked. The CPU must clear this flag before writing 0 to MCR[WRNEN]. Otherwise, this flag be set when MCR[WRNEN] = 1 again. Writing 0 has no effect. This flag is not updated during Freeze mode. 0b - No such occurrence 1b - RX error counter changed from less than 96 to greater than or equal to 96.                                                                                                                                                                                  |
| 15 BIT1ERR | Bit1 Error Flag Indicates when an inconsistency occurs between the transmitted and the received bit in a non-CAN FD message or in the arbitration or data phase of a CAN FD message. A transmitter does not set this flag for an arbitration field or ACK slot. It is not set for a node sending a passive error flag that detects dominant bits. NOTE After a read operation, the field's value clears to 0. 0b - No such occurrence. 1b - At least one bit sent as recessive is received as dominant. |
| 14 BIT0ERR | Bit0 Error Flag Indicates when an inconsistency occurs between the transmitted and the received bit in a non-CAN FD message or in the arbitration or data phase of a CAN FD message. After a read operation, the field's value clears to 0. 0b - No such occurrence. 1b - At least one bit sent as dominant is received as recessive.                                                                                                                                                                   |
| 13 ACKERR  | Acknowledge Error Flag Indicates whether the transmitter node has detected an Acknowledge Error. This error means that a dominant bit has not been detected during the ACK SLOT. After a read operation, the field's value clears to 0. 0b - No error 1b - An ACK error occurred since last read of this register.                                                                                                                                                                                      |
| 12 CRCERR  | Cyclic Redundancy Check Error Flag Indicates whether the receiver node has detected a Cyclic Redundancy Check (CRC) error either in a non-FD message or in the arbitration or data phase of a frame in CAN FD format. This error means that the calculated CRC is different from the received. After a read operation, the field's value clears to 0. 0b - No error 1b - A CRC error occurred since last read of this register.                                                                         |
| 11         | Form Error Flag                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |

Table continues on the next page...

## Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                                                                                                 |
|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FRMERR      | Indicates whether a form error has been detected in a non-FD message or in the arbitration or data phase of an FDmessagebythereceiver node. This error meansthat a fixed-form field contains at least one illegal bit. After a read operation, the field's value clears to 0. 0b - No error 1b - A Form Error occurred since last read of this register. |
| 10 STFERR   | Stuffing Error Flag Indicates that a stuffing error has been detected in a non-FD message or in the arbitration or data phase of an FD message by the receiver node. After a read operation, the field's value clears to 0. 0b - No error 1b - Error occurred since last read of this register.                                                          |
| 9 TXWRN     | TX Error Warning Flag Indicates when repetitive errors occur during message transmission. Only the value of ECR[TXERRCNT] affects this flag. This flag is not updated during Freeze mode. After a read operation, the field's value clears to 0. 0b - No such occurrence. 1b - TXERRCNT is 96 or greater.                                                |
| 8 RXWRN     | RX Error Warning Flag Indicates when repetitive errors occur during message reception. Only the value of ECR[RXERRCNT] affects this flag. This flag is not updated during Freeze mode. After a read operation, the field's value clears to 0. 0b - No such occurrence. 1b - RXERRCNT is greater than or equal to 96.                                     |
| 7 IDLE      | Idle Indicates whether CAN bus is in IDLE state. See Table 372. 0b - Not IDLE 1b - IDLE                                                                                                                                                                                                                                                                  |
| 6 TX        | FlexCAN In Transmission Indicates whether FlexCAN is transmitting a message. See Table 372. 0b - Not transmitting 1b - Transmitting                                                                                                                                                                                                                      |
| 5-4 FLTCONF | Fault Confinement State Indicates the confinement state of the FlexCAN module.                                                                                                                                                                                                                                                                           |

Table continues on the next page...

## Table continued from the previous page...

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|           | If CTRL1[LOM] = 1, after a delay that depends on the CAN bit timing, this field indicates Error Passive. The samedelay affects the waythat this field reflects an update to ECRregister by the CPU.It maybenecessary to wait up to one CAN bit time for coherence to be restored. Soft reset affects this field, but if CTRL1[LOM] = 1, its reset value lasts for only one CAN bit. After that time, this field reports Error Passive. 00b - Error Active 01b - Error Passive 1xb - Bus Off |
| 3 RX      | FlexCAN in Reception Flag Indicates whether FlexCAN is receiving a message. See the table in Error and Status 1 (ESR1). 0b - Not receiving 1b - Receiving                                                                                                                                                                                                                                                                                                                                   |
| 2 BOFFINT | Bus Off Interrupt Flag Indicates whether FlexCAN has entered Bus Off state. If CTRL1[BOFFMSK]) = 1, an interrupt is generated to the CPU. Writing 0 to this field has no effect. 0b - No such occurrence. 1b - FlexCAN module entered Bus Off state.                                                                                                                                                                                                                                        |
| 1 ERRINT  | Error Interrupt Flag Indicates that at least one of the error flags (ESR1[BIT1ERR], ESR1[BIT0ERR], ESR1[ACKERR], ESR1[CRCERR], ESR1[FRMERR], or ESR1[STFERR]) is set. If the corresponding mask CTRL1[ERRMSK] = 1, an interrupt is generated to the CPU. Writing 0 to this field has no effect. 0b - No such occurrence. 1b - Indicates setting of any error flag in the Error and Status register.                                                                                         |
| 0 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |

## 50.5.2.10 Interrupt Masks 2 (IMASK2)

## Offset

| Register   | Offset   |
|------------|----------|
| IMASK2     | 24h      |

## Function

Allows any of the 32 message buffer interrupts to be enabled or disabled for MB63 to MB32. It contains one interrupt mask bit per buffer. This configuration allows the CPU to determine which buffer generates an interrupt after a successful transmission or reception when the corresponding Interrupt Flags 2 (IFLAG2) flag is set.

## Diagram

<!-- image -->

| Bits    | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24         | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|---------|------|------|------|------|------|------|------|------------|------|------|------|------|------|------|------|------|
| R W     |      |      |      |      |      |      |      | BUF63TO32M |      |      |      |      |      |      |      |      |
| Reset   | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0          | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits    | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8          | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R       |      |      |      |      |      |      |      | BUF63TO32M |      |      |      |      |      |      |      |      |
| W Reset | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0          | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field           | Function                                                                                                                                                                                                                                                                                                                                      |
|-----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0 BUF63TO32M | Buffer MBi Mask Masks the corresponding FlexCAN message buffer interrupt for MB63-MB32. If the corresponding Interrupt Flags 2 (IFLAG2) flag is set, writing 1 or 0 to a field in IMASK2 can set or clear an interrupt request. NOTE 0b - The corresponding buffer interrupt is disabled. 1b - The corresponding buffer interrupt is enabled. |

## 50.5.2.11 Interrupt Masks 1 (IMASK1)

## Offset

| Register   | Offset   |
|------------|----------|
| IMASK1     | 28h      |

## Function

Masks interrupt flags. This register allows any of the 32 message buffer interrupts to be enabled or disabled for MB31 to MB0. It contains one interrupt mask bit per buffer. This configuration allows the CPU to determine which buffer generates an interrupt after a successful transmission or reception when the corresponding Interrupt Flags 1 (IFLAG1) flag is set.

CAN (FlexCAN)

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24        | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|-----------|------|------|------|------|------|------|------|------|
| R W    |      |      |      |      |      |      |      | BUF31TO0M |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8         | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      |      |      |      |      |      |      |      | BUF31TO0M |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field          | Function                                                                                                                                                                                                                                                                                                                                                      |
|----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0 BUF31TO0M | Buffer MBi Mask Enables or disables the corresponding FlexCAN message buffer interrupt for MB31 to MB0. If the corresponding Interrupt Flags 1 (IFLAG1) flag is set, writing 1 or 0 to a field in IMASK1 can set or clear an interrupt request. NOTE 0b - The corresponding buffer interrupt is disabled. 1b - The corresponding buffer interrupt is enabled. |

## 50.5.2.12 Interrupt Flags 2 (IFLAG2)

## Offset

| Register   | Offset   |
|------------|----------|
| IFLAG2     | 2Ch      |

## Function

Contains the flags for the 32 message buffer interrupts for MB63 to MB32. It contains one interrupt flag bit per buffer. Each successful transmission or reception sets the respective flag in this register. If the corresponding Interrupt Masks 2 (IMASK2) bit is set, an interrupt is generated.

Before updating MCR[MAXMB], the CPU must service the IFLAG2 flags whose MB value is greater than the MAXMB to be updated. Otherwise, those flags remain set and are inconsistent with the number of message buffers available.

CAN (FlexCAN)

## Diagram

<!-- image -->

| Bits   | 31         | 30         | 29         | 28         | 27         | 26         | 25         | 24         | 23         | 22         | 21         | 20         | 19         | 18         | 17         | 16         |
|--------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|
| R      | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I |
| W      | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        |
| Reset  | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          |
| Bits   | 15         | 14         | 13         | 12         | 11         | 10         | 9          | 8          | 7          | 6          | 5          | 4          | 3          | 2          | 1          | 0          |
| R      | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I | BUF63TO32I |
| W      | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        |
| Reset  | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          |

## Fields

| Field      | Function                                                                                                                                                                                                                                                            |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0       | Buffer MBi Interrupt                                                                                                                                                                                                                                                |
| BUF63TO32I | Flags the corresponding FlexCAN message buffer interrupt for MB63 to MB32. 0b - The corresponding buffer has no occurrence of successfully completed transmission or reception. 1b - The corresponding buffer has successfully completed transmission or reception. |

## 50.5.2.13 Interrupt Flags 1 (IFLAG1)

## Offset

| Register   | Offset   |
|------------|----------|
| IFLAG1     | 30h      |

## Function

Contains the flags for the 32 message buffer interrupts for MB31 to MB0. It contains one interrupt flag bit per buffer. Each successful transmission or reception sets the corresponding IFLAG1 bit. If the corresponding Interrupt Masks 1 (IMASK1) bit is set, an interrupt is generated. There is an exception when DMA for Legacy RX FIFO is enabled, as described below.

The BUF7I to BUF5I flags also represent Legacy FIFO interrupts when the Legacy RX FIFO is enabled. When MCR[RFEN] is 1 and MCR[DMA] is 0, the function of the eight least significant interrupt flags changes:

- BUF7I, BUF6I, and BUF5I indicate operating conditions of the Legacy FIFO.
- BUF4I to BUF1I fields are reserved.
- BUF0I empties the Legacy FIFO.

Before writing 1 to MCR[RFEN], the CPU must service the IFLAG flags set in the Legacy RX FIFO region; see Legacy RX FIFO. Otherwise, these IFLAG flags mistakenly show the related message buffers now belonging to Legacy FIFO as having contents to be serviced. When MCR[RFEN] is 0, the Legacy FIFO flags must be cleared. The same care must be taken when a CTRL2[RFFN] value is selected, extending Legacy RX FIFO filters beyond MB7. For example, when RFFN is 8h, Legacy RX FIFO filters occupy the MB0-23 range, and related IFLAG flags must be cleared.

CAN (FlexCAN)

When MCR[RFEN] and MCR[DMA] are 1 (DMA feature for Legacy RX FIFO enabled), the function of the eight least significant interrupt flags (BUF7I-BUF0I) changes to support DMA operation. BUF7I, BUF6I, and BUF4I-BUF1I are not used. BUF5I indicates operating condition of Legacy FIFO, and BUF0I empties the Legacy FIFO. Moreover, BUF5I does not generate a CPU interrupt, but it does generate a DMA request. IMASK1 bits in the Legacy RX FIFO region are not considered when bit MCR[DMA] = 1. In addition, the CPU must not clear the BUF5I flag when DMA is enabled. Before writing 1 to MCR[DMA], the CPU must service the IFLAG flags set in the Legacy RX FIFO region. When MCR[DMA] is 0, the Legacy FIFO must be empty. Legacy FIFO must be disabled when MCR[FDEN] = 1.

Before updating MCR[MAXMB], the CPU must service the IFLAG1 flags whose MB value is greater than the MCR[MAXMB] to be updated. Otherwise, those flags remain set and are inconsistent with the number of message buffers available.

## Diagram

<!-- image -->

## Fields

| Field          | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-8 BUF31TO8I | Buffer MBi Interrupt Flags the corresponding FlexCAN message buffer interrupt for MB31 to MB8. 0b - The corresponding buffer has no occurrence of successfully completed transmission or reception. 1b - The corresponding buffer has successfully completed transmission or reception.                                                                                                                                                                                                                                                                                                                                         |
| 7 BUF7I        | Buffer MB7 Interrupt or Legacy RX FIFO Overflow Flags the interrupt for MB7 when MCR[RFEN] = 0 (Legacy RX FIFO disabled). When a CPU write changes the value of MCR[RFEN], FlexCAN clears this flag. NOTE When MCR[RFEN] = 1, this flag represents a Legacy RXFIFO overflow. In this case, the flag indicates that a message was lost because the Legacy RX FIFO is full. When the Legacy RX FIFO is full and a message buffer captures the message, this flag is not set. 0b - No occurrence of MB7 completing transmission or reception, or no FIFO overflow. 1b - MB7 completed transmission or reception, or FIFO overflow. |
| 6 BUF6I        | Buffer MB6 Interrupt or Legacy RX FIFO Warning Flags the interrupt for MB6 when MCR[RFEN] = 0 (Legacy RX FIFO disabled).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |

Table continues on the next page...

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|              | When a CPU write changes the value of MCR[RFEN], FlexCAN clears this flag. NOTE When MCR[RFEN] = 1, this flag represents a Legacy RX FIFO warning. In this case, the flag indicates when the number of unread messages within the Legacy RX FIFO is increased to five from four due to the reception of a new message. In other words, the Legacy RX FIFO is almost full. If this flag is cleared when there are more than four unread messages, it does not set again until the number of unread messages in the Legacy RX FIFO decreases to four or fewer. 0b - No occurrence of MB6 completing transmission or reception, or FIFO not almost full. 1b - MB6 completed transmission or reception, or FIFO almost full. |
| 5 BUF5I      | Buffer MB5 Interrupt or Frames available in Legacy RX FIFO Flags the interrupt for MB5 when MCR[RFEN] = 0 (Legacy RX FIFO disabled). When a CPU write changes the value of MCR[RFEN], FlexCAN clears this flag. NOTE WhenMCR[RFEN]=1,theBUF5Iflag represents frames available in Legacy RXFIFO. In this case, the flag indicates that at least one frame is available to be read from the Legacy RX FIFO. When MCR[DMA] = 1, this flag generates a DMA request. The CPU must not clear this field by writing 1 to BUF5I. 0b - No occurrence of completed transmission or reception, or no frames available 1b - MB5 completed transmission or reception, or frames available                                             |
| 4-1 BUF4TO1I | Buffer MBi Interrupt or Reserved Flags the interrupts for MB4 to MB1 when MCR[RFEN] = 0 (Legacy RX FIFO disabled). When a CPU write changes the value of MCR[RFEN], FlexCAN clears these flags. NOTE When MCR[RFEN] = 1, the BUF4TO1I flags are reserved. 0b - The corresponding buffer has no occurrence of successfully completed transmission or reception. 1b - The corresponding buffer has successfully completed transmission or reception.                                                                                                                                                                                                                                                                       |
| 0 BUF0I      | Buffer MB0 Interrupt or Clear Legacy FIFO bit Flags the interrupt for MB0 when MCR[RFEN] = 0 (Legacy RX FIFO disabled). If MCR[RFEN] = 1, this field is used to trigger the clear Legacy FIFO operation. This operation empties the Legacy FIFO contents. Before performing this operation, the CPU must service all Legacy FIFO-related IFLAG flags. When MCR[DMA] = 1, this operation also clears the BUF5I flag, aborting the DMA request. The clear Legacy FIFO operation occurs when the CPUwrites 1 to BUF0I. This operation is only allowed in Freeze mode; the module blocks it in other conditions. 0b - MB0 has no occurrence of successfully completed transmission or reception.                             |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                       |
|---------|----------------------------------------------------------------|
|         | 1b - MB0 has successfully completed transmission or reception. |

## 50.5.2.14 Control 2 (CTRL2)

## Offset

| Register   | Offset   |
|------------|----------|
| CTRL2      | 34h      |

## Function

Complements Control 1 (CTRL1), providing control bits for memory write-access in Freeze mode. This register extends Legacy FIFO filter quantity, and adjusts the operation of internal FlexCAN processes such as matching and arbitration.

Soft reset does not affect the contents of this register.

Table 373 shows how the value of CTRL2[RFFN] determines the Legacy RX FIFO filter structure.

Table 373. Possible Legacy RX FIFO filter structures

| RFFN[3:0]   |   Number of Legacy RX FIFO filter elements | Message buffers occupied by Legacy RX FIFO and ID filter table   | Remaining available message buffers   | Legacy RX FIFO ID filter table elements affected by RX individual masks   | Legacy RX FIFO ID filter table elements affected by Legacy RX FIFO global mask   |
|-------------|--------------------------------------------|------------------------------------------------------------------|---------------------------------------|---------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| 0h          |                                          8 | MB 0-7                                                           | MB 8-127                              | Elements 0-7                                                              | none                                                                             |
| 1h          |                                         16 | MB 0-9                                                           | MB 10-127                             | Elements 0-9                                                              | Elements 10-15                                                                   |
| 2h          |                                         24 | MB 0-11                                                          | MB 12-127                             | Elements 0-11                                                             | Elements 12-23                                                                   |
| 3h          |                                         32 | MB 0-13                                                          | MB 14-127                             | Elements 0-13                                                             | Elements 14-31                                                                   |
| 4h          |                                         40 | MB 0-15                                                          | MB 16-127                             | Elements 0-15                                                             | Elements 16-39                                                                   |
| 5h          |                                         48 | MB 0-17                                                          | MB 18-127                             | Elements 0-17                                                             | Elements 18-47                                                                   |
| 6h          |                                         56 | MB 0-19                                                          | MB 20-127                             | Elements 0-19                                                             | Elements 20-55                                                                   |
| 7h          |                                         64 | MB 0-21                                                          | MB 22-127                             | Elements 0-21                                                             | Elements 22-63                                                                   |
| 8h          |                                         72 | MB 0-23                                                          | MB 24-127                             | Elements 0-23                                                             | Elements 24-71                                                                   |
| 9h          |                                         80 | MB 0-25                                                          | MB 26-127                             | Elements 0-25                                                             | Elements 26-79                                                                   |
| Ah          |                                         88 | MB 0-27                                                          | MB 28-127                             | Elements 0-27                                                             | Elements 28-87                                                                   |
| Bh          |                                         96 | MB 0-29                                                          | MB 30-127                             | Elements 0-29                                                             | Elements 30-95                                                                   |
| Ch          |                                        104 | MB 0-31                                                          | MB 32-127                             | Elements 0-31                                                             | Elements 32-103                                                                  |
| Dh          |                                        112 | MB 0-33                                                          | MB 34-127                             | Elements 0-31                                                             | Elements 32-111                                                                  |
| Eh          |                                        120 | MB 0-35                                                          | MB 36-127                             | Elements 0-31                                                             | Elements 32-119                                                                  |
| Fh          |                                        128 | MB 0-37                                                          | MB 38-127                             | Elements 0-31                                                             | Elements 32-127                                                                  |

## Diagram

<!-- image -->

| Bits   | 31          | 30          | 29      | 28          | 27        | 26   | 25   | 24       | 23        | 22   | 21   | 20   | 19   | 18   | 17   | 16     |
|--------|-------------|-------------|---------|-------------|-----------|------|------|----------|-----------|------|------|------|------|------|------|--------|
| R W    | ERRM SK_... | BOFF DON... | ECRW RE | WRMF RZ     |           | RFFN | RFFN | RFFN     |           | TASD | TASD | TASD |      | MRP  | RRS  | EACE N |
| Reset  | 0           | 0           | 0       | 0           | 0         | 0    | 0    | 0        | 0         | 0    | 0    | 1    | 0    | 0    | 0    | 0      |
| Bits   | 15          | 14          | 13      | 12          | 11        | 10   | 9    | 8        | 7         | 6    | 5    | 4    | 3    | 2    | 1    | 0      |
| R W    | TIMER       | PREX CEN    | BTE     | ISOCA NF... | EDFLT DIS | 0    |      | MBTSBASE | TSTAMPCAP |      | 0    | 0    | 0    | 0    | 0    | 0      |
| Reset  | _S... 0     | 0           | 0       | 0           | 0         | 0    | 0 0  | 0 0      | 0         | 0    | 0    | 0    | 0    | 0    | 0    | 0      |

## Fields

| Field           | Function                                                                                                                                                                                                                                                                                                                                                  |
|-----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 ERRMSK_FAS T | Error Interrupt Mask for Errors Detected in the Data Phase of Fast CAN FD Frames Enables the ESR1[ERRINT_FAST] interrupt. 0b - Disable 1b - Enable                                                                                                                                                                                                        |
| 30 BOFFDONEMS K | Bus Off Done Interrupt Mask Enables the Bus Off Done interrupt, ESR1[BOFFDONEINT]. 0b - Disable 1b - Enable                                                                                                                                                                                                                                               |
| 29 ECRWRE       | Error Correction Configuration Register Write Enable Enables updates for Memory Error Control (MECR). If the protocol described in Detection and correction of memory errors is not followed, this field is automatically 0. 0b - Disable 1b - Enable                                                                                                     |
| 28 WRMFRZ       | Write Access to Memory in Freeze Mode Enables unrestricted write access to FlexCAN memory in Freeze mode. When this field is 0, write access restrictions are maintained. This field can only be written in Freeze mode, and has no effect out of Freeze mode. Do not write 1 to MCR[RFEN] during FlexCAN memory initialization. 0b - Disable 1b - Enable |
| 27-24 RFFN      | Number of Legacy Receive FIFO Filters Defines the number of Receive Legacy FIFO filters, as shown in Table 373. The chip determines the maximum selectable number of filters. Do not program this field with values that cause the number of                                                                                                              |

Table continues on the next page...

CAN (FlexCAN)

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | message buffers occupied by Legacy RX FIFO and Legacy RX FIFO ID Filter to exceed MCR[MAXMB]. MCR[MAXMB] defines the number of message buffers present. This field can only be written in Freeze mode; the module blocks it in other modes. Each group of eight filters occupies a memory space equivalent to two message buffers. The more filters are implemented, the fewer message buffers are available. The Legacy RX FIFO occupies the memory space originally reserved for MB0-5. This field should be programmed with a value corresponding to a number of filters less than the number of available memory words. The number of available words can be calculated as follows: (SETUP_MB - 6)  4 Where SETUP_MB is the smaller of the parameter NUMBER_OF_MB and MCR[MAXMB]. The number of remaining message buffers available is: (SETUP_MB - 8) - (RFFN  2) If the number of Legacy RX FIFO filters programmed through RFFN exceeds the SETUP_MB value (memory space available), the exceeding ones are not functional.  The number of the last remaining available message buffers is the smaller of (NUMBER_OF_MB - 1) and MCR[MAXMB].  If RX Individual Mask registers are not enabled, the Legacy RX FIFO Global Mask affects all Legacy RX FIFO filters. NOTE |
| 23-19 TASD | Transmission Arbitration Start Delay Indicates by how many CAN bits the transmission arbitration process start point can be delayed from the first bit of CRC field on CAN bus. See TX arbitration start delay for details. This field can be written only in Freeze mode; the module blocks it in other modes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 18 MRP     | Message Buffers Reception Priority Sets the priority for the matching process. This field can be written only in Freeze mode; the module blocks it in other modes. 0b - Matching starts from Legacy RX FIFO or Enhanced RX FIFO and continues on message buffers. 1b - Matching starts from message buffers and continues on Legacy RX FIFO or Enhanced RX FIFO.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 17 RRS     | Remote Request Storing Determines what the module does with a remote request. The remote request frame is submitted to a matching process. If this field is 1, the frame is stored in the corresponding message buffer in the samefashion as a data frame. No automatic remote response frame is generated. If this field is 0, an automatic remote response frame is generated if a message buffer with CODE = 1010b is found with the same ID.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |

Table continues on the next page...

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|              | This bit can be written only in Freeze mode. The module blocks it in other modes. 0b - Generated 1b - Stored                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 16 EACEN     | Entire Frame Arbitration Field Comparison Enable for RX Message Buffers Controls the comparison of IDE and RTRfields within RXmessagebuffer filters with their corresponding bits in the incoming frame by the matching process. If enabled, the IDE and RTRfields of the RXmessagebuffer are compared to their corresponding bits within the incoming frame (mask bits apply). If disabled, the IDE field of the RX message buffer filter is always compared and RTR is never compared despite mask bits. This field does not affect matching for Legacy RX FIFO or Enhanced RX FIFO. This field can be written only in Freeze mode; the module blocks it in other modes. 0b - Disable 1b - Enable |
| 15 TIMER_SRC | Timer Source Selects the time tick source used for incrementing the free-running timer counter. If CAN bit clock is selected, it defines the baud rate on the CAN bus. If External time tick is selected, the period can be adjusted to match the baud rate on the CAN bus. It could also be adjusted to a different value as required. See the device-specific section for details about the external time tick. This field can be written in Freeze mode only. 0b - CAN bit clock 1b - External time tick                                                                                                                                                                                         |
| 14 PREXCEN   | Protocol Exception Enable Enables the protocol exception feature. This field is writable only in Freeze mode. See Protocol exception event in the CANProtocol standard (ISO 11898-1:2015) for details. NOTE 0b - Disabled 1b - Enabled                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 13 BTE       | Bit Timing Expansion Enable Enables the use of Enhanced CAN Bit Timing Prescalers (EPRS), Enhanced Data Phase CAN Bit Timing (EDCBT), and Enhanced Nominal CAN Bit Timing (ENCBT) to configure the CAN bit timing segments, instead of using the bit timing fields of CAN Bit Timing (CBT), CAN FD Bit Timing (FDCBT), and Control 1 (CTRL1). If this field is 1:                                                                                                                                                                                                                                                                                                                                   |

Table continues on the next page...

Table continued from the previous page...

| Field         | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|---------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|               |  CTRL1[PRESDIV], CTRL1[PROPSEG], CTRL1[PSEG1], CTRL1[PSEG2], and CTRL1[RJW] are read as zero. A write operation to these fields has no effect.  CBT[EPRESDIV], CBT[ERJW], CBT[EPROPSEG], CBT[EPSEG1], and CBT[EPSEG2], and the corresponding fields in CAN FD Bit Timing (FDCBT), are read as zero. A write operation to these fields has no effect.  ETDC[ETDCOFF], ETDC[ETDCEN], ETDC[ETDCFAIL], and ETDC[ETDCVAL] are used by FlexCAN instead of FDCTRL[TDCOFF], FDCTRL[TDCEN], FDCTRL[TDCFAIL], and FDCTRL[TDCVAL]. These fields are read as zero, and a write operation to them has no effect.  ETDC[TDMDIS] can be used to disable transceiver delay measurement. 0b - Disable 1b - Enable      |
| 12 ISOCANFDEN | ISO CAN FD Enable Enables the CAN FD protocol according to ISO specification (ISO 11898-1:2015) (see CAN FD ISO compliance). This field is writable only in Freeze mode. FlexCAN is able to transmit FD frame format according to CAN Protocol standard (ISO 11898-1:2015). NOTE 0b - Disable. FlexCAN operates using the non-ISO CAN FD protocol. 1b - Enable. FlexCAN operates using the ISO CAN FD protocol (ISO 11898-1:2015).                                                                                                                                                                                                                                                                        |
| 11 EDFLTDIS   | Edge Filter Disable Disables the edge filter used during the Bus Integration state. When the Edge Filter is enabled, two consecutive nominal time quanta with dominant bus states are required to detect an edge that causes synchronization. When synchronization occurs, the counting of the sequence of eleven consecutive recessive bits is restarted. The edge filter prevents dominant pulses that are shorter than a nominal bit time (present during the data phase of an FD frame) from being mistaken for an idle condition. This field is writable only in Freeze mode. See Bus Integration state in the CAN Protocol standard (ISO 11898-1:2015) for details. NOTE 0b - Enabled 1b - Disabled |
| 10 -          | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 9-8           | Message Buffer Timestamp Base                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |

Table continues on the next page...

## Table continued from the previous page...

| Field         | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|---------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| MBTSBASE      | Selects the timebase used for capturing the 16-bit TIME_STAMP field of the message buffer register. This field can be written in Freeze Mode only. 00b - TIMER 01b - Lower 16 bits of high-resolution timer 10b - Upper 16 bits of high-resolution timer 11b - Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 7-6 TSTAMPCAP | Timestamp Capture Point Configures the point in time when a 32-bit timebase is captured during a CAN frame. This base is stored in the high-resolution timestamp register (HR_TIME_STAMP). For classical CAN frames, capture points can be the start-of-frame bit or the point when CAN frame is considered valid. This point is the seventh bit of the end-of-frame for transmission and the sixth bit of the end-of-frame for reception. For CAN FD frames, the high-resolution timestamp can be captured at the start of frame, when a CAN FD frame is considered valid, or the res bit. This field can be written in Freeze mode only. 00b - Disabled 01b - End of the CAN frame 10b - Start of the CAN frame 11b - Start of frame for classical CAN frames; res bit for CAN FD frames |
| 5 -           | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 4-2 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 1-0 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |

## 50.5.2.15 Error and Status 2 (ESR2)

## Offset

| Register   | Offset   |
|------------|----------|
| ESR2       | 38h      |

## Function

Reports general status information.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | LPTM | LPTM | LPTM | LPTM | LPTM | LPTM | LPTM |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | VPS  | IMB  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| W      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-23 -    | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 22-16 LPTM | Lowest Priority TX Message Buffer Indicates the lowest number inactive message bufferwhen ESR2[VPS] = 1 (see ESR2[IMB]). If no message buffer is inactive, the message buffer indicated depends on the value of CTRL1[LBUF]. If CTRL1[LBUF] = 0, the message buffer indicated is the one with the greatest arbitration value (see Highest-priority message buffer first). If CTRL1[LBUF] = 1, the message buffer indicated is the active TX message buffer with the highest number. If a TX message buffer is being transmitted, it is not considered in the LPTMcalculation. If ESR2[IMB] is not 0 and a frame is transmitted successfully, the value of LPTM is updated with its message buffer number.                                                                                                                                                                                                                       |
| 15 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 14 VPS     | Valid Priority Status Indicates whether the contents of ESR2[IMB] and ESR2[LPTM]arevalid. Itbecomes1uponeverycomplete TX arbitration process, unless the CPU writes to the Control and Status word of a message buffer already scanned. In other words, it is behind the TX Arbitration Pointer, during the TX arbitration process. If there is no inactive message buffer and only one TX message buffer that is being transmitted, this field remains 0. This field becomes 0 upon the start of every TX arbitration process or upon a write to the Control and Status word of any message buffer. No CPU write to the Control and Status of a message buffer that the abort mechanism blocks affects this field. WhenMCR[AEN]=1,theabort code write to the Control and Status of an MB being transmitted (pending abort) is blocked. Any write attempt to a TX MB with its IFLAG flag set is also blocked. NOTE 0b - Invalid |

Table continues on the next page...

CAN (FlexCAN)

## Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 13 IMB  | Inactive Message Buffer Indicates whether any message buffer is inactive (CODE field is either 1000b or 0b) when ESR2[VPS] = 1. This field becomes 1 when:  A lowest-priority TX message buffer (ESR2[LPTM]) is found and it is inactive during arbitration.  This field is not 1, and a frame is transmitted successfully. This field always becomes 0 at the start of arbitration (see Arbitration process). If a message buffer is successfully transmitted and this field is 0 (no inactive message buffer), ESR2[VPS] and this field both become 1. The index related to the MB transmitted is loaded into ESR2[LPTM]. In this case, the value of ESR2[LPTM] is the number of the first inactive message buffer. 0b - Message buffer indicated by ESR2[LPTM] is not inactive. 1b - At least one message buffer is inactive. |
| 12 -    | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 11-0 -  | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |

## 50.5.2.16 Cyclic Redundancy Check (CRCR)

## Offset

| Register   | Offset   |
|------------|----------|
| CRCR       | 44h      |

## Function

Provides information about the CRC of transmitted messages for non-FD messages. This register only reports the 15 low-order bits of CRC calculations for messages in CAN FD format that require either 17 or 21 bits. For CAN FD format frames, you must use the CAN FD CRC (FDCRC). This register is updated at the same time that the TX interrupt flag is set.

## NOTE

See CRC sequence calculation in the CAN Protocol standard (ISO 11898-1:2015) for details.

## Diagram

<!-- image -->

| Bits   | 31   | 30    | 29    | 28    | 27    | 26    | 25    | 24    | 23    | 22    | 21    | 20    | 19    | 18    | 17    | 16    |
|--------|------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| R      |      |       |       |       | 0     |       |       |       |       | MBCRC | MBCRC | MBCRC | MBCRC | MBCRC | MBCRC | MBCRC |
| W      |      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |
| Reset  | 0    | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |
| Bits   | 15   | 14    | 13    | 12    | 11    | 10    | 9     | 8     | 7     | 6     | 5     | 4     | 3     | 2     | 1     | 0     |
| R      | 0    | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC | TXCRC |
| W      |      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |
| Reset  | 0    | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |

## Fields

| Field       | Function                                                                                                                                                     |
|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-23 -     | Reserved                                                                                                                                                     |
| 22-16 MBCRC | CRC Message Buffer Indicates the number of the message buffer corresponding to the value in CRCR[TXCRC].                                                     |
| 15 -        | Reserved                                                                                                                                                     |
| 14-0 TXCRC  | Transmitted CRC value Indicates the CRC value of the last transmitted message for non-FD frames. For FD frames, CRC value is reported in CAN FD CRC (FDCRC). |

## 50.5.2.17 Legacy RX FIFO Global Mask (RXFGMASK)

## Offset

| Register   | Offset   |
|------------|----------|
| RXFGMASK   | 48h      |

## Function

This register is located in RAM.

Masks the Legacy RX FIFO ID filter table elements that do not have a corresponding RXIMR according to CTRL2[RFFN], when Legacy RX FIFO is enabled.

This register can only be written in Freeze mode; the module blocks it in other modes.

The following table shows how the FGM bits correspond to each IDAF field.

CAN (FlexCAN)

Table 374. Correspondence of Legacy RX FIFO global mask bits to IDF fields

| Legacy RX FIFO ID filter table elements format (MCR[IDAM])   | Identifier acceptance filter fields   | Identifier acceptance filter fields   | Identifier acceptance filter fields   | Identifier acceptance filter fields   | Identifier acceptance filter fields         | Identifier acceptance filter fields   |
|--------------------------------------------------------------|---------------------------------------|---------------------------------------|---------------------------------------|---------------------------------------|---------------------------------------------|---------------------------------------|
| Legacy RX FIFO ID filter table elements format (MCR[IDAM])   | RTR                                   | IDE                                   | RXIDA                                 | RXIDB 1                               | RXIDC 2                                     | Reserved                              |
| A                                                            | FGM[31]                               | FGM[30]                               | FGM[29:1]                             | -                                     | -                                           | FGM[0]                                |
| B                                                            | FGM[31], FGM[15]                      | FGM[30], FGM[14]                      | -                                     | FGM[29:16], FGM[13:0]                 | -                                           | -                                     |
| C                                                            | -                                     | -                                     | -                                     | -                                     | FGM[31:24], FGM[23:16], FGM[15:8], FGM[7:0] | -                                     |

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| W      | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  | FGM  |
| Reset  | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    |

## Fields

| Field   | Function                                                                                                                                                                       |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | Legacy RX FIFO Global Mask Bits                                                                                                                                                |
| FGM     | Masks the ID filter table elements bits in a perfect alignment. 0b - The corresponding bit in the filter is "don't care." 1b - The corresponding bit in the filter is checked. |

## 50.5.2.18 Legacy RX FIFO Information (RXFIR)

## Offset

| Register   | Offset   |
|------------|----------|
| RXFIR      | 4Ch      |

## Function

Provides information about Legacy RX FIFO.

This register is the port through which the CPU accesses the output of the Legacy RXFIR FIFO located in RAM. FlexCAN writes to the Legacy RXFIR FIFO when a new message is moved into the Legacy RX FIFO. Also, its output is updated whenever the output of the Legacy RX FIFO is updated with the next message. See Legacy RX FIFO for instructions on reading this register.

| Bits   | 31      | 30      | 29      | 28      | 27      | 26      | 25      | 24      | 23      | 22      | 21      | 20      | 19      | 18      | 17      | 16      |
|--------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|
| R      | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |
| W      |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |
| Reset  | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       |
| Bits   | 15      | 14      | 13      | 12      | 11      | 10      | 9       | 8       | 7       | 6       | 5       | 4       | 3       | 2       | 1       | 0       |
| R      | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT | 0 IDHIT |
| W      |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |
| Reset  | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       | u       |

<!-- image -->

## Fields

| Field     | Function                                                                                                                                                                                                                                                                                                                                              |
|-----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-9 -    | Reserved                                                                                                                                                                                                                                                                                                                                              |
| 8-0 IDHIT | Identifier Acceptance Filter Hit Indicator Indicates which Identifier Acceptance filter that the received message hit in the output of the Legacy RX FIFO. If multiple filters match the incoming message ID, the first matching IDAF found (lowest number) by the matching process is indicated. This field is valid only when IFLAG1[BUF5I] is set. |

## 50.5.2.19 CAN Bit Timing (CBT)

## Offset

| Register   | Offset   |
|------------|----------|
| CBT        | 50h      |

## Function

Provides an alternative way to store the CAN bit timing variables described in Control 1 (CTRL1). EPRESDIV, EPROPSEG, EPSEG1, EPSEG2, and ERJW are extended versions of CTRL1[PRESDIV], CTRL1[PROPSEG], CTRL1[PSEG1], CTRL1[PSEG2], and CTRL1[RJW] respectively.

CAN (FlexCAN)

## NOTE

The CAN bit variables in CTRL1 and in CBT are stored in the same register.

CBT[BTF] selects the use of the timing variables defined in this register.

When the CAN FD feature is enabled (MCR[FDEN] = 1), always write 1 to CBT[BTF].

Soft reset does not affect the contents of this register.

## NOTE

Ensure that bit time settings and protocol engine tolerance are in compliance with the CAN Protocol standard (ISO 11898-1:2015).

## NOTE

If CTRL2[BTE] = 1, EPRESDIV, ERJW, EPROPSEG, EPSEG1, and EPSEG2 are read as zero. A write operation to them has no effect.

<!-- image -->

## Fields

| Field          | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 BTF         | Bit Timing Format Enable Enables the use of extended CAN bit timing fields EPRESDIV, EPROPSEG, EPSEG1, EPSEG2, and ERJW. These fields replace the CAN bit timing variables defined in Control 1 (CTRL1). This field can be written in Freeze mode only. 0b - Disable 1b - Enable                                                                                                                                                                                                                                                    |
| 30-21 EPRESDIV | Extended Prescaler Division Factor Defines the ratio between the PE clock frequency and the serial clock (Sclock) frequency when CBT[BTF] = 1, otherwise it has no effect. It extends the CTRL1[PRESDIV] value range. The Sclock period defines the time quantum of the CANprotocol. For the reset value, the Sclock frequency is equal to the PE clock frequency (see Protocol timing). This field can be written only in Freeze mode; the module blocks it in other modes. Sclock frequency = PE clock frequency  (EPRESDIV + 1) |

Table continues on the next page...

## Table continued from the previous page...

| Field          | Function                                                                                                                                                                                                                                                                                                                                                                |
|----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 20-16 ERJW     | Extended Resync Jump Width Defines the maximum number of time quanta that one resynchronization can change a bit time when CBT[BTF] = 1. Otherwise, it has no effect. It extends the CTRL1[RJW] value range. This field can be written only in Freeze mode; the module blocks it in other modes. Resync Jump Width = ERJW + 1. One Time Quantum = one Sclock period.    |
| 15-10 EPROPSEG | Extended Propagation Segment Defines the length of the propagation segment in the bit time when CBT[BTF] = 1, otherwise it has no effect. It extends the CTRL1[PROPSEG] value range. This field can be written only in Freeze mode; the module blocks it in other modes. Propagation Segment Time = (EPROPSEG + 1)  Time Quanta. One Time Quantum = one Sclock period. |
| 9-5 EPSEG1     | Extended Phase Segment 1 Defines the length of phase segment 1 in the bit time when CBT[BTF] = 1, otherwise it has no effect. It extends the CTRL1[PSEG1] value range. This field can be written only in Freeze mode; the module blocks it in other modes. Phase Buffer Segment 1 = (EPSEG1 + 1)  Time Quanta. One Time Quantum = one Sclock period.                   |
| 4-0 EPSEG2     | Extended Phase Segment 2 Defines the length of phase segment 2 in the bit time when CBT[BTF] = 1, otherwise it has no effect. It extends the CTRL1[PSEG2] value range. This field can be written only in Freeze mode; the module blocks it in other modes. Phase Buffer Segment 1 = (EPSEG2 + 1)  Time Quanta. One Time Quantum = one Sclock period.                   |

## 50.5.2.20 Interrupt Masks 4 (IMASK4)

## Offset

| Register   | Offset   |
|------------|----------|
| IMASK4     | 68h      |

## Function

Enables or disables any number of the 32 message buffer interrupts for MB127 to MB96. It contains one interrupt mask bit per buffer. This configuration allows the CPU to determine which buffer generates an interrupt after a successful transmission or reception when the corresponding IFLAG4 flag is set.

## Diagram

<!-- image -->

| Bits    | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24          | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|---------|------|------|------|------|------|------|------|-------------|------|------|------|------|------|------|------|------|
| R W     |      |      |      |      |      |      |      | BUF127TO96M |      |      |      |      |      |      |      |      |
| Reset   | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0           | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits    | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8           | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R       |      |      |      |      |      |      |      | BUF127TO96M |      |      |      |      |      |      |      |      |
| W Reset | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0           | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field            | Function                                                                                                                                                                                                                                                                                                                                                                                                                       |
|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0 BUF127TO96M | Buffer MBi Mask Enables or disables the corresponding FlexCAN message buffer interrupt for MB127 to MB96. When CAN FD is enabled, the MB range is defined in accordance with FDCTRL[MBDSRn]. If the corresponding IFLAG4 flag is set, writing 1 or 0 to a field in IMASK4 can set or clear an interrupt request. NOTE 0b - The corresponding buffer interrupt is disabled. 1b - The corresponding buffer interrupt is enabled. |

## 50.5.2.21 Interrupt Masks 3 (IMASK3)

## Offset

| Register   | Offset   |
|------------|----------|
| IMASK3     | 6Ch      |

## Function

Enables or disables any number of the 32 message buffer interrupts for MB95 to MB64. It contains one interrupt mask bit per buffer. This configuration allows the CPU to determine which buffer generates an interrupt after a successful transmission or reception when the corresponding IFLAG3 flag is set.

CAN (FlexCAN)

## Diagram

<!-- image -->

| Bits    | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24         | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|---------|------|------|------|------|------|------|------|------------|------|------|------|------|------|------|------|------|
| R W     |      |      |      |      |      |      |      | BUF95TO64M |      |      |      |      |      |      |      |      |
| Reset   | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0          | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits    | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8          | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R       |      |      |      |      |      |      |      | BUF95TO64M |      |      |      |      |      |      |      |      |
| W Reset | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0          | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field           | Function                                                                                                                                                                                                                                                                                                                                                                                                                      |
|-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0 BUF95TO64M | Buffer MBi Mask Enables or disables the corresponding FlexCAN message buffer interrupt for MB95 to MB64. When CAN FD is enabled, the MB range is defined in accordance with FDCTRL[MBDSRn]. If the corresponding IFLAG3 flag is set, writing 1 or 0 to a field in IMASK3 can set or clear an interrupt request. NOTE 0b - The corresponding buffer interrupt is disabled. 1b - The corresponding buffer interrupt is enabled. |

## 50.5.2.22 Interrupt Flags 4 (IFLAG4)

## Offset

| Register   | Offset   |
|------------|----------|
| IFLAG4     | 70h      |

## Function

Defines the flags for the 32 message buffer interrupts for MB127 to MB96. It contains one interrupt flag per buffer. Each successful transmission or reception sets the corresponding IFLAG4 flag. If the corresponding IMASK4 bit is 1, an interrupt is generated. The interrupt flag must be cleared by writing 1 to it. Writing 0 has no effect.

Before updating MCR[MAXMB], the CPU must service the IFLAG4 flags whose MB value is greater than the MAXMB to be updated. Otherwise, they remain set and are inconsistent with the number of message buffers available.

CAN (FlexCAN)

## Diagram

<!-- image -->

| Bits   | 31         | 30         | 29         | 28         | 27         | 26         | 25         | 24         | 23         | 22         | 21         | 20         | 19         | 18         | 17         | 16         |
|--------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|------------|
| R      | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 |
| W      | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        |
| Reset  | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          |
| Bits   | 15         | 14         | 13         | 12         | 11         | 10         | 9          | 8          | 7          | 6          | 5          | 4          | 3          | 2          | 1          | 0          |
| R      | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 | BUF127TO96 |
| W      | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        | W1C        |
| Reset  | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          | 0          |

## Fields

| Field           | Function                                                             |
|-----------------|----------------------------------------------------------------------|
| 31-0 BUF127TO96 | Buffer MBi Interrupt Flags the corresponding the MB range is defined |

## 50.5.2.23 Interrupt Flags 3 (IFLAG3)

## Offset

| Register   | Offset   |
|------------|----------|
| IFLAG3     | 74h      |

## Function

Defines the flags for the 32 message buffer interrupts for MB95 to MB64. It contains one interrupt flag bit per buffer. Each successful transmission or reception sets the corresponding IFLAG3 flag. If the corresponding IMASK3 bit is 1, an interrupt is generated. The interrupt flag must be cleared by writing 1 to it. Writing 0 has no effect.

Before updating MCR[MAXMB], the CPU must service the IFLAG3 flags whose MB value is greater than the MAXMB to be updated. Otherwise, they remain set and are inconsistent with the number of message buffers available.

CAN (FlexCAN)

## Diagram

<!-- image -->

| Bits   | 31        | 30        | 29        | 28        | 27        | 26        | 25        | 24        | 23        | 22        | 21        | 20        | 19        | 18        | 17        | 16        |
|--------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|
| R      | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 |
| W      | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       |
| Reset  | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         |
| Bits   | 15        | 14        | 13        | 12        | 11        | 10        | 9         | 8         | 7         | 6         | 5         | 4         | 3         | 2         | 1         | 0         |
| R      | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 | BUF95TO64 |
| W      | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       | W1C       |
| Reset  | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         | 0         |

## Fields

| Field     | Function                                                                                                                                                                                                                                                                                                                                              |
|-----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0      | Buffer MBi Interrupt                                                                                                                                                                                                                                                                                                                                  |
| BUF95TO64 | Flags the corresponding FlexCAN message buffer interrupt for MB95 to MB64.When CAN FD is enabled, the MB range is defined in accordance with FDCTRL[MBDSRn]. 0b - The corresponding buffer has no occurrence of successfully completed transmission or reception. 1b - The corresponding buffer has successfully completed transmission or reception. |

## 50.5.2.24 Receive Individual Mask (RXIMR0 - RXIMR127)

## Offset

For n = 0 to 127:

| Register   | Offset          |
|------------|-----------------|
| RXIMRn     | 880h + (n  4h) |

## Function

Stores the acceptance masks for ID filtering in RX message buffers and the Legacy RX FIFO.

When the Legacy RX FIFO is disabled (MCR[RFEN] = 0), an individual mask is provided for each available RX message buffer on a one-to-one correspondence. When the Legacy RX FIFO is enabled (MCR[RFEN] = 1), an individual mask is provided for each Legacy RX FIFO ID filter table element on a one-to-one correspondence. This correspondence depends on the setting of CTRL2[RFFN] (see Legacy RX FIFO).

RXIMR0 stores the individual mask associated with either MB0 or ID filter table element 0. RXIMR1 stores the individual mask associated with either MB1 or ID filter table element 1, and so on.

The CPU can only access the RXIMR registers when the module is in Freeze mode; otherwise, the module blocks them. Reset does not affect these registers. They are located in RAM and must be explicitly initialized prior to any reception.

It is possible for the RXIMR memory region to be accessed as general-purpose memory. See Bus interface for more information.

CAN (FlexCAN)

## Diagram

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R W    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R W    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    | u    |

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                          |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-0 MI | Individual Mask Bits Masks the corresponding bit in both the message buffer filter and Legacy RX FIFO ID filter table element in distinct ways. For message buffer filters, see RX Message Buffers Global Mask (RXMGMASK). For Legacy RX FIFO ID filter table elements, see Legacy RX FIFO Global Mask (RXFGMASK). 0b - The corresponding bit in the filter is "don't care." 1b - The corresponding bit in the filter is checked. |

## 50.5.2.25 Memory Error Control (MECR)

## Offset

| Register   | Offset   |
|------------|----------|
| MECR       | AE0h     |

## Function

Contains control bits for memory error detection and correction (ECC).

## NOTE

When CTRL2[ECRWRE] = 0, writes to this register are blocked, except for MECR[ECRWRDIS].

CAN (FlexCAN)

## Diagram

<!-- image -->

## Fields

| Field       | Function                                                                                                                                                                                                                                                           |
|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 ECRWRDIS | Error Configuration Register Write Disable Disables writes on this register. This field automatically becomes 1 (disabled) when CTRL2[ECRWRE] is 1. The protocol described in Detection and correction of memory errors must be followed. 0b - Enable 1b - Disable |
| 30-20 -     | Reserved                                                                                                                                                                                                                                                           |
| 19 -        | Reserved When writing to this field, always write the reset value.                                                                                                                                                                                                 |
| 18 -        | Reserved When writing to this field, always write the reset value.                                                                                                                                                                                                 |
| 17 -        | Reserved                                                                                                                                                                                                                                                           |
| 16 -        | Reserved When writing to this field, always write the reset value.                                                                                                                                                                                                 |
| 15 HAERRIE  | Host Access Error Injection Enable Enables the injection of errors only in memory reads issued by the host (CPU). 0b - Disable 1b - Enable                                                                                                                         |
| 14          | FlexCAN Access Error Injection Enable                                                                                                                                                                                                                              |

Table continues on the next page...

CAN (FlexCAN)

## Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|-------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FAERRIE     | Enables the injection of errors only in memory reads issued by FlexCAN internal processes. 0b - Disable 1b - Enable                                                                                                                                                                                                                                                                                                                                                                   |
| 13 EXTERRIE | Extended Error Injection Enable Extends the error injection on 32-bit memory accesses to the complementary 32-bit word. This feature uses the same 32-bit error injection data and parity words used for 64-bit memory accesses performed by internal FlexCAN processes. See Error Injection Data Pattern (ERRIDPR) and Error Injection Parity Pattern (ERRIPPR). 0b - Disable. Apply error injection only to the 32-bit word. 1b - Enable. Apply error injection to the 64-bit word. |
| 12-10 -     | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 9 RERRDIS   | Error Report Disable Disables the update of the error report registers. The update of error-related flags and the generation of bus transfer errors are still active. When reading the report registers, this field must be 1 to assure coherence on the consecutive register reads. NOTE 0b - Enable 1b - Disable                                                                                                                                                                    |
| 8 ECCDIS    | Error Correction Disable Disables completely the memory detection and correction mechanism. Besides disabling the error report mechanism, it also stops the update of the error-related flags and the generation of bus transfer errors. The parity bits continue to be calculated and written into memory on write transactions. 0b - Enable 1b - Disable                                                                                                                            |
| 7 NCEFAFRZ  | Non-Correctable Errors in FlexCAN Access Put Device in Freeze Mode Determines the response whenanon-correctable errorisdetectedinamemoryreadperformedbyFlexCAN internal processes. In this case, entering Freeze mode prevents corrupted data from being treated as valid by FlexCAN internal processes. 0b - Keep normal operation. 1b - Put FlexCAN in Freeze mode (see section "Freeze mode").                                                                                     |
| 6-0 -       | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

## 50.5.2.26 Error Injection Address (ERRIAR)

## Offset

| Register   | Offset   |
|------------|----------|
| ERRIAR     | AE4h     |

## Function

Contains the address where error is to be injected.

Use the following table to convert from the memory map address to the location in the physical FlexCAN RAM. (Where pairs of values are provided, the first is the address for MCR[FDEN] = 0, the second is for MCR[FDEN] = 1.)

Table 375. Error injection address for classical CAN format

| RAM contents       | Injection address   | Memory map    |
|--------------------|---------------------|---------------|
| FlexCAN registers  | Not mapped          | -             |
| Message buffers    | 0000h               | 0080h         |
| RXIMRs             | 1000h               | 0880h         |
| RXFIR_0            | 1200h               | 0A80h         |
| RXFIR_1            | 1204h               | 0A84h         |
| RXFIR_2            | 1208h               | 0A88h         |
| RXFIR_3            | 120Ch               | 0A8Ch         |
| RXFIR_4            | 1210h               | 0A90h         |
| RXFIR_5            | 1214h               | 0A94h         |
| Reserved           | -                   | 0A98h         |
| RXMGMASK           | 1220h               | 0AA0h         |
| RXFGMASK           | 1224h               | 0AA4h         |
| RX14MASK           | 1228h               | 0AA8h         |
| RX15MASK           | 122Ch               | 0AACh         |
| Tx_SMB             | 1230h               | 0AB0h / 0F28h |
| Rx_SMB0            | 1240h / 1278h       | 0AC0h / 0F70h |
| Rx_SMB1            | 1250h / 12C0h       | 0AD0h / 0FB8h |
| Rx_SMB0_TIME_STAMP | 1308h               | 0C20h         |
| Rx_SMB1_TIME_STAMP | 130Ch               | 0C24h         |
| HR_TIME_STAMP      | 1310h               | 0C30h         |
| Enhanced MB memory | 800h                | 1000h         |
| Enhanced RX FIFO   | 1510h               | 2000h         |
| ERFFEL             | 1F10h               | 3000h         |

CAN (FlexCAN)

<!-- image -->

## Fields

| Field          | Function                                                                                                                                                                                          |
|----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-14 -        | Reserved                                                                                                                                                                                          |
| 13-2 INJADDR_H | Error Injection Address High Defines the twelve most significant bits of the physical RAM address where error is to be injected (see table above).                                                |
| 1-0 INJADDR_L  | Error Injection Address Low Defines the two least significant bits of the physical RAM address where error is to be injected. These bits ensure that the address is on a thirty-two-bit boundary. |

## 50.5.2.27 Error Injection Data Pattern (ERRIDPR)

## Offset

| Register   | Offset   |
|------------|----------|
| ERRIDPR    | AE8h     |

## Function

Contains the error pattern to be injected in the data word read from memory.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| R W    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| R W    |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function                                                                                                                              |
|---------|---------------------------------------------------------------------------------------------------------------------------------------|
| 31-0    | Data Flip Pattern                                                                                                                     |
| DFLIP   | Contains the flip pattern. Bits set to 1 in the flip pattern cause the corresponding data bit in the word read from memory to invert. |

## 50.5.2.28 Error Injection Parity Pattern (ERRIPPR)

## Offset

| Register   | Offset   |
|------------|----------|
| ERRIPPR    | AECh     |

## Function

Contains the error pattern to be injected in parity bits read from memory with the data word. Bits set to 1 in the flip pattern cause the corresponding parity bit in the word read from memory to invert.

## Diagram

<!-- image -->

CAN (FlexCAN)

## Fields

| Field        | Function                                           |
|--------------|----------------------------------------------------|
| 31-29 -      | Reserved                                           |
| 28-24 PFLIP3 | Parity Flip Pattern for Byte 3 (Most Significant)  |
| 23-21 -      | Reserved                                           |
| 20-16 PFLIP2 | Parity Flip Pattern for Byte 2                     |
| 15-13 -      | Reserved                                           |
| 12-8 PFLIP1  | Parity Flip Pattern for Byte 1                     |
| 7-5 -        | Reserved                                           |
| 4-0 PFLIP0   | Parity Flip Pattern for Byte 0 (Least Significant) |

## 50.5.2.29 Error Report Address (RERRAR)

## Offset

| Register   | Offset   |
|------------|----------|
| RERRAR     | AF0h     |

## Function

Reports the address used for an access operation in which an error (correctable or non-correctable) was detected. Also reports the identification of the source of that access.

This address is always reported using a 32-bit alignment. Non-aligned accesses (ERRADDR[1:0] nonzero) are reported with the address aligned, and data is reported in RERRDR shifted accordingly. When errors are detected in accesses larger than 32-bit (as performed by FlexCAN internal processes), the address of the 32-bit word where the error was detected is reported. For errors detected in more than one 32-bit word, only the least significant address is reported.

Table 376. Source of memory access

| SAID[2:0]   | Error during...         |
|-------------|-------------------------|
| 0           | Move-out FlexCAN access |
| 1           | Move-in                 |
| 2           | TX arbitration          |
| 3           | RX matching             |
| 4           | Move-out host access    |
| 5-7         | Reserved                |

## Diagram

<!-- image -->

| Bits   | 31      | 30      | 29      | 28      | 27      | 26      | 25      | 24      | 23      | 22      | 21      | 20      | 19      | 18      | 17      | 16      |
|--------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|
| R      | 0       | 0       | 0       | 0       | 0       | 0       | 0       | NCE     | 0       | 0       | 0       | 0       | 0       | SAID    | SAID    | SAID    |
| W      |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |
| Reset  | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |
| Bits   | 15      | 14      | 13      | 12      | 11      | 10      | 9       | 8       | 7       | 6       | 5       | 4       | 3       | 2       | 1       | 0       |
| R      | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR | ERRADDR |
| W      |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |         |
| Reset  | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |

## Fields

| Field      | Function                                                                                                                                                                                       |
|------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-25 -    | Reserved                                                                                                                                                                                       |
| 24 NCE     | Non-Correctable Error Indicates that the report is due to a non-correctable error. 0b - Reporting a correctable error 1b - Reporting a non-correctable error                                   |
| 23-19 -    | Reserved                                                                                                                                                                                       |
| 18-16 SAID | SAID SAID[2] - Identification of the requester of the memory read request:  0 = Requested by FlexCAN internal processes  1 = Requested by host (CPU) SAID[1] - Details of FlexCAN operation: |

Table continues on the next page...

## Table continued from the previous page...

| Field        | Function                                                                                                                                              |
|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
|              |  0 = Move  1 = Scanning SAID[0] - Operation that requested the memory read:  0 = Transmission  1 = Reception For more information, see Table 376. |
| 15-14 -      | Reserved                                                                                                                                              |
| 13-0 ERRADDR | Address Where Error Detected See description of Error Injection Address (ERRIAR).                                                                     |

## 50.5.2.30 Error Report Data (RERRDR)

## Offset

| Register   | Offset   |
|------------|----------|
| RERRDR     | AF4h     |

## Function

Reports the raw data (unmodified by the correction performed by ECC logic) read from memory with error. The value reported does not represent the transient values of the BUSY bit (see Table 382) when reading a message buffer.

## Diagram

<!-- image -->

| Bits   | 31    | 30    | 29    | 28    | 27    | 26    | 25    | 24    | 23    | 22    | 21    | 20    | 19    | 18    | 17    | 16    |
|--------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| R      | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA |
| W      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |
| Reset  | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |
| Bits   | 15    | 14    | 13    | 12    | 11    | 10    | 9     | 8     | 7     | 6     | 5     | 4     | 3     | 2     | 1     | 0     |
| R      | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA | RDATA |
| W      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |
| Reset  | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |

## Fields

| Field   | Function                                  |
|---------|-------------------------------------------|
| 31-0    | Raw Data Word Read from Memory with Error |
| RDATA   |                                           |

## 50.5.2.31 Error Report Syndrome (RERRSYNR)

## Offset

| Register   | Offset   |
|------------|----------|
| RERRSYNR   | AF8h     |

## Function

Contains the syndrome detected in a memory read with error. It also reports the bytes which were read in this 32-bit read transaction.

Each SYNDn field indicates the type of error and which bit in byte (n) the error affects. (SYND3 corresponds to the most significant byte in the data word read from memory; SYND0 corresponds to the least significant.)

Table 377. Syndrome definition

| SYNDn (hex)   | Type   | Bit affected                     |
|---------------|--------|----------------------------------|
| 00            | -      | none (no error)                  |
| 01            | Code   | 0                                |
| 02            | Code   | 1                                |
| 04            | Code   | 2                                |
| 07            | Data   | 5                                |
| 08            | Code   | 3                                |
| 0E            | Data   | 7                                |
| 10            | Code   | 4                                |
| 13            | Data   | 2                                |
| 15            | Data   | 6                                |
| 16            | Data   | 1                                |
| 19            | Data   | 3                                |
| 1A            | Data   | 4                                |
| 1C            | Data   | 0                                |
| 06            | -      | All-zeroes non-correctable error |
| 1F            | -      | All-ones non-correctable error   |
| All others    | -      | Non-correctable error            |

Each BEn field indicates which byte in the 32-bit word reported was effectively read. The syndrome bits are calculated for all bytes, including the non-read ones. Errors detected in non-read bytes are indicated (see Error indication) and reported (see Error reporting).

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28    | 27    | 26    | 25    | 24    | 23   | 22   | 21   | 20    | 19    | 18    | 17    | 16    |
|--------|------|------|------|-------|-------|-------|-------|-------|------|------|------|-------|-------|-------|-------|-------|
| R      | BE3  | 0    | 0    | SYND3 | SYND3 | SYND3 | SYND3 | SYND3 | BE2  | 0    | 0    | SYND2 | SYND2 | SYND2 | SYND2 | SYND2 |
| W      |      |      |      |       |       |       |       |       |      |      |      |       |       |       |       |       |
| Reset  | 0    | 0    | 0    | 0     | 0     | 0     | 0     | 0     | 0    | 0    | 0    | 0     | 0     | 0     | 0     | 0     |
| Bits   | 15   | 14   | 13   | 12    | 11    | 10    | 9     | 8     | 7    | 6    | 5    | 4     | 3     | 2     | 1     | 0     |
| R      | BE1  | 0    | 0    | SYND1 | SYND1 | SYND1 | SYND1 | SYND1 | BE0  | 0    | 0    | SYND0 | SYND0 | SYND0 | SYND0 | SYND0 |
| W      |      |      |      |       |       |       |       |       |      |      |      |       |       |       |       |       |
| Reset  | 0    | 0    | 0    | 0     | 0     | 0     | 0     | 0     | 0    | 0    | 0    | 0     | 0     | 0     | 0     | 0     |

## Fields

| Field       | Function                                                                               |
|-------------|----------------------------------------------------------------------------------------|
| 31 BE3      | Byte Enabled for Byte 3 (Most Significant) 0b - Byte was not read. 1b - Byte was read. |
| 30-29 -     | Reserved                                                                               |
| 28-24 SYND3 | Error Syndrome for Byte 3 (Most Significant) See Table 377.                            |
| 23 BE2      | Byte Enabled for Byte 2 0b - Byte was not read. 1b - Byte was read.                    |
| 22-21 -     | Reserved                                                                               |
| 20-16 SYND2 | Error Syndrome for Byte 2 See Table 377.                                               |
| 15 BE1      | Byte Enabled for Byte 1 0b - Byte was not read. 1b - Byte was read.                    |
| 14-13       | Reserved                                                                               |

Table continues on the next page...

Table continued from the previous page...

| Field      | Function                                                                                |
|------------|-----------------------------------------------------------------------------------------|
| -          |                                                                                         |
| 12-8 SYND1 | Error Syndrome for Byte 1 See Table 377.                                                |
| 7 BE0      | Byte Enabled for Byte 0 (Least Significant) 0b - Byte was not read. 1b - Byte was read. |
| 6-5 -      | Reserved                                                                                |
| 4-0 SYND0  | Error Syndrome for Byte 0 (Least Significant) See Table 377.                            |

## 50.5.2.32 Error Status (ERRSR)

## Offset

| Register   | Offset   |
|------------|----------|
| ERRSR      | AFCh     |

## Function

Contains the status bits of the error correction and detection operations. These flags can be cleared by writing 1 to them. Writing 0 has no effect.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19        | 18        | 17   | 16    |
|--------|------|------|------|------|------|------|------|------|------|------|------|------|-----------|-----------|------|-------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | HANC EIF  | FANC EIF  | 0    | CEIF  |
| W      |      |      |      |      |      |      |      |      |      |      |      |      | W1C       | W1C       |      | W1C   |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0         | 0    | 0     |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3         | 2         | 1    | 0     |
| R      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | HANC EIOF | FANC EIOF | 0    | CEIOF |
| W      |      |      |      |      |      |      |      |      |      |      |      |      | W1C       | W1C       |      | W1C   |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0         | 0    | 0     |

## Fields

| Field      | Function                                                                                                                                                                                                                                                                                                                |
|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-20 -    | Reserved                                                                                                                                                                                                                                                                                                                |
| 19 HANCEIF | Host Access with Noncorrectable Error Interrupt Flag Indicates that a noncorrectable error was detected in a memory read initiated by host. A bus transfer error is asserted for that access. No interrupt is associated with this flag. 0b - No errors detected 1b - Error detected                                    |
| 18 FANCEIF | FlexCAN Access with Non-Correctable Error Interrupt Flag Indicates that a non-correctable error was detected in a memory read initiated by FlexCAN internal processes. No interrupt is associated with this flag. 0b - No errors detected 1b - Error detected                                                           |
| 17 -       | Reserved                                                                                                                                                                                                                                                                                                                |
| 16 CEIF    | Correctable Error Interrupt Flag Indicates that a correctable error was detected in a memory read. 0b - No errors detected 1b - Error detected                                                                                                                                                                          |
| 15-4 -     | Reserved                                                                                                                                                                                                                                                                                                                |
| 3 HANCEIOF | Host Access With Non-Correctable Error Interrupt Overrun Flag Indicates that a non-correctable error was detected in a memory read initiated by host when ERRSR[HANCEIF] was set. No interrupt is associated with this flag. See Error indication. 0b - No errors detected 1b - Error detected                          |
| 2 FANCEIOF | FlexCAN Access with Non-Correctable Error Interrupt Overrun Flag Indicates that a non-correctable error was detected in a memory read initiated by FlexCAN internal processes when ERRSR[FANCEIF] was set. No interrupt is associated with this flag. See Error indication. 0b - No errors detected 1b - Error detected |
| 1 -        | Reserved                                                                                                                                                                                                                                                                                                                |

Table continues on the next page...

Table continued from the previous page...

| Field   | Function                                                                                                                                                                                                |
|---------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0       | Correctable Error Interrupt Overrun Flag                                                                                                                                                                |
| CEIOF   | Indicates that a correctable error was detected in a memory read when ERRSR[CEIF] was set. No interrupt is associated with this flag. See Error indication. 0b - No errors detected 1b - Error detected |

## 50.5.2.33 Enhanced CAN Bit Timing Prescalers (EPRS)

## Offset

| Register   | Offset   |
|------------|----------|
| EPRS       | BF0h     |

## Function

Defines the CAN bit timing prescalers for the nominal phase and data phase when CTRL2[BTE] = 1.

Used by the module only if CTRL2[BTE] = 1; otherwise a write operation has no effect and all fields are read as 0.

This register can be written only in Freeze mode; the module blocks it in other modes.

Soft reset does not affect the contents of this register.

## Diagram

<!-- image -->

| Bits   | 31   | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21        | 20   | 19   | 18   | 17   | 16   |
|--------|------|------|------|------|------|------|------|------|------|------|-----------|------|------|------|------|------|
| R      | 0    | 0    | 0    | 0    | 0    | 0    |      |      |      |      | EDPRESDIV |      |      |      |      |      |
| W      |      |      |      |      |      |      |      |      |      |      |           |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0    | 0    | 0    |
| Bits   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5         | 4    | 3    | 2    | 1    | 0    |
| R      | 0    | 0    | 0    | 0    | 0    | 0    |      |      |      |      | ENPRESDIV |      |      |      |      |      |
| W      |      |      |      |      |      |      |      |      |      |      |           |      |      |      |      |      |
| Reset  | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0         | 0    | 0    | 0    | 0    | 0    |

## Fields

| Field   | Function   |
|---------|------------|
| 31-26   | Reserved   |

Table continues on the next page...

## Table continued from the previous page...

| Field           | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|-----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 25-16 EDPRESDIV | Extended Data Phase Prescaler Division Factor Defines the ratio between the PE clock frequency and the Sclock frequency in the data phase of a CAN FD message when CTRL2[BTE] = 1. The Sclock period defines the time quantum of the CAN FD protocol for the data bit rate. Sclock frequency = PE clock frequency  (EDPRESDIV + 1). To minimize errors when processing FD frames, use the same value for this field and for EPRS[ENPRESDIV]. See the first note in CAN FD frames for details. NOTE |
| 15-10 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 9-0 ENPRESDIV   | Extended Nominal Prescaler Division Factor Defines the ratio between the PE clock frequency and the Sclock frequency when CTRL2[BTE] = 1. Otherwise, it reads as 0 and a write operation has no effect. The Sclock period defines the time quantum of the CAN protocol in the nominal phase. For the reset value, the Sclock frequency is equal to the PE clock frequency (see Protocol timing). Sclock frequency = PE clock frequency  (ENPRESDIV + 1)                                            |

## 50.5.2.34 Enhanced Nominal CAN Bit Timing (ENCBT)

## Offset

| Register   | Offset   |
|------------|----------|
| ENCBT      | BF4h     |

## Function

Provides an alternative way to store the CAN bit timing variables described in Control 1 (CTRL1) and CAN Bit Timing (CBT), to get higher CAN bit timing resolution.

This register is used by the module only if CTRL2[BTE] = 1. Otherwise, a write operation has no effect and all fields are read as zero.

Soft reset does not affect the contents of this register.

This register can be written only in Freeze mode; the module blocks it in other modes.

## Diagram

<!-- image -->

| Bits   | 31            | 30   | 29   | 28   | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | 19   | 18   | 17     | 16   |
|--------|---------------|------|------|------|------|------|------|------|------|------|------|------|------|------|--------|------|
| R      | 0             |      |      |      |      |      |      |      |      |      | 0    |      |      |      |        |      |
| W      |               |      |      |      |      |      | NRJW |      |      |      |      |      |      |      | NTSEG2 |      |
| Reset  | 0             | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0      | 0    |
| Bits   | 15            | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1      | 0    |
| R      | 0             |      |      |      |      |      |      |      |      |      |      |      |      |      |        |      |
| W      | NTSEG2 NTSEG1 |      |      |      |      |      |      |      |      |      |      |      |      |      |        |      |
| Reset  | 0             | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0      | 0    |

## Fields

| Field        | Function                                                                                                                                                                                                                                                              |
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-29 -      | Reserved                                                                                                                                                                                                                                                              |
| 28-22 NRJW   | Nominal Resynchronization Jump Width Defines the maximum number of time quanta that one resynchronization can change a nominal bit time when CTRL2[BTE] = 1. Otherwise, it has no effect. One time quantum = one Sclock period. Nominal Resync Jump Width = NRJW + 1. |
| 21-19 -      | Reserved                                                                                                                                                                                                                                                              |
| 18-12 NTSEG2 | Nominal Time Segment 2 Defines the length of Time Segment 2 in the nominal bit time when CTRL2[BTE] = 1. Otherwise, it has no effect. Nominal Time Segment 2 = (NTSEG2 + 1)  Time Quanta. One time quantum = one Sclock period.                                      |
| 11-8 -       | Reserved                                                                                                                                                                                                                                                              |
| 7-0 NTSEG1   | Nominal Time Segment 1 Defines the length of Time Segment 1 in the bit time when CTRL2[BTE] = 1. Otherwise, it has no effect. Nominal Time Segment 1 = (NTSEG1 + 1)  Time Quanta. One time quantum = one Sclock period.                                              |

CAN (FlexCAN)

## 50.5.2.35 Enhanced Data Phase CAN Bit Timing (EDCBT)

## Offset

| Register   | Offset   |
|------------|----------|
| EDCBT      | BF8h     |

## Function

Provides an alternative way to store the data phase CAN bit timing variables described in CAN FD Bit Timing (FDCBT) to achieve higher CAN bit timing resolution.

This register is used by the module only if CTRL2[BTE] = 1; otherwise a write operation has no effect and all fields are read as zero.

Soft reset does not affect the contents of this register.

This register can be written only in Freeze mode; the module blocks it in other modes.

NOTE

<!-- image -->

## Fields

| Field   | Function                                                                                                                                                                                         |
|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-26 - | Reserved                                                                                                                                                                                         |
| 25-22   | Data Phase Resynchronization Jump Width                                                                                                                                                          |
| DRJW    | Defines the maximum number of time quanta that one resynchronization can change a data phase bit time when CTRL2[BTE] = 1. Otherwise, it has no effect. Data Phase Resync Jump Width = DRJW + 1. |

Table continues on the next page...

CAN (FlexCAN)

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                  |
|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 21-16 -      | Reserved                                                                                                                                                                                                                                  |
| 15-12 DTSEG2 | Data Phase Time Segment 2 Defines the length of time segment 2 in the data phase bit time when CTRL2[BTE] = 1. Otherwise, it has no effect. Data Phase Time Segment 2 = (DTSEG2 + 1)  Time Quanta. One Time Quantum = one Sclock period. |
| 11-5 -       | Reserved                                                                                                                                                                                                                                  |
| 4-0 DTSEG1   | Data Phase Segment 1 Defines the length of time segment 1 in the data phase bit time when CTRL2[BTE] = 1. Otherwise, it has no effect. Data Phase Time Segment 1 = (NTSEG1 + 1)  Time Quanta. One Time Quantum = one Sclock period.      |

## 50.5.2.36 Enhanced Transceiver Delay Compensation (ETDC)

## Offset

| Register   | Offset   |
|------------|----------|
| ETDC       | BFCh     |

## Function

Contains extended versions of FDCTRL[TDCOFF] and FDCTRL[TDCVAL]. This register is used by the module only if CTRL2[BTE] = 1. Otherwise, a write operation has no effect and all fields are read as zero.

## NOTE

See Transmitter delay compensation in the CAN Protocol standard (ISO 11898-1:2015) for details.

## Diagram

<!-- image -->

| Bits   | 31        | 30      | 29   | 28   | 27   | 26   | 25   | 24   | 23      | 22      | 21      | 20      | 19      | 18      | 17      | 16      |
|--------|-----------|---------|------|------|------|------|------|------|---------|---------|---------|---------|---------|---------|---------|---------|
| R W    | ETDC EN   | TDMDI S | 0    | 0    | 0    | 0    | 0    | 0    | 0       | ETDCOFF | ETDCOFF | ETDCOFF | ETDCOFF | ETDCOFF | ETDCOFF | ETDCOFF |
| Reset  | 0         | 0       | 0 0  | 0    |      | 0    | 0    | 0    | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |
| Bits   | 15        | 14      | 13   | 12   | 11   | 10   | 9    | 8    | 7       | 6       | 5       | 4       | 3       | 2       | 1       | 0       |
| R      | ETDC FAIL | 0       | 0    | 0    | 0    | 0    | 0    | 0    | ETDCVAL | ETDCVAL | ETDCVAL | ETDCVAL | ETDCVAL | ETDCVAL | ETDCVAL | ETDCVAL |
| W      | W1C       |         |      |      |      |      |      |      |         |         |         |         |         |         |         |         |
| Reset  | 0         | 0       | 0    | 0    | 0    | 0    | 0    | 0    | 0       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |

## Fields

| Field     | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 ETDCEN | Transceiver Delay Compensation Enable Enables the TDC feature. It can be written in Freeze mode only. See Transmitter delay compensation in the CAN Protocol standard (ISO 11898-1:2015) for details. NOTE TDC must be disabled when the Loop Back Mode is enabled. See CTRL1[LPB]. NOTE 0b - Disable                                                                                                                                                                    |
| 30 TDMDIS | Transceiver Delay Measurement Disable Disables the transceiver delay measurement. When the TDC measurement is disabled, only ETDC[ETDCOFF] determines the secondary sample point position. If TCD measurement is enabled, the sum of the transceiver delay measurement plus the enhanced TDC offset determines the secondary sample point position. Soft reset does not affect this field. This bit can be enabled only if CTRL2[BTE] = 1. NOTE 0b - Enable 1b - Disable |
| 29-23 -   | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 22-16     | Enhanced Transceiver Delay Compensation Offset                                                                                                                                                                                                                                                                                                                                                                                                                           |

Table continues on the next page...

CAN (FlexCAN)

Table continued from the previous page...

| Field       | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|-------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ETDCOFF     | Contains the offset value to be added to the loop delay of the measured transceiver. This value defines the position of the delayed comparison point when bit rate switching is active. See Transceiver delay compensation for details on how the loop delay measurement is performed. This field can be written in Freeze mode only. Its value can be defined in protocol engine (PE) clock periods (CANCLK, see Protocol timing for more details). It must be smaller than the CAN bit duration in the data bit rate for proper operation. Do not write 0 to this field. If CTRL2[BTE] becomes 1 after a chip-level hard reset, this field is read as 1h. NOTE |
| 15 ETDCFAIL | Transceiver Delay Compensation Fail Indicates whether the transceiver delay compensation (TDC) mechanism is out of range. In this case, it is unable to compensate the loop delay of the transceiver and successfully compare the delayed received bits to the transmitted ones. (See Transceiver delay compensation.) This field becomes 0 the first time FlexCAN detects the out of range condition. 0b - In range 1b - Out of range                                                                                                                                                                                                                           |
| 14-8 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 7-0 ETDCVAL | Enhanced Transceiver Delay Compensation Value Contains ETDC[ETDCOFF] added to the measured value of the transceiver loop delay in the latest transmitted CAN FD frame, with BRS = 1. The module only updates this field when ETDC[ETDCEN] = 1. Soft reset affects this field. If ETDC[TDMDIS] = 1, this field stores ETDC[ETDCOFF] only. NOTE                                                                                                                                                                                                                                                                                                                    |

## 50.5.2.37 CAN FD Control (FDCTRL)

## Offset

| Register   | Offset   |
|------------|----------|
| FDCTRL     | C00h     |

## Function

Contains control bits for CAN FD operation. It also defines the data size of message buffers allocated in different partitions of RAM (memory blocks) as described in Table 378.

When an 8-byte payload is selected:

- Block R0 allocates MB0 to MB31.
- Block R1 allocates MB32 to MB63.
- Block R2 allocates MB64 to MB95.
- Block R3 allocates MB96 to MB127.

When a payload larger than eight bytes is selected, the maximum number of message buffers in a block is limited as described below.

Table 378. Number of message buffers

| Payload size   |   Maximum number of message buffers per RAM block |
|----------------|---------------------------------------------------|
| 8 bytes        |                                                32 |
| 16 bytes       |                                                21 |
| 32 bytes       |                                                12 |
| 64 bytes       |                                                 7 |

One memory block fits exactly 32 message buffers with an 8-byte payload. For other possible payload sizes, empty memory may exist between the last message buffer in a block and the beginning of the next block. This empty memory corresponds to less than one message buffer, and must not be used.

Soft reset does not affect the contents of this register.

## Diagram

<!-- image -->

## Fields

| Field   | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31      | Bit Rate Switch Enable                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| FDRATE  | Enables the effect of the Bit Rate Switch (BRS bit) during the data phase of TX messages. When 1, if BRS = 1 in the TX message buffer, frames are transmitted with bit rate switching. When 0, frames are transmitted at a nominal rate, and the BRS bit in the TX MB has no effect. The CPU can write to this field at any time. However, its effect becomes active only under one of these conditions:  The CAN bus is in the Wait for Bus Idle state. |

Table continues on the next page...

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                                                 |
|--------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|              |  The CAN bus is in the Bus Idle state.  The CAN bus is in the Bus Off state.  The current frame under reception or transmission reaches the interframe space. By writing 0 to FDCTRL[FDRATE], the CPU can force all bits in CAN FD messages to be transmitted at nominal bit rate. This transmission occurs regardless of the value in the BRSbit of the TX message buffers. 0b - Disable 1b - Enable |
| 30-27 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                 |
| 26-25 MBDSR3 | Message Buffer Data Size for Region 3 Selects the data size per message buffer for region R3 of message buffers allocated in RAM. This field can be written in Freeze mode only. 00b - 8 bytes 01b - 16 bytes 10b - 32 bytes 11b - 64 bytes                                                                                                                                                              |
| 24 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                 |
| 23-22 MBDSR2 | Message Buffer Data Size for Region 2 Selects the data size per message buffer for region R2 of message buffers allocated in RAM. This field can be written in Freeze mode only. 00b - 8 bytes 01b - 16 bytes 10b - 32 bytes 11b - 64 bytes                                                                                                                                                              |
| 21 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                 |
| 20-19 MBDSR1 | Message Buffer Data Size for Region 1 Selects the data size per message buffer for region R1 of message buffers allocated in RAM. This field can be written in Freeze mode only. 00b - 8 bytes                                                                                                                                                                                                           |

Table continues on the next page...

## Table continued from the previous page...

| Field        | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|              | 01b - 16 bytes 10b - 32 bytes 11b - 64 bytes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 18 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 17-16 MBDSR0 | Message Buffer Data Size for Region 0 Selects the data size per message buffer for region R0 of message buffers allocated in RAM. This field can be written in Freeze mode only. 00b - 8 bytes 01b - 16 bytes 10b - 32 bytes                                                                                                                                                                                                                                                                                                              |
| 15 TDCEN     | Transceiver Delay Compensation Enable Enables the TDC feature. It can be written in Freeze mode only. See Transmitter delay compensation in the CAN Protocol standard (ISO 11898-1:2015) for details. TDC must be disabled when Loopback mode is enabled (see CTRL1[LPB]). CTRL2[BTE] = 1, this field is read as 0 and a write operation has no effect. NOTE 0b - Disable 1b - Enable                                                                                                                                                     |
| 14 TDCFAIL   | Transceiver Delay Compensation Fail Indicates whether the Transceiver Delay Compensation (TDC) mechanism is out of range. In this case, the mechanism cannot compensate for the loop delay of the transceiver and successfully compare the delayed received bits to the transmitted ones (see Transceiver delay compensation). The first time that FlexCAN detects the out-of-range condition, this field becomes 1. If CTRL2[BTE] = 1, this field is read as 0 and a write operation has no effect. NOTE 0b - In range 1b - Out of range |
| 13 -         | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 12-8         | Transceiver Delay Compensation Offset                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |

Table continues on the next page...

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| TDCOFF     | Contains the offset value to be added to the loop delay of the measured transceiver. This value defines the position of the delayed comparison point when bit rate switching is active. See Transceiver delay compensation for details about loop delay measurement. This field can be written in Freeze mode only. Its value can be defined in Protocol Engine Clock periods (CANCLK, see Protocol timing for more details). The value must be smaller than the CANbit duration in the data bit rate for proper operation. If CTRL2[BTE] = 1, TDCOFF is read as 0 and a write operation has no effect. NOTE It is not recommended to set the value of this field to zero. NOTE |
| 7-6 -      | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 5-0 TDCVAL | Transceiver Delay Compensation Value Contains the value of the transceiver loop delay measured from the transmitted EDL-to-R0 transition edge to the respective received one added to FDCTRL[TDCOFF]. This value is an integer multiple of the Protocol Engine Clock period (CANCLK). If CTRL2[BTE] = 1, this field is read as 0. See Protocol timing for details on the loop delay measurement.                                                                                                                                                                                                                                                                                |

## 50.5.2.38 CAN FD Bit Timing (FDCBT)

## Offset

| Register   | Offset   |
|------------|----------|
| FDCBT      | C04h     |

## Function

Stores the CAN bit timing variables used in the data phase of CAN FD messages when the FDCTRL[FDRATE] = 1, compatible with the CAN FD specification. Fields in this register define:

- The time quantum duration
- The number of time quanta per CAN bit
- The sample point position for the data bit rate portion of a CAN FD message with BRS = 1

Soft reset does not affect the contents of this register.

The sum of the Fast Propagation Segment (FPROPSEG) and Fast Phase Segment 1 (FPSEG1) must be at least two time quanta.

Ensure bit time settings and protocol engine tolerance are in compliance with the CAN Protocol standard (ISO 11898-1:2015).

## NOTE

If CTRL2[BTE] = 1, this register is read as zero and a write operation has no effect.

## Diagram

<!-- image -->

| Bits   | 31   | 30       | 29       | 28       | 27       | 26   | 25       | 24       | 23     | 22     | 21     | 20   | 19   | 18   | 17     | 16     |
|--------|------|----------|----------|----------|----------|------|----------|----------|--------|--------|--------|------|------|------|--------|--------|
| R      | 0    |          |          |          |          |      |          |          |        |        |        |      | 0    |      | FRJW   |        |
| W      |      |          |          |          |          |      | FPRESDIV | FPRESDIV |        |        |        |      |      |      | FRJW   |        |
| Reset  | 0    | 0        | 0        | 0        | 0        | 0    | 0        | 0        | 0      | 0      | 0      | 0    | 0    | 0    | 0      | 0      |
| Bits   | 15   | 14       | 13       | 12       | 11       | 10   | 9        | 8        | 7      | 6      | 5      | 4    | 3    | 2    | 1      | 0      |
| R      | 0    |          |          |          |          |      | 0        | 0        |        |        |        | 0    | 0    |      | FPSEG2 | FPSEG2 |
| W      |      | FPROPSEG | FPROPSEG | FPROPSEG | FPROPSEG |      |          |          | FPSEG1 | FPSEG1 | FPSEG1 |      |      |      |        |        |
| Reset  | 0    | 0        | 0        | 0        | 0        | 0    | 0        | 0        | 0      | 0      | 0      | 0    | 0    | 0    | 0      | 0      |

## Fields

| Field          | Function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31-30 -        | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 29-20 FPRESDIV | Fast Prescaler Division Factor Defines the ratio between the PEclock frequency and the serial clock (Sclock) frequency in the data bit rate portion of a CAN FD message with BRS = 1. The Sclock period defines the time quantum of the CAN FD protocol for the data bit rate. This field can be written only in Freeze mode; the module blocks it in other modes. Sclock frequency = PE clock frequency  (FPRESDIV + 1). To minimize errors when processing FD frames, use the same value for this field and for CTRL1[PRESDIV] or CBT[EPRESDIV]. See the first note in CAN FD frames for details. NOTE |
| 19 -           | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 18-16 FRJW     | Fast Resync Jump Width Defines the maximum number of time quanta that one resynchronization can change a bit time in the data bit rate portion of a CAN FD message with BRS = 1. This field can be written only in Freeze mode; the module blocks it in other modes. Resync Jump Width = FSJW + 1. One Time Quantum = one Sclock period.                                                                                                                                                                                                                                                                  |
| 15 -           | Reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 14-10 FPROPSEG | Fast Propagation Segment                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |

Table continues on the next page...

CAN (FlexCAN)

## Table continued from the previous page...

| Field      | Function                                                                                                                                                                                                                                                                                                          |
|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|            | Defines the length of the propagation segment in the bit time in the data bit rate portion of a CAN FD message with BRS = 1. This field can be written only in Freeze mode; the module blocks it in other modes. Propagation Segment Time = FPROPSEG  Time Quanta. One Time Quantum = one Sclock period.         |
| 9-8 -      | Reserved                                                                                                                                                                                                                                                                                                          |
| 7-5 FPSEG1 | Fast Phase Segment 1 Defines the length of phase segment 1 in the bit time in the data bit rate portion of a CAN FD message with BRS = 1. This field can be written only in Freeze mode; the module blocks it in other modes. Phase Segment 1 = (FPSEG1 + 1)  Time Quanta. One Time Quantum = one Sclock period. |
| 4-3 -      | Reserved                                                                                                                                                                                                                                                                                                          |
| 2-0 FPSEG2 | Fast Phase Segment 2 Defines the length of phase segment 2 in the data bit rate portion of a CANFDmessage with BRS = 1. This field can be written only in Freeze mode; the module blocks it in other modes. Phase Segment 2 = (FPSEG2 + 1)  Time Quanta. One Time Quantum = one Sclock period.                   |

## 50.5.2.39 CAN FD CRC (FDCRC)

## Offset

| Register   | Offset   |
|------------|----------|
| FDCRC      | C08h     |

## Function

Provides information about the cyclic redundancy check (CRC) of transmitted messages.

FlexCAN uses different CRC polynomials for different frame formats.

- The CRC\_15 polynomial is used for all frames in CAN format.
- The CRC\_17 polynomial is used for frames in CAN FD format with a DATA FIELD up to sixteen bytes.
- The CRC\_21 polynomial is used for frames in CAN FD format with a DATA FIELD longer than sixteen bytes.

Each polynomial shown below results in a Hamming distance of 6. This register is updated at the same time that the TX Interrupt flag is set.

## Diagram

<!-- image -->

| Bits   | 31       | 30       | 29       | 28       | 27       | 26       | 25       | 24       | 23       | 22       | 21       | 20       | 19       | 18       | 17       | 16       |
|--------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
| R      | 0        | FD_MBCRC | FD_MBCRC | FD_MBCRC | FD_MBCRC | FD_MBCRC | FD_MBCRC | FD_MBCRC | 0        | 0        | 0        | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC |
| W      |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          |
| Reset  | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        |
| Bits   | 15       | 14       | 13       | 12       | 11       | 10       | 9        | 8        | 7        | 6        | 5        | 4        | 3        | 2        | 1        | 0        |
| R      | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC | FD_TXCRC |
| W      |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          |          |
| Reset  | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        | 0        |

## Fields

| Field          | Function                                                                                                                                                                                                                                                                                                                                                                                |
|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 -           | Reserved                                                                                                                                                                                                                                                                                                                                                                                |
| 30-24 FD_MBCRC | CRC Message Buffer Number for FD_TXCRC Indicates the number of the message buffer corresponding to the value in FDCRC[FD_TXCRC], for bothFD and non-FD frames. It reports the same information as in CRCR[MBCRC].                                                                                                                                                                       |
| 23-21 -        | Reserved                                                                                                                                                                                                                                                                                                                                                                                |
| 20-0 FD_TXCRC  | Extended Transmitted CRC value Contains the CRC value calculated over the most recent transmitted message. Different CRC polynomials are used for different frame formats. For CRC_15 and CRC_17, the six most significant bits and the four most significant bits are reported as zeroes, respectively. For CRC_15, this field has the same content as Cyclic Redundancy Check (CRCR). |

<!-- formula-not-decoded -->

Equation 34. CRC polynomial used on CAN frame

## NOTE

See CRC sequence calculation in the CAN Protocol standard (ISO 11898-1:2015) for details.

## 50.5.2.40 Enhanced RX FIFO Control (ERFCR)

## Offset

| Register   | Offset   |
|------------|----------|
| ERFCR      | C0Ch     |

## Function

Defines the Enhanced RX FIFO configuration.

This register can be written only in Freeze mode.

Soft reset does not affect any of the contents of this register.

## Diagram

<!-- image -->

## Fields

<!-- image -->

| Field       | Function                                                                                                                                                                                                      |
|-------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 31 ERFEN    | Enhanced RX FIFO enable Enables the Enhanced RX FIFO. If MCR[RFEN] = 1, do not write 1 to this field. NOTE 0b - Disable 1b - Enable                                                                           |
| 30-26 DMALW | DMA Last Word Defines the last DMA address for each Enhanced RX FIFO element. This table shows the number of elements and the last address for each Enhanced RX FIFO element according to the value of DMALW. |

CAN (FlexCAN)